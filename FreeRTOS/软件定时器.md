# 软件定时器是什么
## 简介
* **软件定时器**就是一个用户可以自己设置的“闹钟”
* 在FreeRTOS里，设置“软件定时器”的**数量不受限制**，它们都是基于**系统滴答计时器中断**(Tick Interrupt)来实现的。
## 软件定时器的类型
* 通过软件定时器**可以实现的两种类型**：
	* **一次性(One-shot timers)：** 在某个时间点运行函数（运行回调函数），除非手动再次启动他，否则不会重启
	* **自动重载定时器(Auto-reload timers)：** 周期性的运行函数，系统会自动重启
## 软件定时器的状态
* **运行：** 运行态的定时器，当指定时间到达之后，它的回调函数会被调用
* **休眠：** 休眠的定时器还可以通过句柄来访问它，但是它不再运行，它的回调函数不会被调用
# 配置（FreeRTOSConfig.h）
```c
//打开定时器
#define configUSE_TIMERS                1
//定时器的优先级
#define configTIMER_TASK_PRIORITY       50
//定时器栈大小
#define configTIMER_TASK_STACK_DEPTH    50
//定时器队列大小
#define configTIMER_QUEUE_LENGTH        50
```
# 相关函数
## 句柄
```c
//定义定时器句柄
TimerHandle_t xTimer;
```
## 创建软件定时器
```c
/*
-功能：
用于创建一个软件定时器对象。

-参数：
const char * const pcTimerName：定时器名称字符串指针。
TickType_t xTimerPeriodInTicks：定时器周期，以系统节拍为单位。
UBaseType_t uxAutoReload：定时器类型（pdTRUE为周期性，pdFALSE为一次性）。
void * pvTimerID：用户定义的定时器ID 指针，没什么写的的话ID写为NULL就行。
TimerCallbackFunction_t pxCallbackFunction：定时器回调函数指针。

-返回值：
返回一个TimerHandle_t类型的值，它是指向新创建的定时器对象的句柄。如果创建失败（通常是由于内存不足），则返回NULL。
*/
TimerHandle_t xTimerCreate( const char * const pcTimerName, TickType_t xTimerPeriodInTicks, UBaseType_t uxAutoReload, void * pvTimerID, TimerCallbackFunction_t pxCallbackFunction );
```
## 启动指定定时器
```c
/*
-功能：
启动一个已经创建的定时器。如果定时器已经在运行，这个函数的操作没有影响。如果定时器已经过期并且是一次性定时器，它会重新启动定时器。

-参数：
xTimer：要启动的定时器的句柄，该句柄是xTimerCreate函数返回的值。
xTicksToWait：等待定时器启动操作完成的最大系统节拍数。如果设置为 0，表示不等待，直接返回。这个参数主要用于在定时器启动操作需要同步的情况下，比如在等待一个资源（如互斥锁）被释放后再启动定时器。通常情况下，可以设置为 0。

-返回值：
BaseType_t是返回值类型，pdPASS表示成功，pdFAIL表示失败（通常是由于参数错误或者定时器已经在运行并且不能被重新启动）。
*/
BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xTicksToWait );
```
## 停止一个正在运行的定时器
```c
/*
-功能：停止一个正在运行的定时器。

-参数：
xTimer：要停止的定时器的句柄。
xTicksToWait：等待定时器停止操作完成的最大系统节拍数。如果设置为 0，表示不等待，直接返回。

-返回值：
返回pdPASS表示定时器停止成功，返回pdFAIL表示停止失败（通常是由于参数错误或者定时器已经停止）。
*/
BaseType_t xTimerStop( TimerHandle_t xTimer, TickType_t xTicksToWait );
```
## 重置一个正在运行的定时器
```c
/*
-功能：重置一个正在运行的定时器，将其剩余时间重新设置为初始周期。如果定时器已经停止，这个函数的操作没有影响。

-参数：
xTimer：要重置的定时器的句柄。
xTicksToWait：等待定时器重置操作完成的最大系统节拍数。如果设置为 0，表示不等待，直接返回。

-返回值：
返回pdPASS表示定时器重置成功，返回pdFAIL表示重置失败（通常是由于参数错误或者定时器已经停止）。
*/
BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xTicksToWait );
```
## 改变指定定时器的周期
```c
/*
-功能：
改变一个已经创建的定时器的周期，使其按照新设定的周期来运行。

-参数：
xTimer：要改变周期的定时器的句柄，用于确定具体要更改周期的定时器。
xNewPeriod：新的定时器周期，以系统节拍为单位，用于设定定时器后续的触发间隔时间。
xTicksToWait：等待周期改变操作完成的最大系统节拍数，设置为 0 时意味着不等待，直接返回，满足不同应用场景对等待的要求。

-返回值：
返回pdPASS表示周期改变成功，返回pdFAIL表示改变失败（通常是由于参数错误或者定时器正在执行回调函数等原因导致无法即时更改周期）。
*/
BaseType_t xTimerChangePeriod( TimerHandle_t xTimer, TickType_t xNewPeriod, TickType_t xTicksToWait );
```
## 检查定时器状态
```c
/*
- 功能：
检查一个定时器是否处于活动状态（正在运行或等待运行），以便在程序中知晓定时器的当前运行情况。

-参数：
xTimer：要检查的定时器的句柄，指定需要确认状态的具体定时器。

-返回值：
返回pdTRUE表示定时器是活动的，返回pdFALSE表示定时器是非活动的（即已经停止）。
*/
BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer );
```
## 获取定时器到期时间
```c
/*
-功能：
用于获取指定定时器的到期时间。这个到期时间是以系统节拍计数（tick count）为单位来表示的，它可以帮助用户了解定时器距离到期还有多少个系统节拍，或者在定时器已经到期的情况下，获取其最后一次到期的时间。

-参数：
xTimer：这是一个TimerHandle_t类型的参数，代表要获取到期时间的定时器句柄。这个句柄是在定时器创建时通过xTimerCreate函数返回的，用于唯一标识一个定时器。

-返回值：
函数返回一个TickType_t类型的值。这个值表示定时器的到期时间（以系统节拍计数）。如果返回值为0，通常表示定时器没有运行或者出现了错误情况（如无效的定时器句柄）。
*/
TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer );
```
# 示例代码
```c
#include "stm32f10x.h"  
#include "Delay.h"
#include "OLED.h"
#include "Serial2.h"
#include "KEY.h"
#include "LED.h"
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "event_groups.h"
#include "stdio.h"

//使用定时器模拟屏幕待机，正常就是LED1ON ，5秒内没有按下任何按键LEDOFF
TaskHandle_t TaskScreenHandle = NULL;
TaskHandle_t SerialPrintHandle = NULL;
TaskHandle_t CreateTaskHandle = NULL;

//定义串口发送数据的队列句柄
QueueHandle_t xSerialMesQueue1;

//创建定时器句柄
 TimerHandle_t xLEDTimers;

//定时器回调函数
void pxCallbackLEDFunction(TimerHandle_t xTimer)
{
	LED1_OFF();
}

//屏幕控制函数
void vTaskScreenFunction( void *pvParameters)
{
	TickType_t xRemainingTime; //记录剩下的时间
	char str[30];
	while(1)
	{	
		//如何按键KEY1被按下了,重置定时器
		if(KEY1_Press()==1)
		{
			xTimerReset(xLEDTimers,10);//数字10：调用任务处于阻塞状态以等待停止命令成功发送到定时器命令队列的时间（单位：滴答）
		}
		//打印当前定时器还需要多久调用回调函数
		xRemainingTime = xTimerGetExpiryTime( xLEDTimers ) - xTaskGetTickCount();
		sprintf(str,"%d",xRemainingTime);
		xQueueSendToBack(xSerialMesQueue1,str,portMAX_DELAY );
	}
}

void vSerialPrintFunction( void *pvParameters )
{
	char sendstr[50];
	while(1)
	{
		//1.等待队列里面的消息
		xQueueReceive(
                          xSerialMesQueue1,
                          sendstr,
                          portMAX_DELAY
		);		
		//2.发送消息
		Serial2_SendStringLine(sendstr);
	}
}

void CreateTaskFunction( void *pvParameters )
{
	taskENTER_CRITICAL();
	//创建任务

	xTaskCreate( vTaskScreenFunction, //指向任务入口函数的指针
                         "TaskScreen",//任务的描述性名称
                         400, //如果堆栈宽度为 32 位，uxStackDepth 为 400， 则将分配 1600 字节用作任务堆栈
                         NULL,//作为参数传递给所创建任务的值
                         1,//创建的任务将以该指定优先级执行。
                         &TaskScreenHandle  //用于将句柄传递至由 xTaskCreate() 函数创建的任务
                       );


	
	xTaskCreate( vSerialPrintFunction, //指向任务入口函数的指针
                         "SerialPrint",//任务的描述性名称
                         400, //如果堆栈宽度为 32 位，uxStackDepth 为 400， 则将分配 1600 字节用作任务堆栈
                         NULL,//作为参数传递给所创建任务的值
                         4,//创建的任务将以该指定优先级执行。
                         &SerialPrintHandle  //用于将句柄传递至由 xTaskCreate() 函数创建的任务
                       );
					   
	taskEXIT_CRITICAL();
	//回收资源
	vTaskDelete(NULL);
}

int main(void)
{
	Delay_s(1); //上电后等设备准备好
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4); //一个project中定义一次即可
	//初始化硬件
	OLED_Init();
	OLED_Clear();		
	Serial2_Init();	
	KEY_Init();
	MYLED_Init();		
	
	//创建队列
	char message[50];
	xSerialMesQueue1 = xQueueCreate( 20, sizeof( message ) );
	//创建定时器
	xLEDTimers = xTimerCreate
	( "LEDTimer",//定时器名字
                   5000,//周期5秒
                   pdFALSE,//不周期新重载
                   ( void * ) 0,
                   pxCallbackLEDFunction );
   //开启屏幕背光，开始定时器
	LED1_ON();
	xTimerStart(xLEDTimers,10);			   
	
	BaseType_t xReturned = xTaskCreate( CreateTaskFunction, //指向任务入口函数的指针
                         "CreateTask",//任务的描述性名称
                         400, //如果堆栈宽度为 32 位，uxStackDepth 为 400， 则将分配 1600 字节用作任务堆栈
                         NULL,//作为参数传递给所创建任务的值
                         1,//创建的任务将以该指定优先级执行。
                         &CreateTaskHandle  //用于将句柄传递至由 xTaskCreate() 函数创建的任务
                       );
	//判断是否创建成功
    if( xReturned != pdPASS )
    {
        OLED_ShowString(1,1,"Create Task Fail.");
    }				   
	//启动任务，开始调度器
	vTaskStartScheduler();
}

```