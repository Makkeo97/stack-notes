# 一、信号量

信号量可以实现任务之间同步或临界资源的互斥访问， 常用于协助一组相互竞争的任务来访 
问临界资源。

信号量是一个**非负整数**，所有获取它的任务都会将该整数减一，当该整数值为零时，所有试图获取它的任务都将处于阻塞状态。通常一个信号量的计 数值用于对应有效的资源数，表示剩下的可被占用的互斥资源数。其值的含义分两种情况：
* 0： 表示没有积累下来的释放信号量操作，且有可能有在此信号量上阻塞的任务。 
* 正值，表示有一个或多个释放信号量操作。
# 二、头文件
```c
#include "semphr.h" 
```
# 三、二值信号量
## 函数
```c
//定义一个二值信号量的句柄
SemaphoreHandle_t xBinarySemaphore;

//等待信号量
xSemaphoreTake( xBinarySemaphore,portMAX_DELAY);

//在中断中等待信号量
BaseType_t xSemaphoreTakeFromISR( 
SemaphoreHandle_t xSemaphore, // 要获取的信号量句柄 
BaseType_t *pxHigherPriorityTaskWoken // 如果设置为 pdTRUE，则唤醒更高优先级的任务 );

//释放信号量
xSemaphoreGive( xBinarySemaphore);

//从中断服务程序中释放信号量，并获取是否有高优先级任务被唤醒
BaseType_t xHigherPriorityTaskWoken = pdFALSE;
xSemaphoreGiveFromISR(xBinarySemaphore, &xHigherPriorityTaskWoken);

//创建二值信号量
xBinarySemaphore = xSemaphoreCreateBinary();

//删除一个信号量，包括二值信号量，计数信号量，互斥量和递归互斥量
vSemaphoreDelete(SemaphoreHandle_t xSemaphore )
```
# 四、计数信号量
## （1）配置（FreeRTOSConfig.h）
```c
#define configUSE_COUNTING_SEMAPHORES    1 //开启计数信号量
```
## （2）相关函数
```c
//定义一个计数信号量的句柄
SemaphoreHandle_t xCountingSemaphore;

//等待信号量
xSemaphoreTake( xCountingSemaphore,portMAX_DELAY);

//在中断中等待信号量
BaseType_t xSemaphoreTakeFromISR( 
SemaphoreHandle_t xSemaphore, // 要获取的信号量句柄 
BaseType_t *pxHigherPriorityTaskWoken // 如果设置为 pdTRUE，则唤醒更高优先级的任务 );

//释放信号量
xSemaphoreGive( xCountingSemaphore);

//从中断服务程序中释放信号量
BaseType_t xHigherPriorityTaskWoken = pdFALSE;
xSemaphoreGiveFromISR(xCountingSemaphore, &xHigherPriorityTaskWoken);

//获取剩余信号量的值
uint8_t count = uxSemaphoreGetCount(xCountingSemaphore);

//创建计数信号量，第一个参数为最大计数值，第二个参数为初始值，返回值是句柄名，创建后开始运行
xCountingSemaphore = xSemaphoreCreateCounting(10,10);

//删除一个信号量，包括二值信号量，计数信号量，互斥量和递归互斥量
vSemaphoreDelete(SemaphoreHandle_t xSemaphore )
```
# 五、互斥信号量（互斥锁）
## （1）作用

互斥信号量是一种特殊的二值信号量，可以实现**优先级继承**的机制：

优先级继承算法是指，暂时提高某个占有某种资源的低优先级任务的优先级，使之与在所有等待该资源的任务中优先级最高那个任务的优先级相等，而当这个低优先级任务执行完毕释放该资源时，优先级重新回到初始设定值。因此，继承优先级的任务避免了系统资源被任何中间优先级的任务抢占。

* **举例：**
	现在有 3 个任务分别为 H 任务（High）、 M 任务（Middle）、 L 任务（Low）， 3 个任务的优先级顺序为 H 任务>M  任务>L 任务。正常运行的时候 H 任务可以打断 M 任务与 L 任务， M 任务可以打断 L  任务，假设系统中有一个资源被保护了，此时该 资源被 L 任务正在使用中，某一刻， H 任务需要使用该资源，但是 L 任务还没使用完，  H 任务则因为申请不到资源而进入阻塞态， L 任务继续使用该资源，此时已经出现了“**优先级反转**”现象，高优先级任务在等着低优先级的任务执行，如果在 L 任务执行的时候刚好M任务被唤醒了，由于 M 任务优先级比 L 任务优先级高，那么会打断 L 任务，抢占了CPU 的使 用权，直到 M 任务执行完，再把 CPU 使用权归还给 L 任务， L 任务继续执行，等到执行完 毕之后释放该资源， H  任务此时才从阻塞态解除，使用该资源。这个过程，本来是最高优先 级的 H 任务，在等待了更低优先级的 L 任务与 M 任务，其阻塞的时间是  M任务运行时间 +L 任务运行时间，这只是只有 3  个任务的系统，假如很多个这样子的任务打断最低优先级 的任务，那这个系统最高优先级任务岂不是崩溃了，这个现象是绝对不允许出现的，高优先级的任务必须能及时响应。
	
	就需要使用互斥信号量了，在使用互斥信号量后，L拿到锁后执行了一会儿，M来了，因为M没有上锁，所以M一直执行，M执行一会儿后H来了，因为H需要用锁，这个时候就会出现优先级继承，L的优先级被提到和H一样，M被立刻打断，以便于L执行完后释放锁给优先级更高的H用，L释放锁后，优先级就会回到他本身的优先级。

## （2）配置文件（FreeRTOSConfig.h）
```c
#define configUSE_MUTEXES 1 //开启互斥信号量
```
## （3）相关函数
```c
//定义一个互斥信号量的句柄
SemaphoreHandle_t xMutexSemaphore;

//等待信号量
xSemaphoreTake( xMutexSemaphore,portMAX_DELAY);

//释放信号量
xSemaphoreGive( xMutexSemaphore);

//互斥信号量不能在中断服务程序中释放信号量

//创建一个互斥信号量
xMutexSemaphore = xSemaphoreCreateMutex();

//删除一个信号量，包括二值信号量，计数信号量，互斥量和递归互斥量
vSemaphoreDelete(SemaphoreHandle_t xSemaphore )
```
# 六、递归信号量
* **可以重复获取调用**的信号量，本来按照信号量的特性，每获取一次可用信号量个数就会减少 一个，但是递归则不然， 对于已经获取递归互斥量的任务可以**重复获取该递归互斥量**， 该任 务拥有递归信号量的所有权。 任务成功**获取几次递归互斥量， 就要返还几次**，**在此之前递归互斥量都处于无效状态**， 其他任务无法获取， 只有持有递归信号量的任务才能获取与释放。
```c
//定义一个递归信号量
SemaphoreHandle_t xRecursiveMutexSemaphore;

//获取递归信号量
xSemaphoreTakeRecursive( xRecursiveMutexSemaphore,portMAX_DELAY);

//释放递归信号量
xSemaphoreGiveRecursive( xRecursiveMutexSemaphore);

//创建递归信号量
xRecursiveMutexSemaphore = xSemaphoreCreateRecursiveMutex();

//删除一个信号量，包括二值信号量，计数信号量，互斥量和递归互斥量
vSemaphoreDelete(SemaphoreHandle_t xSemaphore )
```