Qt串口通信 
在Qt框架中实现串口通信主要依赖于Qt Serial Port 模块，这是一个提供访问硬件串行接口的跨平 
台库。
# 一、Qt Serial Port 模块 
* **引入模块：**首先需要确保你的项目文件(.pro)中包含了 `serialport` 模块，例如：

```cpp
QT += serialport
```

* **核心类：**
  * `QSerialPort` ：该类提供了对串口的读写操作以及串口参数的配置功能，例如设置波特率、数据位、停止位、奇偶校验位等。
  * `QSerialPortInfo` ：这个类用于获取系统中可用串口的信息，像串口名称、描述等，方便开发者选择合适的串口进行通信。 

* **基本步骤：**
  1. 查找可用的串口设备：可以使用 `QSerialPortInfo::availablePorts()` 来获取系统中所有可用的串口设备列表。
  2. 打开串口：创建一个 `QSerialPort` 实例，并调用其 `setPortName()` 方法指定要使用的串口，然后通过 `open()` 方法打开该端口。
  3. 配置串口参数：包括波特率、数据位、停止位和校验方式等，这些都可以通过相应的 `setter` 方法设置，例如 `setBaudRate()` , `setDataBits()` , `setStopBits()` , 和 `setParity()` 。 
  4. 读写数据：使用 `read()` 或 `write()` 方法来进行数据的发送与接收。
  5. 关闭串口：完成通信后，记得调用 `close()` 方法关闭串口资源。

## 1. 查找可用串口

```cpp
#include <QCoreApplication> 
#include <QSerialPortInfo> 
#include <QDebug>

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    // 获取所有可用的串口信息
    foreach (const QSerialPortInfo &info, QSerialPortInfo::availablePorts()) { 
        qDebug() << "Name : " << info.portName();
        qDebug() << "Description : " << info.description();
    }

    return a.exec();
}
```

## 2. 打开串口

利用 `QSerialPort` 类打开指定的串口，并对串口参数做出配置。

```cpp
#include <QCoreApplication> 
#include <QSerialPort>
#include <QSerialPortInfo> 
#include <QDebug>

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    QSerialPort serial;
    serial.setPortName("COM1"); // 设置串口名称
    serial.setBaudRate(QSerialPort::Baud9600); // 设置波特率
    serial.setDataBits(QSerialPort::Data8); // 设置数据位
    serial.setParity(QSerialPort::NoParity); // 设置奇偶校验位 
    serial.setStopBits(QSerialPort::OneStop); // 设置停止位

    if (serial.open(QIODevice::ReadWrite)) { 
        qDebug() << "打开成功";
    } else {
        qDebug() << "打开失败";
    }

    return a.exec();
}
```

## 3. 读写数据

打开串口之后，就可以使用 `QSerialPort` 类的 `write()` 方法发送数据，使用 `readyRead()` 信号 和 `readAll()` 方法接收数据。

* **获取有效端口：**

```cpp
// 获取所有有效端口
QList<QSerialPortInfo> portList = QSerialPortInfo::availablePorts(); 
for (QSerialPortInfo info : portList)
{
    qDebug() << "端口名：" << info.portName() << "，端口描述：" << info.description();
    // 在UI控件上添加数据
    ui->comboBoxPort->addItem(info.portName());
}
```

* **获取标准的波特率：**

```cpp
// 获取标准的波特率
QList<int> baudRates =  QSerialPortInfo::standardBaudRates(); 
for (int i = 0; i < baudRates.size(); i++)
{
    qDebug() << QString::number(baudRates.at(i));
}
```

* **设置停止位：**

```cpp
// 在UI控件上添加数据
ui->comboBoxStopbit->addItem("1", QSerialPort::OneStop); 
ui->comboBoxStopbit->addItem("1.5", QSerialPort::OneAndHalfStop); 
ui->comboBoxStopbit->addItem("2", QSerialPort::TwoStop);
```

* **设置数据位：**

```cpp
// 在UI控件上添加数据
ui->comboBoxDataBit->addItem("5", QSerialPort::Data5); 
ui->comboBoxDataBit->addItem("6", QSerialPort::Data6); 
ui->comboBoxDataBit->addItem("7", QSerialPort::Data7); 
ui->comboBoxDataBit->addItem("8", QSerialPort::Data8);
```

* **设置校验位：**

```cpp
// 在UI控件上添加数据
ui->comboBoxParity->addItem("NoParity", QSerialPort::NoParity); 
ui->comboBoxParity->addItem("EvenParity", QSerialPort::EvenParity); 
ui->comboBoxParity->addItem("OddParity", QSerialPort::OddParity); 
ui->comboBoxParity->addItem("SpaceParity", QSerialPort::SpaceParity); 
ui->comboBoxParity->addItem("MarkParity", QSerialPort::MarkParity);
```

* **打开串口：**

```cpp
// 点击打开串口按钮绑定的槽函数
void MainWindow::on_pushButton_clicked()
{
    if (serialPort.isOpen())
    {
        serialPort.close();
        ui->pushButton->setText("打开串口");
    }
    else
    {
        //获取串口
        auto portName = ui->comboBoxPort->currentText();
        //获取波特率
        auto baudRate = ui->comboBoxBaudRate->currentText().toInt(); 
        //获取数据位
        auto dataBits = ui->comboBoxDataBit-
>currentData().value<QSerialPort::DataBits>();
        //获取停止位
        auto stopBits = ui->comboBoxStopbit-
>currentData().value<QSerialPort::StopBits>();
        //获取校验位
        auto parity = ui->comboBoxParity->currentData().value<QSerialPort::Parity>();

        serialPort.setPortName(portName); 
        serialPort.setBaudRate(baudRate); 
        serialPort.setDataBits(dataBits); 
        serialPort.setStopBits(stopBits); 
        serialPort.setParity(parity);
        //打开串口
        if (serialPort.open(QIODevice::ReadWrite))
        {
            //接受数据
            ui->pushButton->setText("关闭串口");
        }
        else
        {
            QMessageBox::information(this, "", "打开失败：" + 
serialPort.errorString());
            return ;
        }
        //连接槽函数
        connect(&serialPort, &QSerialPort::readyRead, this, &MainWindow::onReadyRead); 
    }
}
```

* **发送数据：**

```cpp
// 点击发送按钮绑定的槽函数
void MainWindow::on_pushButton_send_clicked()
{
    QString data = ui->plainTextEditSend->toPlainText(); 
    serialPort.write(data.toLocal8Bit());
}
```

* **接收数据：**

```cpp
// 点击接收按钮绑定的槽函数
void MainWindow::onReadyRead()
{
    QString text = serialPort.readAll();
    ui->plainTextEdit_recive->setPlainText(text);
}
```

这段代码展示了如何初始化串口、设置参数、连接信号与槽以便在数据到达时进行处理。

# 二、串口相关的概念

## 1. 波特率（Baud Rate）

* 这是衡量串口通信速度的一个指标，表示每秒钟可以传输的最大符号数（比特数）。
* 通信两端的波特率必须相同，否则会导致数据无法正确解析。 
* **常见值：**4800、9600、19200、38400、57600、115200等。

## 2. 数据位（Data Bits）

* 数据位是指每个字符实际包含的有效数据位数，通常为5到9位。
* 数据位应与实际传输的数据格式匹配。例如，ASCII字符通常使用8位数据位。 
* 常见值：
  * `QSerialPort::Data5` ：5位 
  * `QSerialPort::Data6` ：6位 
  * `QSerialPort::Data7` ：7位 
  * `QSerialPort::Data8` ：8位（最常用）

## 3. 停止位（Stop Bits） 

* 停止位用于标记一个字符传输的结束。它可以是1位、1.5位或2位。

* 用于同步接收端和发送端，确保数据帧的完整性。 
* 常见值：
  * `QSerialPort::OneStop` ：1位（最常用） 
  * `QSerialPort::OneAndHalfStop` ：1.5位 
  * `QSerialPort::TwoStop` ：2位

## 4. 校验位（Parity Bit） 
* 用于检测数据传输错误的一种简单方法，分为无校验、奇校验和偶校验等。

* 如果通信环境容易受到干扰，可以选择奇校验或偶校验以提高数据可靠性。通过计算数据位中的 “1”的奇偶性来检测错误。

* 假设我们发送一个字符 `'A'` （ASCII码为 `0x41` ，二进制为 `0100 0001` ），并且使用8位数据位和偶校验：
  1. 数据位：`0100 0001` （包含两个 “1” ）。
  2. 偶校验：为了使 “1” 的总数为偶数，校验位需要为 `0` 。 
  3. 最终发送的数据帧：`0100 0001 0` （包括校验位）。
  4. 如果接收方发现接收到的数据帧中 “1” 的总数不是偶数，则可以判断数据传输错误。 

* 常见值：
  * `QSerialPort::NoParity` ：无校验（最常用） 
  * `QSerialPort::EvenParity`：偶校验（数据位中“1”的个数为偶数） 
  * `QSerialPort::OddParity`：奇校验（数据位中“1”的个数为奇数） 
  * `QSerialPort::SpaceParity`：空格校验（始终为0） 
  * `QSerialPort::MarkParity`：标记校验（始终为1）

# 三、串口助手实验

## 1. qmake

```cpp
QT       += serialport
```

## 2. UI设计

![image-20250322171317757](./assets/image-20250322171317757.png)

## 3. mainwindow.h

```cpp
#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow>
#include <QSerialPort>     //提供访问串口的功能
#include <QSerialPortInfo> //提供系统中存在的串口信息
#include <QDebug>          //debug用

namespace Ui {
class MainWindow;
}

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    explicit MainWindow(QWidget *parent = nullptr);
    ~MainWindow();

private slots:

    void on_Button_openserial_clicked();//点击打开串口按钮

    void ReadData();//串口读数据（接收数据）

    void on_Button_send_clicked();//点击发送按钮

private:
    Ui::MainWindow *ui;
    QSerialPort *serial;//定义串口对象
};

#endif // MAINWINDOW_H
```

## 4. mainwindow.cpp

```cpp
#include "mainwindow.h"
#include "ui_mainwindow.h"

// 构造函数，初始化主窗口
MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui->setupUi(this);

    // 获取系统中所有可用的串口信息
    QList<QSerialPortInfo> list = QSerialPortInfo::availablePorts();
    // 遍历所有可用的串口，并将串口名称添加到下拉栏中
    for(int i=0; i<list.size(); i++)
    {
        ui->comboBox_port->addItem(list.at(i).portName());
    }

    // 创建一个新的串口对象
    serial = new QSerialPort;

    // 连接信号与槽：当串口有数据可读时，调用ReadData函数
    QObject::connect(serial, &QSerialPort::readyRead, this, &MainWindow::ReadData);
}

// 析构函数，释放UI对象
MainWindow::~MainWindow()
{
    delete ui;
}

// 点击打开串口按钮的槽函数
void MainWindow::on_Button_openserial_clicked()
{
    // 判断当前按钮的文本是否为“打开串口”
    if(ui->Button_openserial->text() == "打开串口")
    {
        // 设置串口名称为下拉栏中选中的串口名称
        serial->setPortName(ui->comboBox_port->currentText());

        // 根据下拉栏的选择设置波特率
        switch (ui->comboBox_baud->currentIndex())
        {
        case 0: serial->setBaudRate(QSerialPort::Baud115200); break; // 115200
        case 1: serial->setBaudRate(QSerialPort::Baud9600);   break; // 9600
        default: break;
        }

        // 根据下拉栏的选择设置数据位数
        switch (ui->comboBox_databit->currentIndex())
        {
        case 0: serial->setDataBits(QSerialPort::Data8); break; // 8位数据位
        case 1: serial->setDataBits(QSerialPort::Data6); break; // 6位数据位
        default: break;
        }

        // 根据下拉栏的选择设置校验位
        switch (ui->comboBox_parity->currentIndex())
        {
        case 0: serial->setParity(QSerialPort::NoParity);   break; // 无校验位
        case 1: serial->setParity(QSerialPort::EvenParity); break; // 偶校验
        case 2: serial->setParity(QSerialPort::OddParity);  break; // 奇校验
        default: break;
        }

        // 根据下拉栏的选择设置停止位
        switch (ui->comboBox_stopbit->currentIndex())
        {
        case 0: serial->setStopBits(QSerialPort::OneStop); break; // 1位停止位
        case 1: serial->setStopBits(QSerialPort::OneAndHalfStop); break; // 1.5位停止位
        case 2: serial->setStopBits(QSerialPort::TwoStop); break; // 2位停止位
        default: break;
        }

        // 设置流控制为无流控制
        serial->setFlowControl(QSerialPort::NoFlowControl);

        // 尝试以读写模式打开串口，并检查是否成功
        bool info = serial->open(QIODevice::ReadWrite);
        if(info == true)
        {
            qDebug() << "success"; // 打印成功信息
            // 改变label的颜色为绿色，表示串口已打开
            ui->label_light->setStyleSheet("background-color:rgb(0,255,0);border-radius:5px;");
            // 禁用所有下拉栏，防止在串口打开时修改设置
            ui->comboBox_port->setEnabled(false);
            ui->comboBox_baud->setEnabled(false);
            ui->comboBox_databit->setEnabled(false);
            ui->comboBox_parity->setEnabled(false);
            ui->comboBox_stopbit->setEnabled(false);
            // 将按钮文本改为“关闭串口”
            ui->Button_openserial->setText(tr("关闭串口"));
        }
        else
        {
            qDebug() << "fail"; // 打印失败信息
        }
    }
    else
    {
        // 关闭串口
        serial->clear(); // 清空串口缓冲区
        serial->close();  // 关闭串口
        // 改变label的颜色为红色，表示串口已关闭
        ui->label_light->setStyleSheet("background-color:rgb(255,0,0);border-radius:5px;");
        // 恢复所有下拉栏的使能状态，允许用户修改设置
        ui->comboBox_port->setEnabled(true);
        ui->comboBox_baud->setEnabled(true);
        ui->comboBox_databit->setEnabled(true);
        ui->comboBox_parity->setEnabled(true);
        ui->comboBox_stopbit->setEnabled(true);
        // 将按钮文本改为“打开串口”
        ui->Button_openserial->setText(tr("打开串口"));
    }
}

// 接收数据的槽函数
void MainWindow::ReadData()
{
    // 读取串口缓冲区中的所有数据
    QByteArray buf = serial->readAll();
    // 将读取到的数据追加显示在文本浏览器中
    ui->textBrowser->append(buf);
}

// 点击发送按钮的槽函数
void MainWindow::on_Button_send_clicked()
{
    // 检查串口是否已打开
    if (serial->isOpen())
    {
        // 获取要发送的数据：从lineEdit_send中获取文本内容，并添加换行符
        QString sendData = ui->lineEdit_send->text() + "\n";
        // 将字符串转换为QByteArray格式
        QByteArray data = sendData.toUtf8();
        // 通过串口发送数据
        serial->write(data);
    }
    else
    {
        qDebug() << "serial is not open"; // 如果串口未打开，打印错误信息
    }
}
```

