## 模型视图结构（一）

### 一、模型/视图结构概述

> 模型/视图结构一种将数据存储和界面展示分离的编程方法。模型用于存储数据，视图组件用来显示模型中的数据。

在Qt中，模型-视图架构（Model-View Architecture）被广泛应用于数据驱动的用户界面设计中。与传统的MVC（Model-View-Controller）和MVVM（Model-View-ViewModel）模式类似，Qt的模型-视图架构也强调数据和表示的分离。Qt中的模型/视图架构主要涉及三个核心概念：模型（Model）、视图（View）和委托（Delegate）。

#### 1、模型（Model）

> 模型是数据的容器。定义了数据的结构和逻辑，以及数据的访问和更新规则。

常见的模型包括`QStandardItemModel`（用于通用的数据存储）、`QSqlTableModel`（用于SQL数据库）和`QFileSystemModel`（用于文件系统）等。

模型的数据来源可以是内存中的字符串列表，也可以是来自于数据库表中的数据。

同一模型可以采用用不同的视图组件来展示数据，所以模型/视图结构是一种高效灵活的编程结构。

![image-20240322154322086](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/hanling/20240322154322.png)

#### 2、视图（View）

> 视图是用户界面的一部分，用于展示模型中的数据。

在Qt中，常见的视图组件有`QTableView`、`QListView`、`QTreeView`或`QAbstractItemView`的子类，它们负责从模型中获取数据，并以适当的方式显示出来。视图通过信号和槽机制与模型通信，可以监听模型的数据变化，并相应地更新UI。

#### 3、委托（Delegate）

> 委托在模型-视图架构中起到中介的作用，它决定了视图中数据项的外观和行为。

委托可以自定义数据项的绘制方式和编辑行为。比如为视图与模型之间的交互提供临时的编辑器，在QTableView组件上双击一个单元格来编辑数据时，单元格里就会出现一个QLineEdit组件，这个编辑框就是代理提供的临时编辑器，修改后会被自动保存在模型里。

模型、视图和代理使用信号和槽进行通信。当数据发生变化时，模型发射信号通知视图组件；当用户在界面上操作数据时，视图组件发射信号表示操作信息；在编辑数据时，代理会发射信号告知模型和视图组件编辑器的状态。

Qt的模型-视图架构与传统的MVC（Model-View-Controller）模式有相似之处。MVC 就是Model-View-Control模式的简称，包括模型层(Model)，视图层(View)，控制层(Controller)。

- Model主要负责管理数据
- View主要用来显示数据
- Controller主要用来操作数据，控制View联动。

Qt模型-视图架构中，模型用来管理数据。视图用于展示模型中的数据。代理Delegate负责控制视图中每个项的编辑和显示行为，但是，它并不完全等同于MVC中的控制器，因为它的作用范围有限。

### 二、模型类

#### 1、模型类的继承关系

模型（Model）是用来给视图提供数据的，也叫数据模型。模型的数据来源可以是其他类、文件、数据库等。Qt中几个主要的模型类，继承关系如下：

![image-20240322175843517](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/hanling/20240322175843.png)

|模型类|功能|
|---|---|
|QFileSystemModel|用于表示计算机文件系统的模型类|
|QStringListModel|用于表示字符串列表数据的模型类|
|QStandardItemModel|标准的基于项的模型类，每个项是一个QStandardItem对象|
|QSqlQueryModel|用于表示数据库SQL查询结果的模型类|
|QSqlTableModel|用于表示数据库的一个数据表的模型类|

#### 2、模型的基本结构

QAbstractItemModel是所有模型类的基类，它的子类都是以表格的层次结构展示数据；视图组件按照这种规则来存取模型中的数据，以不同的形式展示。下图是模型的3种展示形式：

![image-20240325153543666](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/hanling/20240325153543.png)

数据模型中存储数据的基本单元都是项（item），每个项有一个行号、一个列号，一个父项。3个模型都有一个隐藏的根项（root item）。

- 列表模型的存储结构就是一列。
- 表格模型的存储结构是规则的二维数组。
- 树状模型的项可以有子项。

### 三、视图组件

视图组件负责展示数据，它从模型获取数据并呈现给用户。当模型中的数据发生变化时，视图会自动更新显示。

Qt提供的视图组件主要有以下：

![image-20240616152044782](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/hanling/20240616152044.png)

|视图组件|功能|
|---|---|
|QListView|用于显示单列的列表数据，适用于一维数据的操作。|
|QTreeView|用于显示树状结构数据，适用于树状结构数据的操作。|
|QTableView|用于显示表格数据，适用于二维表格数据的操作。|
|QColumnView|用多个OListView显示树状结构数据，树状结构的一层用一个QListView显示。|
|Undo View|撤销命令视图|

### 四、列表模型/视图

> 列表模型的存储结构就是一列

QStringListModel是字符串列表数据的模型类，通常与QListView组件搭配，组成模型/视图结构适合处理字符串列表数据。

我们使用QStringListModel和QListView来实现列表模型，如图所示。

![image-20240325112608622](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/hanling/20240325112608.png)

1. `ListWidget::ListWidget(QWidget *parent)`
2.     `: QWidget(parent)`
3.     `, ui(new Ui::ListWidget)`
4. `{`
5.     `ui->setupUi(this);`
6.     `QStringList list;`
7.     `list << "北京" << "上海" << "成都";`
8.     `QStringListModel *model = new QStringListModel(this);`
9.     `model->setStringList(list);`
10.     `ui->listView->setModel(model);`
11. `}`

13. `ListWidget::~ListWidget()`
14. `{`
15.     `delete ui;`
16. `}`

### 五、表格模型/视图

> QStandardItemModel模型类，主要用于处理层次化的数据结构，能够存储和管理复杂的数据集合。

`QStandardItemModel`可以用于多种视图组件，如`QTableView`、`QTreeView`、`QListView`等，以适应不同的用户界面需求。

这里我们使用QStandardItemModel和QTableView来实现如图所示：

![image-20240403004231706](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/hanling/20240403004231.png)

1. `#include "tablewidget.h"`
2. `#include "ui_tablewidget.h"`
3. `#include <QStandardItemModel>`
4. `using namespace std;`

6. `TableWidget::TableWidget(QWidget *parent)`
7.     `: QWidget(parent)`
8.     `, ui(new Ui::TableWidget)`
9. `{`
10.     `ui->setupUi(this);`
11.     `//C++ STL中的std::array模板类来创建一个固定大小的二维数组`
12.     `//array<QString, 4>：表示每一行是一个包含四个QString元素的一维数组。`
13.     `//array<array<QString, 4>, 3>：表示整个二维数组由三个上述一维数组组成，即整个数组共有三行四列。`
14.     `array<array<QString,4>,3> arr = {`
15.         `{`
16.          `{"张三","研发部","10000","2000"}, // 第一行`
17.          `{"李四","市场部","12000","1000"}, // 第二行`
18.          `{"王五","研发部","12000","2000"}  // 第三行`
19.         `}`
20.     `};`

22.     `QStandardItemModel *model = new QStandardItemModel(this);`
23.     `//设置表头`
24.     `QStringList headers = {"姓名", "部门", "薪水", "奖金"};`
25.     `//以字符串列表内容设置水平表头各列的文字`
26.     `model->setHorizontalHeaderLabels(headers);`
27.     `for (int row = 0; row < 3; row++)`
28.     `{`
29.         `for (int col = 0; col < 4; col++)`
30.         `{`
31.             `//每个项是一个QStandardItem对象`
32.             `QStandardItem *item = new QStandardItem(arr[row][col]);`
33.             `model->setItem(row, col, item);`
34.         `}`
35.     `}`
36.     `ui->tableView->setModel(model);`
37. `}`

39. `TableWidget::~TableWidget()`
40. `{`
41.     `delete ui;`
42. `}`

### 六、模型视图结构的相关概念

#### 1、模型索引

数据模型中引入了模型索引（model index）的概念。通过模型能访问的每一个项都有一个模型索引。

- 模型索引是对模型内部数据结构中单个数据项的唯一标识符，它包含了行号、列号以及可能的父索引等信息，用于精确地定位模型中的某个数据元素。
- QModelIndex 表示模型索引的类。模型索引提供数据存取的一个临时指针，用于通过数据模型提取或修改数据。

1. `#include "listwidget.h"`
2. `#include "ui_listwidget.h"`
3. `#include <QStringListModel>`

5. `ListWidget::ListWidget(QWidget *parent)`
6.     `: QWidget(parent)`
7.     `, ui(new Ui::ListWidget)`
8. `{`
9.     `ui->setupUi(this);`
10.     `QStringList list;`
11.     `list << "北京" << "上海" << "成都";`
12.     `QStringListModel *model = new QStringListModel(this);`
13.     `model->setStringList(list);`
14.     `ui->listView->setModel(model);`
15.     `//参数1，列表中第一行的索引是从0开始`
16.     `//参数2，0表示第一列`
17.     `QModelIndex index = model->index(0,0);`
18.     `//Qt::DisplayRole表示用于显示的数据`
19.     `model->setData(index, "天津", Qt::DisplayRole);`
20. `}`

22. `ListWidget::~ListWidget()`
23. `{`
24.     `delete ui;`
25. `}`

#### 2、行号和列号

数据模型的基本形式是用行和列定义的表格数据，但这并不意味着底层的数据就是是用二维数组存储的，使用行和列只是为了组件之间交互方便的一种规定。通过模型索引的行号和列号就可以存取数据。

要获得一个模型索引，可以提供 3 个参数：行号、列号、父项的模型索引。例如，对于如图中的表格数据模型中的 3 个数据项 A、B、C，

![image-20240325151720760](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/hanling/20240325151720.png)

获取其模型索引的代码是：

`QModelIndex()`空索引表示模型的根项或没有父项的顶级项。

1. `QModelIndex indexA = model->index(0, 0, QModelIndex());`
2. `QModelIndex indexB = model->index(1, 1, QModelIndex());`
3. `QModelIndex indexC = model->index(2, 1, QModelIndex());`

在创建模型索引的函数中需要传递行号、列号和父项的模型索引。对于列表和表格模式的数据模型，顶层节点用 QModelIndex() 表示。

#### 3、父项

当数据模型是列表或表格时，使用行号、列号存储数据比较直观，所有数据项的父项就是根项；当数据模型是树状结构时，情况比较复杂（树状结构中，项一般习惯于称为节点），一个节点可以有父节点，也可以是其他节点的父节点，在构造树状结构数据项的模型索引时，必须指定正确的行号、列号和父节点。

![image-20240325152859590](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/hanling/20240325152859.png)

对于上图中的树状数据模型，节点 A 和节点 C 的父节点是顶层节点，获取模型索引的代码是：

1. `QModelIndex indexA = model->index(0, 0, QModelIndex());`
2. `QModelIndex indexC = model->index(2, 1, QModelIndex());`

但是，节点 B 的父节点是节点 A，节点 B 的模型索引由下面的代码生成：

1. `QModelIndex indexB = model->index(1, 0, indexA);`

#### 4、项的角色

> 通过为一个项指定不同的角色，可以告知视图组件和代理如何展示数据。

在为模型的一个项设置数据时，可以为项设置不同角色的数据。QAbstractItemModel类定义了设置项的数据函数，原型如下：

1. `bool  QAbstractItemModel::setData(const QModelIndex &index, const QVariant &value, int role= Qt::EditRole)`

其中，index是项的模型索引，value是要设置的数据，role是设置数据的角色。角色参数role用枚举类型Qt::ItemDataRole的枚举值表示：

|枚举值|角色数据类型|含义|
|---|---|---|
|Qt::DisplayRole|QString|界面上显示的字符串，例如单元格显示的文字|
|Qt::DecorationRole|QIcon、QColor|在界面上起装饰作用的数据，如图标|
|Qt::EditRole|QString|界面上适合在编辑器中显示的数据，一般是文字|
|Qt::ToolTipRole|QString|项的toolTip字符串|
|Qt::FontRole|QFont|项的字体，如单元格内文字的字体|
|Qt::TextAlignmentRole|Qt::Alignment|项的对齐方式，如单元格内文字的对齐方式|
|Qt::BackgroundRole|QBrush|项的背景色，如单元格的背景色|
|Qt::ForegroundRole|QBrush|项的前景色，如单元格的文字颜色|
|Qt::CheckStateRole|Qt::CheckState|项的复选状态|

在获取一个项的数据时也可以指定角色，以获取不同角色的数据。QAbstractItemModel定义了函数data()，可以返回一个项的不同角色的数据，原型：

1. `QVariant QAbstractItemModel::data(const QModelIndex &index, int role = Qt::DisplayRole)`

模型索引和项角色使用案例：

1. `#include "standardmainwindow.h"`
2. `#include "ui_standardmainwindow.h"`
3. `#include <QTreeView>`
4. `#include <QStandardItemModel>`
5. `#include <QDebug>`

7. `StandardMainWindow::StandardMainWindow(QWidget *parent)`
8.     `: QMainWindow(parent)`
9.     `, ui(new Ui::StandardMainWindow)`
10. `{`
11.     `ui->setupUi(this);`
12.     `QTreeView *view = new QTreeView(this);`
13.     `view->resize(200, 300);`

15.     `QStandardItemModel *model = new QStandardItemModel(this);`
16.     `QStandardItem *root = model->invisibleRootItem();`

18.     `QStandardItem *item0 = new QStandardItem;`
19.     `//item0->setText("节点A");`
20.     `item0->setData("节点A", Qt::EditRole);`
21.     `item0->setData("提示信息", Qt::ToolTipRole);`
22.     `root->appendRow(item0);`

24.     `QStandardItem *item1 = new QStandardItem;`
25.     `item1->setData("节点B", Qt::EditRole);`
26.     `//绘制图标`
27.     `QPixmap pixmap(50, 50);`
28.     `pixmap.fill(Qt::green);`
29.     `//将填充了绿色的QPixmap转换为一个 QIcon`
30.     `//并与Qt::DecorationRole关联，表示在界面上起装饰作用的数据`
31.     `item1->setData(QIcon(pixmap), Qt::DecorationRole);`
32.     `item1->setData(QFont("宋体", 16, QFont::Weight::Bold), Qt::FontRole);`
33.     `root->appendRow(item1);`

35.     `QStandardItem *item2 = new QStandardItem;`
36.     `item2->setData("节点C", Qt::EditRole);`
37.     `item2->setData(QColor("red"),Qt::BackgroundRole);`
38.     `// 设置为可勾选`
39.     `item2->setCheckable(true);`
40.     `// 设置勾选状态为已勾选`
41.     `item2->setData(Qt::Checked, Qt::CheckStateRole);`
42.     `root->appendRow(item2);`

44.     `view->setModel(model);`

47.     `QModelIndex index0 = model->index(0, 0, QModelIndex());`
48.     `qDebug() << "节点A的文本：" << model->data(index0, Qt::EditRole).toString();`
49.     `qDebug() << "节点A的提示文字：" << model->data(index0, Qt::ToolTipRole).toString();`

51.     `QModelIndex index1 = model->index(1, 0, QModelIndex());`
52.     `qDebug() << "节点B的文本：" << model->data(index1, Qt::EditRole).toString();`
53.     `qDebug() << "节点B的装饰：" << model->data(index1, Qt::DecorationRole);`
54.     `qDebug() << "节点B的字体：" << model->data(index1, Qt::FontRole).toString();`

56.     `QModelIndex index2 = model->index(2, 0, QModelIndex());`
57.     `qDebug() << "节点C的文本：" << model->data(index2, Qt::EditRole).toString();`
58.     `qDebug() << "节点C的背景色：" << model->data(index2, Qt::BackgroundRole);`
59.     `qDebug() << "节点C的勾选状态：" << model->data(index2, Qt::CheckStateRole);`
60. `}`

62. `StandardMainWindow::~StandardMainWindow()`
63. `{`
64.     `delete ui;`
65. `}`

## 模型视图结构（二）

QStandardItemModel是基于项的模型类，每个项是一个QStandardItem对象，通常与QTableView组成模型/视图结构。

主要涉及如下3个类的使用方法：

- `QStandardItemModel`基于项的模型类，维护了一个二维数组，每个项是一个QStandardItem对象，用于存储文字、字体、对齐方式等各种角色的数据。
- `QStandardItem`可以包含各种类型的数据，如字符串、图标、工具提示等，并且可以设置是否可编辑、是否可拖放、是否可选中等属性。
- `QItemSelectionModel`项选择模型，用于跟踪视图组件的单元格选择状态的类。比如，当QTableView组件上选择一个或多个单元格时，通过项选择模型可以获得选中单元格中的模型索引。

使用QStandardItemModel、QItemSelectionModel、QStandardItem类，完成如下功能开发：

![image-20240728215839448](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/hanling/20240728215846.png)

### 一、QStandardItemModel类常用函数

#### 1、水平表头和垂直表头

用字符串列表的内容设置表头各列的文字：

1. `void setHorizontalHeaderLabels(const QStringList &labels);`
2. `void setVerticalHeaderLabels(const QStringList *labels);`

#### 2、设置项

为表格的每个单元格设置一个QStandardItem对象

1. `void setItem(int row, int column, QStandardItem *item); //用于表格模型`
2. `void setItem(int row, QStandardItem *item); //用于列表模型`

#### 3、添加行或列

1. `void appendRow(const QList<QStandardItem*> &items);//适用于表格模型`
2. `void appendRow(QStandardItem *item);//适用于列表模型`
3. `void appendColumn(const QList<QStandardItem *> &items);//在表格模型中添加列`

#### 4、插入行或列

1. `void insertRow(int row, const QList<QStandardItem*> &items);//用于表格模型`
2. `void insertRow(int row, QStandardItem *item);//用于列表模型`
3. `void insertColumn(int column, const QList<QStandardItem*> &items);//用于表格模型`
4. `void insertColumn(int column, const QModelIndex &parent = QModelIndex());//用于树状模型`

#### 5、移除行、列或项

移除一行或一列，行列会减一。返回值是被移除的QStandardItem对象列表

1. `QList<QStandardItem*> takeRow(int row);//用于表格模型`
2. `QList<QStandardItem*> takeColumn(int column);//用于表格模型`

初始化数据：

1. `MainWindow::MainWindow(QWidget *parent)`
2.     `: QMainWindow(parent)`
3.     `, ui(new Ui::MainWindow)`
4. `{`
5.     `ui->setupUi(this);`
6.     `ui->toolBar->setToolButtonStyle(Qt::ToolButtonTextUnderIcon);`
7.     `model = new QStandardItemModel(this);`
8. `}`

1. `//打开文件`
2. `void MainWindow::on_actionOpen_triggered()`
3. `{`
4.     `QString curPath = QCoreApplication::applicationDirPath();`
5.     `QString filename = QFileDialog::getOpenFileName(this, "打开文件", curPath, "(*.txt)");`
6.     `if (filename.isEmpty())`
7.     `{`
8.         `return;`
9.     `}`
10.     `openDataFile(filename);`
11. `}`

1. `//从一个StringList 获取数据，初始化数据Model`
2. `void MainWindow::openDataFile(QString filename)`
3. `{`
4.     `QStringList list;`
5.     `QFile file(filename);`
6.     `//QIODevice::ReadOnly是Qt中定义的枚举值，表示以只读模式打开文件，即只能从文件读取数据，不能写入或修改文件内容。`
7.     `//QIODevice::Text表示以文本模式打开文件`
8.     `if (file.open(QIODevice::ReadOnly | QIODevice::Text))`
9.     `{`
10.         `while (!file.atEnd())`
11.         `{`
12.             `//读取文件的一行`
13.             `QString line = file.readLine();`
14.             `list.append(line);`
15.         `}`
16.         `file.close();`
17.         `//从StringList的内容初始化数据模型`
18.         `initData(list);`
19.     `}`
20. `}`

22. `void MainWindow::initData(QStringList &list)`
23. `{`
24.     `int rowCount = list.size();//文本行数，第一行是标题`
25.     `model->setRowCount(rowCount - 1); //实际数据行数`
26.     `//设置表头`
27.     `QString header = list.at(0);//第一行是表头`
28.     `// "\s+" 整体表示匹配一个或多个连续的空白字符作为分隔符。`
29.     `//如果遇到连续的分隔符导致产生了一个空字符串，这个空字符串将会被忽略，不会添加到结果列表 headerList 中。`
30.     `QStringList headerList = header.split(QRegularExpression("\\s+"), Qt::SkipEmptyParts);`
31.     `model->setHorizontalHeaderLabels(headerList);//设置表头`
32.     `ui->tableView->setModel(model);`
33.       `//设置表格数据`
34.     `int j;`
35.     `QStandardItem *item;`
36.     `for (int i = 1; i < rowCount; i++)`
37.     `{`
38.         `QString lineText = list.at(i);//获取数据区的第i行`
39.         `//一个或多个空格、TAB等分隔符隔开的字符串，分解为一个StringList`
40.         `QStringList tempList = lineText.split(QRegularExpression("\\s+"), Qt::SkipEmptyParts);`

42.         `//不包含最后一列`
43.         `for (j = 0; j < FixedColumnCount-1; j++)`
44.         `{`
45.             `item = new QStandardItem(tempList.at(j));`
46.             `model->setItem(i-1, j, item);`
47.         `}`
48.         `//最后一列`
49.         `QString colName = headList.at(j);`
50.         `item = new QStandardItem(colName); //最后一列是checkable`
51.         `item->setCheckable(true);`
52.         `//QBrush 是Qt中用于绘画填充颜色或图案的类`
53.         `item->setBackground(QBrush(Qt::yellow));`
54.         `if (tempList.at(j) == "n")`
55.         `{`
56.             `item->setCheckState(Qt::Unchecked);`
57.         `}`
58.         `else`
59.         `{`
60.             `item->setCheckState(Qt::Checked);`
61.         `}`
62.         `model->setItem(i-1, j, item); //最后一列`
63.     `}`
64. `}`

添加一行：

1. `void MainWindow::on_actionAdd_triggered(){`
2.     `QList<QStandardItem*> list;`
3.     `QStandardItem *item;`
4.      `//不包含最后一列`
5.     `for (int i = 0; i < model->columnCount() - 1; i++)`
6.     `{`
7.         `item = new QStandardItem("0");`
8.         `list << item;`
9.     `}`
10.     `//获取模型最后一列的列标题，Qt::Horizontal表示水平方向的标题，即列标题`
11.     `QString colName = model->headerData(model->columnCount() - 1, Qt::Horizontal).toString();`
12.     `item = new QStandardItem(colName);`
13.     `item->setCheckable(true);`
14.     `item->setBackground(Qt::yellow);`
15.     `list << item;`
16.     `//添加一行`
17.     `model->appendRow(list);`
18. `}`

插入行：

1. `void MainWindow::on_actionInsert_triggered()`
2.     `QList<QStandardItem*> list;`
3.     `QStandardItem *item;`
4.     `for (int i = 0; i < FixedColumnCount -1; i++)`
5.     `{`
6.         `item = new QStandardItem("0");`
7.         `list << item;`
8.     `}`
9.     `QString colName = model->headerData(model->columnCount()-1, Qt::Horizontal).toString();`
10.     `item = new QStandardItem(colName);`
11.     `item->setCheckable(true);`
12.     `item->setBackground(Qt::yellow);`
13.     `list << item;`
14.     `QModelIndex index = ui->tableView->currentIndex();`
15.     `model->insertRow(index.row(), list);`
16.     `ui->tableView->setCurrentIndex(index);`
17. `}`

删除行：

1. `void MainWindow::on_actionDelete_triggered()`
2. `{`
3.     `QModelIndex index = ui->tableView->currentIndex();`
4.     `int row = index.row();`
5.     `if (row == model->rowCount() - 1)`
6.     `{`
7.         `//删除最后一行`
8.         `model->takeRow(row);`
9.     `}`
10.     `else`
11.     `{`
12.         `model->takeRow(row);`
13.         `//删除一行，并重新设置选择行`
14.         `ui->tableView->setCurrentIndex(index);`
15.     `}`
16. `}`

### 二、QItemSelectionModel选择模型

> `QItemSelectionModel`主要负责处理和维护由`QAbstractItemView`（如`QTableView`, `QListView`, `QTreeView`等）使用的模型数据的选中状态。允许在模型层面跟踪和管理用户的选中操作。

主要接口函数：

|函数|说明|
|---|---|
|setModel(QAbstractItemModel *model)|为选择模型设置数据模型|
|hasSelection()|是否有被选择的项|
|currentIndex()|返回当前的模型索引|
|selectedIndexes()|返回所有被选择项的模型索列表|

#### 1、设置选择模型

1. `QItemSelectionModel *selection = new QItemSelectionModel;`
2. `selection->setModel(model); //为选择模型设置数据模型。model为数据模型。`

或

1. `QItemSelectionModel *selection = new QItemSelectionModel(model, this);`

代码实现：

1. `MainWindow::MainWindow(QWidget *parent)`
2.     `: QMainWindow(parent)`
3.     `, ui(new Ui::MainWindow)`
4. `{`
5.     `ui->setupUi(this);`
6.     `ui->toolBar->setToolButtonStyle(Qt::ToolButtonTextUnderIcon);`
7.     `model = new QStandardItemModel(this);`
8.     `selection = new QItemSelectionModel(model, this);`
9.     `//注意这里要先设置数据模型，在设置选择模型`
10.     `ui->tableView->setModel(model);`
11.     `ui->tableView->setSelectionModel(selection);//设置选择模型`
12. `}`

#### 2、获取选中模型索引

`selectedIndexes()`成员函数，返回当前选中的所有模型索引的列表。

实现选中项文本居左、居中、居右显示：

1. `void MainWindow::on_actionCenter_triggered()`
2. `{`
3.     `//是否有被选择的项`
4.     `if (!selection->hasSelection())`
5.     `{`
6.         `return;`
7.     `}`
8.     `//获取选择的单元格的模型索引列表，可以是多选`
9.     `QModelIndexList list = selection->selectedIndexes();`
10.     `for (int i = 0; i < list.count(); i++)`
11.     `{`
12.         `//获取其中的一个模型索引`
13.         `QModelIndex index = list.at(i);`
14.         `//获取单元格项`
15.         `QStandardItem* item = model->itemFromIndex(index);`

17.         `item->setTextAlignment(Qt::AlignCenter | Qt::AlignVCenter);`
18.     `}`
19. `}`

1. `void MainWindow::on_actionRight_triggered()`
2. `{`
3.     `if (!selection->hasSelection())`
4.     `{`
5.         `return;`
6.     `}`
7.     `//获取选择的单元格的模型索引列表，可以是多选`
8.     `QModelIndexList list = selection->selectedIndexes();`
9.     `for (int i = 0; i < list.count(); i++)`
10.     `{`
11.         `//获取其中的一个模型索引`
12.         `QModelIndex index = list.at(i);`
13.         `//获取单元格项`
14.         `QStandardItem* item = model->itemFromIndex(index);`

16.         `item->setTextAlignment(Qt::AlignRight | Qt::AlignVCenter);`
17.     `}`
18. `}`

1. `void MainWindow::on_actionLeft_triggered()`
2. `{`
3.     `if (!selection->hasSelection())`
4.     `{`
5.         `return;`
6.     `}`
7.     `//获取选择的单元格的模型索引列表，可以是多选`
8.     `QModelIndexList list = selection->selectedIndexes();`
9.     `for (int i = 0; i < list.count(); i++)`
10.     `{`
11.         `//获取其中的一个模型索引`
12.         `QModelIndex index = list.at(i);`
13.         `//获取单元格项`
14.         `QStandardItem* item = model->itemFromIndex(index);`
15.         `//Qt::AlignLeft 是Qt预定义的对齐标志，表示文本左对齐。`
16.         `//Qt::AlignVCenter 表示文本垂直居中对齐。`
17.         `item->setTextAlignment(Qt::AlignLeft | Qt::AlignVCenter);`
18.     `}`
19. `}`

设置字体加粗显示：

1. `void MainWindow::on_actionBold_triggered(bool checked)`
2. `{`
3.     `if (!selection->hasSelection())`
4.     `{`
5.         `return;`
6.     `}`
7.     `QModelIndexList selectedIndex = selection->selectedIndexes();`
8.     `for (int i = 0; i < selectedIndex.count(); i++)`
9.     `{`
10.         `QModelIndex index = selectedIndex.at(i);`
11.         `QStandardItem *item = model->itemFromIndex(index);`
12.         `QFont font = item->font();//获取字体`
13.         `if (checked)`
14.         `{`
15.             `font.setWeight(QFont::Bold);`
16.         `}`
17.         `else`
18.         `{`
19.             `font.setWeight(QFont::Normal);`
20.         `}`
21.         `item->setFont(font);//重置字体`
22.     `}`
23. `}`

### 三、QStandardItem类常用函数

QStandardItem没有父类，它存储项的各种特征参数和设置内容，有一些成对的读写函数：

|读取函数|设置函数|设置函数的功能|
|---|---|---|
|text()|setText()|设置项显示文字|
|icon()|setIcon()|设置图标|
|font()|setFont()|设置字体|
|textAlignment()|setTextAlignment()|设置文字对齐方式|
|background()|setBackground()|设置项的背景色|
|isCheckable()|setCheckable()|设置项是否可以复选|
|checkState()|setCheckState()|设置项的复选状态|

### 四、代理

> 在模型/视图结构中，代理的作用就是在视图组件进入编辑状态编辑某个项时，提供一个临时的编辑器用于数据编辑，编辑完成后再把数据同步给数据模型。

例如，在QTableView组件上双击一个单元格时，代理会提供一个临时的编辑器，默认是QLineEdit编辑框，在这个编辑框里修改项的文字，按Enter键或焦点移动到其他单元格时完成编辑，编辑框内的文字会保存到数据模型中。

QAbstractItemDelegate是所有代理的基类，是抽象类，它有两个子类，即`QItemDelegate`和`QStyledItemDelegate`，QStyledItemDelegate能使用Qt样式表定义的当前样式绘制代理组件，QStyleItemDelegate是视图组件使用的默认代理类。

#### 1、自定义代理

QLineEdit编辑框可以输入任何数据，比较通用。在有些情况下，我们希望根据数据类型使用不同的编辑器，例如，年龄列是整数，使用QSpinBox组件作为编辑器更合适。成绩列是浮点数，使用QDoubleSpingBox更合适，而评价列使用一个QComboBox组件从一个列表中选择输入更合适。若要实现这样的功能，就需要使用自定义代理。

![image-20240408215715342](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/hanling/20240408215715.png)

要为QTableView组件的某列或某个单元格设置自定义代理，则自定义代理类需要从QStyleItemDelegate类继承；创建自定义代理类的实例后，在将其设置为整个视图组件、或视图组件的某行、或某列的代理，以替换默认的代理功能。

#### 2、创建代理类

自定义一个代理类，需要重新实现QStyleItemDelegate中定义的4个虚函数。这4个虚函数是由模型/视图系统自动调用。

![image-20240618200208096](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/hanling/20240618200208.png)

##### （1）重写createEditor()函数

函数createEditor()可以创建用于编辑模型数据的界面组件，称为代理编辑器，例如QSpinBox组件，或QComboBox组件，原型如下：

1. `QWidget *QStyleItemDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &index);`

其中，parent是要创建的组件的父组件，一般是窗口对象；option是项的一些显示选项，是QStyleOptionViewItem类型的，包含字体、对齐方式、背景色等属性；index是项在数据模型中的模型索引，通过index->model()可以获取项所属数据模型的对象指针。

在QTableView视图组件上双击一个单元格使其进入编辑状态时，系统就会自动调用createEditor()创建代理编辑器，例如创建QSpinBox组件，然后将其显示在单元格里。

1. `//创建并初始化编辑器控件`
2. `QWidget *TFloatSpinDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &index) const`
3. `{`
4.     `QDoubleSpinBox *editor = new QDoubleSpinBox(parent);`
5.     `//设置编辑器不显示边框框架，使其外观更贴合表格视图的样式。`
6.     `editor->setFrame(false);`
7.     `//设置编辑器不能输入小于0的数值。`
8.     `editor->setMinimum(0);`
9.     `// 设置编辑器允许输入的最大值为100`
10.     `editor->setMaximum(100);`
11.     `//输入最多两位小数的浮点数。`
12.     `editor->setDecimals(2);`
13.     `return editor;`
14. `}`

##### （2）重写setEditorData()函数

用于在编辑器激活前，将模型中的数据加载到编辑器部件中。它从给定的模型索引index处取出数据，并设置到由createEditor创建的editor中。这样，当用户开始编辑时，编辑器会显示当前模型数据的初始值。

1. `void setEditorData(QWidget *editor, const QModelIndex &index) const;`

1. `//编辑器控件加载时，从数据模型中获取对应单元格的数据并设置到编辑器上。`
2. `void TFloatSpinDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const`
3. `{`
4.     `// 从提供的模型索引(index)中按照编辑角色(Qt::EditRole)获取数据。`
5.     `// 将获取到的数据转换为float类型，因为我们的代理是为编辑浮点数设计的。`
6.     `float value = index.model()->data(index, Qt::EditRole).toFloat();`
7.     `// 将传递进来的QWidget指针安全地转换为QDoubleSpinBox类型的指针。`
8.     `QDoubleSpinBox *spinbox = dynamic_cast<QDoubleSpinBox*>(editor);`
9.     `// 使用从数据模型中获取的浮点数值设置QDoubleSpinBox编辑器的当前值。`
10.     `spinbox->setValue(value);`
11. `}`

##### （3）重写setModelData()函数

当编辑器中的数据发生改变且用户提交这些更改时，此函数被调用。它负责将编辑器中的当前数据提取出来，并更新到模型的指定索引index处。这样，视图中的编辑操作就能同步到模型层面，实现了双向数据绑定。

1. `void setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex &index) const;`

1. `//编辑器控件中的数据发生改变后，将更新后的数据保存回数据模型。`
2. `void TFloatSpinDelegate::setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex &index) const`
3. `{`
4.     `QDoubleSpinBox *spinBox = static_cast<QDoubleSpinBox*>(editor);`
5.     `//获取QDoubleSpinBox控件中的当前浮点数值。`
6.     `float value = spinBox->value();`
7.     `// 将浮点数格式化为字符串，保留两位小数。`
8.     `QString str = QString::asprintf("%.2f", value);`
9.     `// 使用QAbstractItemModel提供的接口，将格式化后的字符串数据设置回模型中对应于给定索引(index)的位置。`
10.     `// 数据是以Qt::EditRole的角色进行存储，这是模型中用于表示可编辑数据的标准角色。`
11.     `model->setData(index, str, Qt::EditRole);`
12. `}`

##### （4）重写updateEditorGeometry()函数

此函数用于调整编辑器部件在视图中的几何布局。确保编辑器的大小和位置适应新的布局情况。option参数提供了当前单元格的样式选项，可用于确定编辑器的合适尺寸和位置，index则表示正在编辑的模型索引。

1. `void updateEditorGeometry(QWidget *editor, const QStyleOptionViewItem &option, const QModelIndex &index) const;`

1. `//调整编辑器控件在视图中的布局和大小`
2. `void TFloatSpinDelegate::updateEditorGeometry(QWidget *editor, const QStyleOptionViewItem &option, const QModelIndex &index) const`
3. `{`
4.     `//设置编辑器控件的几何位置和尺寸`
5.     `//与给定的矩形区域option.rect相匹配`
6.     `editor->setGeometry(option.rect);`
7. `}`

#### 3、设置代理类

1. `floatSpinDelegate = new TFloatSpinDelegate(this);`
2. `ui->tableView->setItemDelegateForColumn(3, floatSpinDelegate);//成绩`

### 五、自定义代理类开发

#### 1、开发TIntSpinDelegate代理类

![image-20240407175738603](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/hanling/20240407175738.png)

1. `#include "tintspindelegate.h"`
2. `#include <QSpinBox>`

4. `TIntSpinDelegate::TIntSpinDelegate(QObject *parent)`
5.     `: QStyledItemDelegate{parent}`
6. `{}`

8. `QWidget *TIntSpinDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &index) const`
9. `{`
10.     `QSpinBox *box = new QSpinBox(parent);`
11.     `box->setFrame(false);`
12.     `box->setMinimum(1);`
13.     `box->setMaximum(30);`
14.     `return box;`
15. `}`

17. `void TIntSpinDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const`
18. `{`
19.     `int value = index.model()->data(index, Qt::EditRole).toInt();`
20.     `QSpinBox *box = static_cast<QSpinBox*>(editor);`
21.     `box->setValue(value);`
22. `}`

24. `void TIntSpinDelegate::setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex &index) const`
25. `{`
26.     `QSpinBox *box = static_cast<QSpinBox*>(editor);`
27.     `int value = box->value();`
28.     `QString str = QString::number(value);`
29.     `model->setData(index, str, Qt::EditRole);`
30. `}`

32. `void TIntSpinDelegate::updateEditorGeometry(QWidget *editor, const QStyleOptionViewItem &option, const QModelIndex &index) const`
33. `{`
34.     `editor->setGeometry(option.rect);`
35. `}`

设置代理类：

1. `intSpinDelegate = new TIntSpinDelegate(this);`
2. `ui->tableView->setItemDelegateForColumn(1, intSpinDelegate); //年龄`

#### 2、开发TComboBoxDelegate代理类

![image-20240407175631760](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/hanling/20240407175631.png)

1. `#include "tcomboboxdelegate.h"`
2. `#include <QComboBox>`
3. `TComboBoxDelegate::TComboBoxDelegate(QObject *parent)`
4.     `: QStyledItemDelegate{parent}`
5. `{}`

7. `QWidget *TComboBoxDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &index) const`
8. `{`
9.     `QComboBox *box = new QComboBox(parent);`
10.     `//是否可编辑`
11.     `box->setEditable(editable);`
12.     `//从字符串列表初始化下拉列表`
13.     `for (int i = 0; i < itemList.size(); i++)`
14.     `{`
15.         `box->addItem(itemList.at(i));`
16.     `}`
17.     `return box;`
18. `}`

20. `void TComboBoxDelegate::setEditorData(QWidget *editor, const QModelIndex &index) const`
21. `{`
22.     `QString str = index.model()->data(index, Qt::EditRole).toString();`
23.     `QComboBox *box = static_cast<QComboBox*>(editor);`
24.     `box->setCurrentText(str);`
25. `}`

27. `void TComboBoxDelegate::setModelData(QWidget *editor, QAbstractItemModel *model,`
28.                                      `const QModelIndex &index) const`
29. `{`
30.     `QComboBox *box = static_cast<QComboBox*>(editor);`
31.     `QString text = box->currentText();`
32.     `model->setData(index, text, Qt::EditRole);`
33. `}`

35. `void TComboBoxDelegate::updateEditorGeometry(QWidget *editor, const QStyleOptionViewItem &option, const QModelIndex &index) const`
36. `{`
37.     `editor->setGeometry(option.rect);`
38. `}`

40. `void TComboBoxDelegate::setItems(QStringList list, bool editable)`
41. `{`
42.     `this->itemList = list;`
43.     `this->editable = editable;`
44. `}`

设置代理类：

1. `comboBoxDelegate = new TComboBoxDelegate(this);`
2. `QStringList list;`
3. `list << "优" << "良" << "一般";`
4. `comboBoxDelegate->setItems(list, false);`
5. `ui->tableView->setItemDelegateForColumn(4, comboBoxDelegate);`