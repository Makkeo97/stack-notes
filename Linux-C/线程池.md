# 线程池是什么？
* 是一种管理多线程的技术手段，通过任务队列和线程池来管理每个线程内执行的任务，并在结束后释放该线程给排队的任务使用，在程序开始时创建多个线程，并在程序结束的时候统一销毁，避免反复创建线程导致程序卡顿，提高了程序的性能
# 创建线程池
## 1. 创建任务队列、线程池、任务、队列节点结构体
```c
//任务结构体
typedef struct Task{
    void* (*fun)(void *args);
    void *args;
}Task;

//队列节点
typedef struct Node{
    Task task;
    struct Node *next;
}Node;

//任务队列结构体
typedef struct TaskQueue{
    Node *head;
    Node *end;
    int length;//任务队列的长度
}TaskQueue;

//线程池结构体
typedef struct Pool{
    pthread_t *pids;//线程池数组（用于存放每一个线程标识符）
    TaskQueue *taskQueue;//指向任务队列的指针（使用指针便于访问任务队列）
    int pCount;//允许创建的线程数量
    sem_t taskSem;//用于线程调度控制的任务量
}Pool;

//如果调用销毁就停止线程执行函数的运行需要bool类型来控制
bool pthreadpoolisRun = true;
//正在等待的线程数量
int waitCoun=0;
```
## 2. 初始化线程池
```c
Pool * initPool(int pCount){
    Pool *p=malloc(sizeof(Pool));//分配线程池的空间
    p->pids=malloc(sizeof(pthread_t)*pCount);//分配线程池内部存放标识符的数组空间
    for(int i=0;i<pCount;i++){
        pthread_create( (p->pids)+i,NULL,worker,p );//创建指定数量的线程
    }
    p->taskQueue=malloc(sizeof(TaskQueue));//给线程池内部任务队列分配空间
    //初始化线程池内部任务队列的各项数据
    p->taskQueue->head=NULL;
    p->taskQueue->end=NULL;
    p->taskQueue->length=0;
    //初始化线程池的线程数量为指定值
    p->pCount=pCount;
    //初始化线程池内部调度信号量,因为信号量本质是个数字，用->解出来就是他本身了，所以取地址传进去
    sem_init(&(p->taskSem),0,0);
    return p;
}
```
## 3. 创建执行函数
```c
void * worker(void *args){
    Pool *p=(Pool*)args;
    pthread_t pid=pthread_self();
    pthread_detach(pid);
    printf("线程创建：%ld\n",pid);
    while(pthreadpoolisRun){
        sem_wait(&p->taskSem);
        printf("线程执行：%ld\n",pid);
        Task t = pop(p->taskQueue);
        if(t.fun!=NULL){
            t.fun(t.args);//执行任务
        }
    }
}
```
## 4. 创建节点、入队、出队（要返回任务传给执行函数）
```c
Node * createNode(Task t){
    Node *newNode=malloc(sizeof(Node));
    newNode->task=t;
    newNode->next=NULL;
    return newNode;
}

bool push(TaskQueue *q,Task t){
    if(q==NULL){
        return false;
    }
    Node *newNode = createNode(t);
    if(q->head==NULL){
        q->head=newNode;
        q->end=newNode;
    }else{
        q->end->next=newNode;
        q->end=newNode;
    }
    q->length++;
    return true;
}

Task pop(TaskQueue *q){
    Task output={0};
    if(q==NULL||q->head==NULL){
        return output;
    }
    output=q->head->task;
    if(q->head==q->end){
        free(q->head);
        q->head=NULL;
        q->end=NULL;
    }else{
        Node *oldHead=q->head;
        q->head=q->head->next;
        free(oldHead);
        oldHead=NULL;
    }
    q->length--;
    return output;
}
```
## 5. 添加任务到队列中
```c
void addTask(Pool *p,Task t){
    if(p==NULL){
        return;
    }
    bool isAdd = push(p->taskQueue,t);//只有正确入队才会释放信号量
    if(isAdd){
        sem_post(&p->taskSem);//每次成功添加就释放信号量
    }
}
```
## 6. 销毁线程池
```c
void poolDestory(Pool *p){
    if(p==NULL){
        return;
    }
    while(p->taskQueue->length>0){
        usleep(500*1000);//每500毫秒检测一次任务队列是否为空
    }
    pthreadpoolisRun =false;
    for(int i=0;i<p->waitCount;i++){
		sem_post(&p->taskSem);//如果队列为空，直接释放剩余的信号量，解除正在等待的几个线程的阻塞，因为worker函数中没有传进去要执行的任务，为空，顺序执行自然退出结束线程
	}
    for(int i=0;i<p->pCount;i++){
        pthread_join(p->pids[i],NULL);//虽然队列为空，但是有些还在执行过程中，等待还在执行的线程结束
    }
    //释放资源
    free(p->pids);
    free(p->taskQueue);
    sem_destroy(&p->taskSem);
    free(p);
    p=NULL;
}
```