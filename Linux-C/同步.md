* 是为了让多个线程按照自己想要的顺序执行，共有两种技术手段
# 1. 顺序执行
* 三种方法：
	1. pthread_join
	2. 信号量
	3. 条件变量
# 2. 全部变量顺序访问
* 两种方法（都可以实现，只不过是互斥锁性能稍微好点，但是CPU不差那点性能）：
	1. 信号量
	2. 互斥锁

# 信号量
* **信号量是什么：** 信号量是一种完整的机制，它的核心点是一个数字，**该数字控制了当前可以访问共享资源的线程个数** 。我们可以通过调用信号量库提供的函数来完成线程间的同步（主要是互斥以及顺序执行，也可以用于线程间的通信（较少））

1. **信号量库函数**
```c
#include <semaphore.h>
```
2. **创建信号量**
```c
sem_t 信号量变量名;
```
3. **初始化信号量**
```c
int sem_init(sem_t *sem, int pshared, unsigned int value);
```
* sem : 指向要初始化的信号量的指针。 
* pshared : 如果为0，表示信号量将在进程内的所有线程之间共 享；如果非0（比如1），表示信号量将在进程之间共享。 	
* value : 信号量的初始值。

4. **等待信号量（降低）**
```c
int sem_wait(sem_t *sem);//解除阻塞并降低信号量
```
5. **释放信号量（增加）**
```c
int sem_post(sem_t *sem);//增加信号量
```
6. **销毁信号量**
```c
int sem_destroy(sem_t *sem);
//用于销毁一个信号量。在销毁之前，必须确保没有线程正在等 待该信号量。
```

# 互斥锁
* **互斥锁（Mutex，全称Mutual Exclusion Lock）** 是一种同步机制，用于保护**共享资源（主要是全局变量的修改）** 防止被多个线程同时访问或修改该资源，从而避免数据竞争和不 一致的状态。互斥锁确保在任何时刻只有一个线程可以持有锁并访问受保护的资源（一般指全局资源）。

1. **库函数**
```c
#include <pthread.h>
```
2. **动态初始化一个互斥锁**
```c
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr)
```
* mutex : 指向要初始化的互斥锁的指针。 
* attr : 指向互斥锁属性的指针，如果为NULL，则使用默认属性
* **注意：** 动态初始化的互斥锁，无论是否使用默认属性，都需要显式销毁pthread_mutex_destroy

3. **静态初始化（推荐）**
```c
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;//mutex是一个互斥锁的变量名字
```
* 通过静态初始化得到互斥锁不需要显性的进行销毁，当程序结束时会自动释放锁所占内存资源

4. **上锁**
```c
int pthread_mutex_lock(pthread_mutex_t *mutex);//要传进去一个指针（也就是锁的地址）
```
* 尝试获取（锁定）一个互斥锁。如果互斥锁已被其他线程锁 定，则调用线程将阻塞，直到互斥锁可用

5. **解锁**
```c
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```
* 释放（解锁）一个互斥锁，其他等待锁的线程就有机会持有。

6. **销毁互斥锁**
```c
int pthread_mutex_destroy(pthread_mutex_t *mutex);
```
* 销毁一个互斥锁。在销毁之前，必须确保没有线程持有该锁

