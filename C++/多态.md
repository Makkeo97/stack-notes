# 一、什么是多态

> C++ 中的**多态是指通过一个基类指针或引用调用一个虚函数**时，会根据具体对象的类型来调用该虚函数的不同实现。

我们一般所说的多态都指的是动态多态。C++支持**两种多态**形式：

* 静态多态（编译时多态）
* 动态多态（运行时多态）

1. **重载（Overloading）是静态多态**的一个例子，包括函数重载和运算符重载。它允许你使用相同的函数名称或运算符实现不同功能，具体调用哪个版本由传入的参数类型及数量在编译时决定。

```cpp
void print(int i) { std::cout << "整数: " << i << std::endl; }
void print(double d) { std::cout << "浮点数: " << d << std::endl; }

print(10);    // 调用 print(int)
print(3.14);  // 调用 print(double)
```

* 另一种形式的静态多态是**模板**，允许编写泛型代码，可以在编译时根据实际参数类型生成相应的函数或类实例。

2. **动态多态（运行时多态）** 依赖于虚函数（Virtual Functions）和继承机制实现。多态发生在运行期间，基于对象的实际类型（而非声明类型）来决定具体调用的函数版本。

# 二、虚函数（Virtual Functions）

> 虚函数是基类中使用关键字 `virtual` 声明的函数，其目的是允许派生类覆盖（`override`）该函数的实现。通过基类指针或引用调用虚函数时，实际执行的是具体对象的函数。

## 1、虚函数的定义

在父类中定义虚函数。

```cpp
class Animal
{
public:
	virtual void eat(); //声明虚函数
};
```

## 2、子类重写父类的虚函数

多态的实现条件，第一是要有继承的存在，第二子类必须重写父类的虚函数。

```cpp
class Dog :public Animal
{
public:
	void eat() override; //重写虚函数
};
```

## 3、动态绑定

在C++中实现多态的方式是，**定义基类对象的`指针`或`引用`，指向子类对象**，程序在运行时进行动态绑定。即同一指针或引用类型，使用不同的实例而执行不同的操作。

```cpp
#include <iostream>

using namespace std;

class Animal
{
public:
	virtual void eat() //声明虚函数
	{
		
	};
};

class Dog :public Animal
{
public:
	void eat() override //重写虚函数
	{
		cout << "Dog Eat" << endl;
	}
};

class Cat :public Animal
{
public:
	void eat() override //重写虚函数
	{
		cout << "Cat Eat" << endl;
	}
};

int main()
{
	Animal* test1 = new Dog();//用指针的方式动态绑定
	test1->eat();
	
	Cat cat;
	Animal &test2 = cat;//用引用的方式动态绑定
	test2.eat();
}
```

# 三、抽象类

> 含有纯虚函数的类称为抽象类，抽象类不能被实例化，只能作为其他类的基类使用。

抽象类的设计目的是确保派生类必须实现某些特定功能，提供了一种接口规范，增强了设计的灵活性和可扩展性。

- **纯虚函数是在基类中声明的虚函数，其在基类中没有具体的实现，并且在声明时被赋值为**`= 0`
- 类中如果声明了纯虚函数，则该类是一个**抽象类不能被实例化**
- 一个抽象类至少有一个纯虚函数，**强制子类必须覆盖它的纯虚函数**

```cpp
//纯虚函数必须重写，否则会报错无法实例化抽象类

#include <iostream>

using namespace std;

class Animal
{
public:
	virtual void eat() = 0; //声明纯虚函数
};

class Dog :public Animal
{
public://不重写纯虚函数
};

int main()
{
	Animal* test1 = new Dog();//用指针的方式动态绑定，会报错：无法实例化抽象类
}
```

```cpp
//重写纯虚函数后，抽象类就可以实例化了

#include <iostream>

using namespace std;

class Animal
{
public:
	virtual void eat() = 0; //声明纯虚函数
};

class Dog :public Animal
{
public:
	void eat() override //重写纯虚函数
	{
		cout << "Dog Eat" << endl;
	}
};

int main()
{
	Animal* test1 = new Dog();//用指针的方式动态绑定
	test1->eat();//会打印dog eat
}
```

# 四、虚析构函数

在继承体系中，父类需要提供虚析构函数`virtual`，以确保在**通过父类指针删除派生类对象时**，能够正确调用派生类的析构函数。

- **当父类具有虚析构函数时，通过父类指针删除子类对象时，会先调用子类的析构函数，然后再调用父类的析构函数，以便能正确删除**

```cpp
#include <iostream>

using namespace std;

class Animal
{
public:
	virtual ~Animal()
	{
		cout << "父类虚析构函数" << endl;
	};
};

class Dog :public Animal
{
public:
	~Dog()
	{
		cout << "子类析构函数" << endl;
	};
};

int main()
{
	Animal* test1 = new Dog();//用指针的方式动态绑定
	delete test1;//会先执行子类析构再执行父类析构
}
```

- **如果基类没有定义虚析构函数，通过基类指针删除派生类对象时，只会调用基类的析构函数，而忽略派生类的析构函数。**

```cpp
#include <iostream>

using namespace std;

class Animal
{
public:
	~Animal()
	{
		cout << "父类析构函数" << endl;
	};
};

class Dog :public Animal
{
public:
	~Dog()
	{
		cout << "子类析构函数" << endl;
	};
};

int main()
{
	Animal* test1 = new Dog();//用指针的方式动态绑定
	delete test1;//只会执行父类的析构函数
}
```