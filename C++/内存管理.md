# 一、C++内存区域

C++程序运行的过程中，内存分为**4个区域**

- **代码区**，所有二进制代码都会存放在代码区，由系统进行管理
- **全局区**，存放全局变量、静态变量以及常量，包括初始化数据区、未初始化数据区
- **栈区**，由编译器自动分配释放，存放函数的参数值，局部变量
- **堆区**，由开发人员分配和释放，如果不进行释放则程序结束后由系统回收

`全局区`分为**数据段**（存放已经初始化的全局变量和静态变量还有字符串常量）和**BSS段**（存放未初始化的全局变量和静态变量）

```cpp
#include <iostream>

int temp;
static int staticTemp;

int global = 100;
static int staticGlobal = 200;

int main()
{
    std::cout << "全局未初始化变量：" << &temp << std::endl;
    std::cout << "全局未初始化静态变量：" << &staticTemp << std::endl;
    
    std::cout << "全局已经初始化变量：" << &global << std::endl;
    std::cout << "全局已经初始化静态变量：" << &staticGlobal << std::endl;
    return 0;
}
```

`动态存储区域`指**栈**还有**堆**：用于在程序运行时动态地分配和释放内存。不是在编译时分配的，而是在程序执行过程中根据需要分配的。

**栈区（stack）：** 由编译器自动分配与释放，存放为运行时函数分配的局部变量、函数参数、返回数据等。

**堆区（heap）：** 堆内存的分配并不像栈那样具有固定的方向性。堆内存是由运行时系统动态分配的，通过`new`操作符分配，`delete`操作符释放。

# 二、动态内存管理

`delete` 和 `delete[]` 是用于释放由 `new` 和 `new[]` 分配的动态内存的运算符。它们之间的区别主要在于处理数组和单个对象的方式上。

## （1）delete

- `delete` 运算符负责释放之前通过 `new` 运算符动态分配的内存，在释放内存之前，`delete` 会先调用该对象的**析构函数**。
- 析构函数完成，`delete` 将调用底层的内存管理机制，来释放之前由 `new` 分配的那块内存，使得这块内存可以被操作系统再次使用。
- `delete` 运算符并不会修改指针本身。指针指向的内存区域被认为是无效的，再次使用这个指针（除了将其设为 `nullptr` 或重新分配）会导致未定义行为。

```cpp
#include <iostream>

class MyClass {
    // 这里假设MyClass类有合适的定义，比如可以有成员变量、成员函数等，此处仅为示例简化为空类
};

int main() {
    MyClass* p = new MyClass;
    delete p;
    p = nullptr;
    return 0;
}
```

将指针设置为 `nullptr` 可以明确表示该指针不再指向有效的对象或内存区域，**避免悬挂指针**。

**悬挂指针**是指向已经被释放的内存地址的指针。如果后续代码不小心使用了这个指针，那么程序的行为将是未定义的，可能导致崩溃或其他错误。

## （2）delete[]

`delete[]` 则专门用于释放由 `new[]` 分配的数组内存。当使用 `new[]` 创建一个数组时，必须使用 `delete[]` 来释放这个数组的所有元素的内存。

`delete[]` 不仅释放内存，还会依次调用数组中每个元素的析构函数，从最后一个元素开始向前调用，确保所有资源得到正确清理。

```cpp
#include <iostream>

class MyClass {
public:
    int num;
    ~MyClass()
    {
        std::cout << "析构函数："<<num<< std::endl;
    }
};

int main() {
    MyClass* arr = new MyClass[10];
    arr[0].num = 1;
    arr[1].num = 2;
    arr[2].num = 3;
    delete[] arr;//会从后往前调用十次析构函数
    arr = nullptr;
    return 0;
}
