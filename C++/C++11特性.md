# 一、智能指针

`std::shared_ptr`和`std::unique_ptr`是C++中用于智能管理动态分配内存的两种不同的智能指针。它们都定义在`<memory>`头文件中，提供了更安全的内存管理方式，避免了传统`new`和`delete`操作可能导致的内存泄漏的问题。

## 1、内存泄露

> 内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并不是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，失去了对该段内存的控制，因而造成了内存的浪费。

**危害：** 长期运行的程序出现内存泄漏，影响很大，如操作系统、后台服务等等，出现内存泄漏会导致响应越来越慢，最终卡死。

```cpp
void MemoryLeaks()
{
     // 1.内存申请了忘记释放
     int* p1 = new int(10);
     
     // 2.异常安全问题
     int* p2 = new int[10];
     delete[] p2;
}

int main()
{
	MemoryLeaks();//调用完函数后p2释放了，p1的内存区域没释放，但是p1指针离开作用域就销毁了，于是这块内存区域无法访问了，会发生内存泄漏
}
```

## 2、std::unique_ptr（独占所有权智能指针）

> `unique_ptr`表示独占所有权的智能指针，意味着同一时间只能有一个 `std::unique_ptr` 拥有该资源。并且当 `std::unique_ptr` 被销毁时，它所管理的对象也会被自动删除。
> 
> 一旦一个 `unique_ptr` 被创建并指向一块内存，这块内存就不能再被其他 `unique_ptr` 或普通指针直接访问。

创建：

```cpp
//std::make_unique 是 C++14 引入的一个工厂函数，简化了创建 std::unique_ptr 的过程
std::unique_ptr<int> ptr1 = make_unique<int>(10);
```

如下代码会报错：

```cpp
#include <iostream>
#include <memory>

int main()
{
	std::unique_ptr<int>ptr1 = std::make_unique<int>(10);
	//std::unique_ptr<int>ptr2 = ptr1; //会报错，因为他是独占所有权的智能指针
	//std::unique_ptr<int> ptr2(ptr1);//会报错，因为他是独占所有权的智能指针

}
```

>`std::unique_ptr`表示对一个对象的唯一所有权，因此不能被复制，禁止智能指针对象拷贝，也就不存在浅拷贝及多次释放同一块空间的问题。`unique_ptr` 在其生命周期内负责管理其所指向的资源。当 `unique_ptr` 对象超出作用域或被显式销毁时，会自动调用析构函数来释放内存，不需要再手动释放！

```cpp
#include <iostream>
#include <memory>

class MyClass {
public:
    MyClass() { cout << "构造函数" << endl; }
    ~MyClass() { cout << "析构函数" << endl; }
};

int main()
{
    unique_ptr<MyClass> ptr1 = make_unique<MyClass>();
    unique_ptr<MyClass> ptr2(new MyClass);
}
```

## 3、std::shared_ptr（共享所有权智能指针）

>`std::shared_ptr`允许多个智能指针共享同一个对象的所有权。它通过引用计数机制工作，每当创建一个新的`shared_ptr`指向同一个对象时，引用计数加1；当一个`shared_ptr`被销毁或被重新赋值时，引用计数减1。当引用计数降到0时，对象会被自动删除。适合需要在多个地方共享资源的情况下使用。

```cpp
#include <iostream>
#include <memory>

class MyClass {
public:
    MyClass() { std::cout << "构造函数" << std::endl; }
    ~MyClass() { std::cout << "析构函数" << std::endl; }
};

int main() {
    std::shared_ptr<MyClass> ptr1 = std::make_shared<MyClass>();
    {
        std::shared_ptr<MyClass> ptr2 = ptr1; // 共享所有权，引用计数+1
    } // ptr2是局部的，离开作用域，引用计数-1，但不为0，MyClass实例不会被删除
    
    return 0; // 主程序结束ptr1离开作用域，引用计数变为0，MyClass实例被删除
}
```

**使用智能指针可以简化内存管理的代码逻辑，减少手动内存释放的疏忽和错误，提高代码的可读性和维护性。**

# 二、Lambda表达式

> **Lambda表达式允许在代码中直接定义匿名函数对象**，常用于需要短期使用的简单函数场景，特别是在算法、回调函数或者线程中。Lambda表达式可以捕获上下文中的变量，能够提升代码的灵活性，可读性和简洁性。

## 1. `Lambda` 表达式函数原型

```cpp
[capture](parameters) mutable(optional) exception(optional) -> return_type(optional) { body }
```

## 2. 捕获子句 `[capture]`

> **捕获子句 `[capture]`：**
>
> 1. **指定lambda函数能够访问的外部变量：** 可以是按值捕获（`x=`, 如 `[x]`），按引用捕获（`&x`, 如 `[&y]`），或者混合捕获（如 `[x, &y]`）。
> 2. **特殊形式：**`[=]` 按值捕获所有外部变量，`[&]` 按引用捕获所有外部变量，`[this]` 捕获当前的`this`指针。
> 3. **也可以在捕获列表中初始化捕获的变量：**`[x=42]`。

- **空捕获 `[]`**：表示 Lambda 表达式不捕获任何外部变量，只能使用其参数列表中的参数。

```cpp
#include <iostream>
int main() {
    auto func = []() {
        std::cout << "This is a lambda with no capture." << std::endl;
    };
    func();
    return 0;
}
```

- **值捕获 `[var1, var2, ...]`**：通过值的方式捕获指定的外部变量，Lambda 表达式内部会创建这些变量的副本。在 Lambda 表达式内部修改这些副本不会影响外部变量。

```cpp
#include <iostream>
int main() {
    int x = 10;
    auto func = [x]() {
        std::cout << "Value of x inside lambda: " << x << std::endl;
    };
    func();
    return 0;
}
```

- **引用捕获 `[&var1, &var2, ...]`**：通过引用的方式捕获指定的外部变量，Lambda 表达式内部使用的是这些变量的引用，对其修改会影响外部变量。

```cpp
#include <iostream>
int main() {
    int x = 10;
    auto func = [&x]() {
        x = 20;
        std::cout << "Value of x inside lambda: " << x << std::endl;
    };
    func();
    std::cout << "Value of x outside lambda: " << x << std::endl;
    return 0;
}
```

- **混合捕获 `[&, var1, var2, ...]` 或 `[=, &var1, &var2, ...]` **：
  - `[&, var1, var2, ...]`：除了指定的变量以值的方式捕获外，其他变量以引用的方式捕获。
  - `[=, &var1, &var2, ...]`：除了指定的变量以引用的方式捕获外，其他变量以值的方式捕获。

```cpp
#include <iostream>
int main() {
    int x = 10, y = 20;
    auto func = [&, x]() {
        y = 30;
        std::cout << "x: " << x << ", y: " << y << std::endl;
    };
    func();
    std::cout << "x: " << x << ", y: " << y << std::endl;
    return 0;
}
```

## 3. 参数列表 `(parameters)`

参数列表与普通函数的参数列表类似，用于传递参数给 Lambda 表达式。它可以为空，也可以包含一个或多个参数。

```cpp
#include <iostream>
int main() {
    auto add = [](int a, int b) {
        return a + b;
    };
    std::cout << "Result of addition: " << add(3, 5) << std::endl;
    return 0;
}
```

## 4. `mutable` 关键字（可选）

默认情况下，通过值捕获的变量在 Lambda 表达式内部是只读的，使用 `mutable` 关键字可以修改这些变量的副本。

```cpp
#include <iostream>
int main() {
    int x = 10;
    auto func = [x]() mutable {
        x = 20;
        std::cout << "Value of x inside lambda: " << x << std::endl;
    };
    func();
    std::cout << "Value of x outside lambda: " << x << std::endl;
    return 0;
}
```

## 5. 异常说明符 `exception`（可选）

用于指定 Lambda 表达式可能抛出的异常，其使用方式与普通函数的异常说明符相同。不过在实际使用中较少用到。

```cpp
#include <iostream>
int main() {
    auto func = [](int a) throw(int) {
        if (a < 0) {
            throw 1;
        }
        return a;
    };
    try {
        std::cout << func(-1) << std::endl;
    } catch (int e) {
        std::cout << "Exception caught: " << e << std::endl;
    }
    return 0;
}
```

## 6. 返回类型 `-> return_type`（可选）

如果 Lambda 表达式的返回类型可以通过 `return` 语句自动推导出来，那么可以省略返回类型。否则，需要显式指定返回类型。

```cpp
#include <iostream>
int main() {
    auto divide = [](double a, double b) -> double {
        return a / b;
    };
    std::cout << "Result of division: " << divide(10.0, 2.0) << std::endl;
    return 0;
}
```

## 7. 函数体 `{ body }`

函数体包含了 Lambda 表达式要执行的代码，与普通函数的函数体类似。

## 8. 示例：

### 8.1 无参数，无返回值的lambda

```cpp
// Lambda表达式在C++中可以被当作函数使用
auto printHello = []{ std::cout << "Hello, World!\n"; };
printHello();
```

### 8.2 带参数，有返回值的lambda

```cpp
auto add = [](int a, int b) -> int { return a + b; };
int sum = add(3, 4); //sum = 7
```

### 8.3 捕获外部变量

按值捕获，不能修改外部变量的值。

```cpp
int x = 10;
int y = 10;
auto print = [x]() { std::cout << x << std::endl; }; // 按值捕获x
print(); // 输出10
```

### 8.4 `[=]` 捕获列表

当使用 `[=]` 作为捕获列表时，Lambda 表达式按值捕获所在作用域的所有外部变量。在 Lambda 内部，这些变量值不能修改。

```cpp
int x = 10;
auto print = [=]() {
    std::cout << "Inside lambda: " << x << std::endl; // 输出10
};
print();
```

### 8.5 `[&]` 捕获列表

使用 `[&]` 作为捕获列表时，Lambda 表达式按引用捕获所在作用域的所有外部变量，Lambda内部可以直接访问并修改外部变量的原始值。

lambda内的任何修改都会直接影响到外部定义的变量。

```cpp
int y = 20;
auto ref = [&]() {
    y++; // 这里直接修改外部变量y
    std::cout << "Inside lambda: " << y << std::endl; // 输出21
};
ref();
std::cout << "Outside lambda: " << y << std::endl; // 输出21，因为y被Lambda修改了
```

### 8.6 混合捕获

明确指定哪些变量按值捕获，哪些按引用捕获。例如，`[x, &y]` 表示按值捕获`x`，按引用捕获`y`。

```cpp
int main()
{
    int x = 10;
    int y = 20;
    auto func = [x, &y]() {
        cout << x << endl;
        y++;//按引用捕获的可以修改原数据
        cout << y << endl;
    };
    func();
}
```

## 9. `Lambda` 表达式的优点

> Lambda表达式增强了C++代码的表达力和灵活性，尤其是在处理STL算法、并发编程、事件处理等场景中应用，Lambda表达式提供了一种**更简洁的方式来定义匿名函数对象**，可以直接在算法中使用：

**例如：** 寻找容器中第一个大于某个值的元素，使用Lambda作为谓词：

```cpp
int main()
{
	std::vector<int> vec = {5, 3, 2, 8, 1, 4};
	// 使用Lambda表达式进行升序排序
	std::sort(vec.begin(), vec.end(), [](int a, int b) { return a < b; });
}
```

相比下面的代码更简洁：

```cpp
// 定义一个升序比较的函数对象
struct AscendingComparator {
    bool operator()(int a, int b) const {
        return a < b;
    }
};

int main() {
    std::vector<int> vec = {5, 3, 2, 8, 1, 4};
    // 使用自定义的比较函数对象进行排序
    std::sort(vec.begin(), vec.end(), AscendingComparator());
}
```