# 一、封装

> 封装的核心思想是隐藏对象的内部实现细节，对外提供公共的接口（即公共成员函数），限制对内部数据的直接访问。

从类的角度来看，封装就是把对象的全部属性和操作结合起来，形成一个整体。并且，隐藏具体的实现细节，只暴露必要的接口给外部使用。

封装最大好处在于提升了代码的内聚性，提高代码的安全性，减少耦合度，从而提高代码的可复用性和可维护性。

## 1、封装的实现

C++中实现封装，需要通过权限访问修饰符`public`，`private`，`protected`关键字来说明类中的成员是公有的、私有的，还是受保护的。

- **public(公有的)：** 类外可以访问；
- **private(私有的)：** 类外不可访问，继承类不可访问；
- **protected(受保护的)：** 类外不可访问，继承类可访问。

## 2、访问类成员

类中name、age被定义为私有成员变量，只能通过公有成员函数（set和get函数）来进行操作和访问。这种封装的方式可以保证在外部代码中无法直接访问和修改私有成员，从而提高代码的安全性。

```cpp
class Student
{
private://私有数据成员
	std::string name;
	int age;
public://公共接口方法
	void SetName(std::string str);//通过公有成员函数接口来访问私有成员。
	void SetAge(int num);
	std::string GetName();
	int GetAge();
};
```

# 二、this指针

> `this`指针是一个隐含的指针，它指向调用该成员函数的对象。this指针是隐含在非静态成员函数中的指针，不需要定义，直接使用。

`this`指针有几个关键的用途和特点：

## 1、访问成员变量

`this`指针可以用来访问当前对象的成员变量和调用成员函数。

```cpp
#include <iostream>
#include <string>

class Student {
public:
    std::string name;
    void methodA() {
        this->methodB();
    }
    void methodB() {}
    void showName() {
        std::cout << this->name << std::endl;
    }
};
```

**每个成员函数（非静态成员函数）中都隐含包含一个this指针作为函数参数； 它是指向被调用对象的指针，并在函数调用时将对象自身的地址隐含作为实际参数传递**。

```cpp
#include <iostream>
#include <string>

class Student {
public:
    std::string name;
    void showName() {
        std::cout << this->name << std::endl;
    }
};
```

## 2、解决参数和成员变量同名冲突

```cpp
#include <iostream>
#include <string>

class Student {
public:
    // 构造函数
    Student(std::string name) {
        this->name = name;
    }
    // 获取学生姓名的函数
    std::string getName() const {
        return this->name;
    }
private:
    std::string name;
};

int main() {
    Student student("张三");
    std::cout << "学生姓名为: " << student.getName() << std::endl;
    return 0;
}
```

## 3、作为返回值

```cpp
#include <iostream>
#include <string> 

class Student
{
private://私有数据成员
	std::string name;
	int age;
public://公共接口方法
	Student SetName(std::string name)
	{
		this->name = name;
		return *this;
	}
	Student* SetAge(int age)
	{
		this->age = age;
		return this;
	}
	void GetName()
	{
		std::cout << name << std::endl;
	}
	void GetAge()
	{
		std::cout << this->age << std::endl;
	}
};

int main()
{
	Student s;
	s.SetAge(10)//返回的是this指针，通过->可以继续操作
		->GetAge();
		
	s.SetName("zs")//返回的是this解引用后的对象本身，通过.可以继续操作（编译器会自动把对象的地址隐含作为实参传入）
		.GetName();
}
```

# 三、静态成员

静态类成员使用`static`关键字修饰，静态成员分为静态成员变量，静态成员函数。

## 1、静态成员变量

类的静态成员变量与函数的静态变量类似，静态成员变量的生命周期与整个程序的生命周期相同。一旦程序开始运行，静态成员变量就会被创建并分配内存，直到程序结束运行时，静态成员变量才会被销毁并释放内存。

### （1）静态成员变量必须在类内声明、类外初始化，定义变量前要加static关键字

### （2）静态成员变量可以通过类名直接访问，也可以通过对象名访问

### （3）静态成员变量被类的所有实例共享

静态成员变量属于类级别的变量，不属于任何一个实例（对象），被类的所有实例共享。无论创建多少个类的实例，都共享一个静态成员变量。

## 2、静态成员函数

### （1）静态成员函数与静态成员变量一样，可以通过类名直接访问。也可以通过对象名访问。

在定义静态数据成员函数时，如果函数的实现代码处于类体之外，则在函数的实现部分不能再标识static关键字。

### （2）静态成员函数中只能访问静态成员变量

由于静态成员是在程序开始执行就分配内存，并初始化（变量）；此时类的对象还没有实例化出来，因此不能访问类中的成员变量，成员变量是属于对象的，在对象创建的过程中才分配内存并初始化。

## 3、示例代码

```cpp
//Student.h

#pragma once
class Student
{
public:
	static int val;
	static void show();
};
```

```cpp
//Student.cpp

#include "Student.h"
#include <iostream>

//静态成员变量必须在类内声明、类外初始化，定义变量前要加static关键字
int Student::val = 10;

//静态成员函数的定义处于类体之外，则在函数的实现部分不能再标识static关键字
void Student::show()
{
	//静态成员函数中只能访问静态成员变量
	std::cout << val << std::endl;
}
```

```cpp
//main.cpp

#include "Student.h"
#include <iostream>

int main()
{
	//静态成员变量可以通过类名访问
	std::cout << Student::val << std::endl;
	//静态成员函数可以通过类名访问
	Student::show();
	
	Student test;
	//静态成员变量被所有实例共享，也可以通过对象访问
	std::cout << test.val << std::endl;
	//静态成员函数也可以通过对象名访问
	test.show();
}
```

# 四、const修饰成员函数

## 1、常函数

成员函数后加`const`修饰后，称之为常函数。**常函数不能修改成员属性**。

```cpp
#include <iostream>

class MyClass
{
public:
    //常函数
    void show() const 
    {
        std::cout << "num:" << num << std::endl;//常函数可以正常访问成员
        //num = 1;  // 会报错，因为常函数不可以修改成员属性
    }
private:
    int num = 100;
};

int main()
{
    MyClass myClass;
    myClass.show();
    return 0;
}
```

如果要修改，需要在成员属性声明时加`mutable`关键字。

```cpp
#include <iostream>

class MyClass
{
public:
    //常函数
    void show() const 
    {
        std::cout << "num:" << num << std::endl;//常函数可以正常访问成员
        num = 1;  //加了mutable后，常函数就能修改该成员属性了
        std::cout << "num:" << num << std::endl;//常函数可以正常访问成员
    }
private:
    mutable int num = 100;
};

int main()
{
    MyClass myClass;
    myClass.show();
    return 0;
}
```

## 2，常对象

声明对象前加`const`关键字，则该对象称为常对象，**常对象只能调用常函数**

```cpp
#include <iostream>

class MyClass
{
public:
    void show() const
    {
        num = 1;
        std::cout << "num:" << num << std::endl;
    }
    void modify()
    {
        
    }
private:
    mutable int num = 100;
};

int main()
{
    const MyClass myClass;
    myClass.show();         //常对象可以正常访问常函数
    //myClass.modify();     //会报错，因为常对象不能调用非const成员函数
    return 0;
}
```

# 五、友元

> 友元是C++中一种特殊的访问权限控制机制，它允许一个类、函数或函数模板绕过常规的访问限制，直接访问另一个类的私有（private）和受保护（protected）成员。

友元关系打破了面向对象编程中的封装原则，但有时出于特定的设计需求，这种灵活性是有必要的。

## 1、友元函数

> 友元函数是一个定义在类外部的非成员函数，它不属于任何类，他是一个**全局函数**。可以直接访问类的私有和受保护成员。

友元函数使用`friend`关键字声明：

```cpp
//MyClass.h

#pragma once

class MyClass
{
    friend void print(MyClass& myClass);//声明谁是它的友元函数
public:
    MyClass(int data);
private:
    int data;
};
```

```cpp
//MyClass.cpp

#include "MyClass.h"
#include <iostream>

using namespace std;

// 定义友元函数print，用于访问MyClass类的私有成员data并输出
// print是全局函数
void print(MyClass& myClass)
{
    cout << "访问私有成员：" << myClass.data << endl;
}

// 实现MyClass类的构造函数，成员初始化列表的方式来初始化data成员
MyClass::MyClass(int data) : data(data)
{
}

int main()
{
    MyClass myClass(100);
    print(myClass);
    return 0;
}
```

## 2、友元类

> **友元类（Friend Class）：如果类A声明类B为友元，那么类B可以直接访问类A的私有和受保护成员。友元关系是单向的，即类A声明类B为友元并不意味着类B自动成为类A的友元。**

友元类使用`friend class` 来声明：

```cpp
//MyClassA.h

#pragma once

//#include "MyClassB" //这样包含是不可以的，不然你B包含A，A包含B会直接报错
class MyClassB; //必须这样前项声明，不然ClassA找不到ClassB

class MyClassA
{
public:
    friend class MyClassB;//声明友元类ClassB
    MyClassA(int data);
private:
    int data;
};
```

```cpp
//MyClassA.cpp

#include "MyClassA.h"

MyClassA::MyClassA(int data):data(data)
{

}
```

```cpp
//MyClassB.h

#pragma once

#include "MyClassA.h"//要包含MyClassA，因为B要访问A中成员的话需要知道具体内容

class MyClassB
{
public:
    void print(MyClassA& classA);//可以直接访问类A的对象
};
```

```cpp
//MyClassB.cpp

#include "MyClassB.h"
#include <iostream>

void MyClassB::print(MyClassA& classA)//传入classA对象的引用
{
    std::cout << classA.data << std::endl;//直接访问A中的私有成员
}
```

```cpp
//Main.cpp

#include <iostream>
#include "MyClassB.h"
#include "MyClassA.h"

int main()
{
    MyClassA classA(100);//创建A类的对象，100存在私有成员data中
    MyClassB classB;//创建B类的对象，因为B类已经在A类中声明过友元
    classB.print(classA);//直接访问A中的私有成员
    return 0;
}
```
