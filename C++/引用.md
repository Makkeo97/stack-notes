# 一、C++引用

> C++中的引用（Reference）是一种特殊的变量，它提供了一种间接访问其他变量的方式，**本质上是一个已存在的变量的别名。**
> 

**引用**提供了一种轻量级的、不增加额外存储开销的方式来操作已存在的变量，因此常用于函数参数传递、返回值优化等场景，以提高代码的效率和可读性。本身不占用额外的内存空间来存储数据，而是与一个已存在的变量绑定，通过引用访问或修改的就是该绑定的变量。因此可以说引用是一个已存在变量的另一种访问方式。

## 1、引用的使用

```cpp
数据类型 &别名 = 变量名;
```

## 2、引用的注意事项

- **声明引用必须进行初始化**
- **引用初始化后，不可以改变引用关系，只能通过引用去改变引用对象的**

```cpp
int a = 10;
//int &b; //编译错误，声明引用必须要初始化
int& b = a; //对引用进行初始化
```

# 二、引用作为参数

## 1、避免复制成本

引用作为函数的参数，可以减少值传递带来的开销，尤其是在传递大型对象时，能避免昂贵的深拷贝。

## 2、修改原始数据

使用引用参数可以实现对实参的直接修改。

```cpp
#include <iostream>
using namespace std;

void swap(int& num1, int& num2)
{
int temp = num1;
num1 = num2;
num2 = temp;
}

int main()
{
int a = 10;
int b = 20;
swap(a, b);
cout << "a = " << a << endl;
cout << "b = " << b << endl;
}
```

## 3、对比指针

**使用引用和指针作为函数参数的区别：**

1. 引用使用起来更直观，是原对象的别名，不需要解引用操作符（`*`）

2. 引用和指针都可以作为函数参数来实现数据的共享和修改，使用指针需要程序员自行管理内存和检查指针的有效性。而引用不能为`nullptr（C++中的空指针）`，因为在定义时必须要进行初始化，总是指向某个有效的对象，所以这在一定程度上强制了函数调用时必须提供有效的对象。

3. 使用指针作为函数参数，可以在函数内部改变指针的指向，这是引用类型参数所不具备的。

# 三、引用作为函数的返回值

用引用作为函数的返回值，最大的好处是：在内存中**不产生被返回值的副本**。

## 1、引用作为函数返回值

**引用作为返回值，可以用引用接收也可以用变量接收**

```cpp
//定义全局变量
int temp;

int fun1()
{
	temp = 10;
	return temp;
}

int& fun2()
{
	temp = 10;
	return temp;
}

int main()
{
	// 1. 返回值类型
	int a = func1();
	a = 99;
	cout << temp << endl; //10
	
	// 2. 返回引用类型
	int& b = func2();
	b = 88;
	cout << temp << endl; //88
}
```

在 C++ 中，如果编译器没有进行返回值优化，会创建一个临时变量。这个临时变量用于存储函数返回值。因为函数内部的**局部变量在函数结束后就会销毁**（其生命周期仅限于函数内部），所以需要一个临时的存储位置来保存`返回值，并将其传递给调用函数的地方。

当执行语句`int a = fun1();`的时候会先创建一个临时变量，把返回值拷贝给隐藏的临时变量，然后再把临时变量的值再拷贝给a，假设这个临时变量是t，相当于做了这两个赋值的步骤：

```cpp
t = temp;
a = t;
```

而`返回引用`在内存中不会产生副本，是原有变量的一个别名，这样就避免产生临时变量，相比返回普通类型的执行效率更高。

## 2、使用引用作为函数返回值注意事项

局部变量不要作为引用返回，函数执行完成后，局部变量会被销毁。

如果要返回局部变量，可以使用`static`修饰，静态变量存在于全局区，全局区上的数据在整个程序结束后释放。

```cpp
int& test()
{
     static int a = 1;
     int& b = a;
     return b;
}
```

## 3、函数的调用可以作为左值

### （1）左值

在C++中，表达式分为左值和右值。

> 左值（lvalue）：指的是持久的对象，通常指代表达式结束后依然存在的对象。

**特点:**
- 左值在内存中有明确的地址， 可以取地址。
- 左值可以被修改，即可以出现在赋值语句的左侧。
- 左值可以出现在赋值表达式的左边或右边。

```cpp
int a = 10; // 'a' 是左值，10 是右值
int* p = &a; // 正确，取变量地址，'a' 是左值
int b = a + 1; // 正确，使用左值
```

### （2）右值

> 右值（rvalue）：指的是临时的对象，通常指表达式结束后不再存在的对象。

**特点：**
- 右值不能取地址。
- 右值不能出现在赋值语句的左侧。

```cpp
int a = 10; 
int* p2 = &(a+1); // 错误，表达式(a+1)的结果是一个右值，右值不能取地址
int x = 10;
int y = 20;
// 同样，下面的尝试也是无效的
(x + y) = 100; // 编译器错误：表达式 (x + y) 是一个右值，不能出现在赋值语句的左边
```

### （3）函数调用作为左值

**当函数返回引用时，函数的调用可以作为左值：**

```cpp
int a;
int& test()
{
     a = 10;
     return a;
}

int main()
{
     //将返回的引用赋给了另一个引用 num1。这意味着 num1 和 a 现在指向同一个内存位置。
     int& num1 = test();
     //test() 返回的是 a 的引用，可以直接通过这个引用来修改 a 的值。
     test() = 20;
     //输出 num1 的值，此时  num1 也是 a 的引用，因此输出20。
     cout << num1 << endl;
     cout << a << endl;
	
     //num2 是一个整型变量而非引用，所以这里实际上是对 a 的值进行了拷贝。
     int num2 = test();
     // 因此，num2 的值为10。
     cout << num2 << endl;
}
```

**接收引用的可以是引用也可以是普通的变量**

# 四、常引用

## 1、常引用的定义

通过const关键字定义常量引用，必须在声明时初始化。

```cpp
const int &a = 10;
```

上述代码中，`10` 是一个字面值常量，本身不是变量，不能直接被引用。但是使用const修饰后，编译器会创建一个临时变量，相当于下面的代码：

```cpp
int temp=10;
const int &a=temp;
//此时，如果想要修改a的值，是不被允许的。会提示表达式必须是可修改的左值。
```

常量引用主要用来修饰形参，提高安全性，防止形参改变实参。可以使用常量引用来提高安全性。避免形参改变实参的问题。

```cpp
#include <iostream>
using namespace std;

void test(const int& num)
{
//num = 100;//不被允许的
cout << "num = " << num << endl;
}

int main()
{
int a = 10;
test(a);
cout << "a = " << a << endl; //10
}
```

## 2、常指针，指针常量，指向常量的常指针

1. **常指针（int \* const p）**
    - 从本质上来说，常指针是指针本身不能被重新赋值的指针。就好像它被 “固定” 在了内存中的某个位置上，一旦初始化指向了一个变量的地址，就必须一直指向这个地址。不过，它所指向的变量的值是可以改变的。可以把它想象成一个牢牢扎根在某个地方的工具，虽然不能移动这个工具的位置，但是可以用它来对其指向的对象进行操作。
    - 例如，这就好比是一个固定指向某个房间（变量的地址）的通道，虽然不能改变通道指向的房间，但是可以改变房间内的物品（变量的值）。
2. **指针常量（const int \*p）**
    - 指针常量重点在于它所指向的数据是常量。这意味着通过这个指针不能对它所指向的数据进行修改。但是，指针本身是可以重新赋值的，它可以指向其他的数据。可以将其类比为一个有特定规则的探测器，这个探测器不能改变它所探测到的物体的性质，但是可以去探测其他的物体。
    - 例如，就像是一个可以移动的观察窗口，只能观察数据，不能修改数据，但是可以将这个观察窗口（指针）移动到其他数据（变量）上进行观察。
3. **指向常量的常指针（const int \* const p）**
    - 这种类型的指针是最严格的。它既不能改变所指向的地址，也不能改变所指向的数据的值。它就像一个被完全固定住的、并且有严格使用规则的设备。这个设备的位置固定，而且不能对它所指向的对象进行任何修改。
    - 例如，就像是一个固定在某个房间（变量地址）上的密封观察窗口，既不能改变观察窗口的位置（指针的指向），也不能通过这个窗口修改房间内的物品（指针所指向变量的值）。

**总结：**`const`修饰引用主要用于保证对象的不可变性，并且引用初始化后不能重新绑定；而`const`修饰指针则可以用来保证指针所指向的值不可变。