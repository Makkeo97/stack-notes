C++ 模板编程是 C++ 语言的一个强大特性，通过编写泛型代码，可以创建能够处理多种数据类型的函数或类，而不需要为每种类型重复编写相同的代码逻辑。

# 一、为什么使用模板

比如我们现在想要完成这样一个工作，比较两个的大小。在C++中，我们可以通过函数重载的方式来完成这个工作。

```cpp
// 函数重载
int compare(int x, int y) {
    std::cout << "int compare(int x, int y)" << std::endl;
    if (x > y) return 1;
    else if (x < y) return -1;
    else return 0;
}

int compare(double x, double y) {
    std::cout << "int compare(double x, double y)" << std::endl;
    if (x > y) return 1;
    else if (x < y) return -1;
    else return 0;
}
```

这两个函数除了参数列表不同，其余的功能等都是一样的，根据比较的值类型不同而需要写多个函数，造成代码冗余。C++中可以通过模板编程来简化开发。

# 二、模板的概念

> 模板（Templates）允许编写通用的代码，这些代码可以适应不同的数据类型，而无需为每种数据类型重复编写相同的逻辑。

模板是C++中`泛型编程`的基础， 作为强类型语言，C++ 要求所有变量都具有具体类型，由程序员显式声明或编译器推导。

而模板允许程序员在定义类或函数时，编写与数据类型无关的通用代码：

```cpp
template<class T>
T compare(T x, T y);
```

上面的代码描述了一个具有 `T类型` 的泛型函数的模板，其返回值和参数（x和 y）都具有此类型。那么T到底是什么类型？实际上，T只是一个占位符，具体是什么类型，此时并不知道，需要在具体调用的时候，指定参数的实际类型。

如下代码：此时T就是int类型：

```cpp
int a=10;
int b=20;
int c=compare(a,b);
```

如下代码，此时T就是double类型：

```cpp
double a = 5;
double b = 8;
double c = compare(a, b);
```

因此，对于`T compare(T x, T y)`来说，它就是一类函数的万能公式。具有通用性，但是不能直接使用。就好像我们编写简历时用的模板一样，不能直接用，在具体编写简历的时候，指定其中的内容。

模板可以分为`函数模板`和`类模板`两大类。

# 三、函数模版

> C++中的函数模板是一种编写通用函数的机制，这些函数能够操作多种数据类型，而无需为每种类型单独编写函数定义。

## 1、函数模版的定义

语法形式如下：多个参数用逗号分隔。

```cpp
template <typename T1,typename T2,......>
返回值类型 函数名(参数列表){函数体}
```

- `template`关键字表示这是一个模板定义。
- `typename T`声明了一个类型参数`T`，表示函数可以接受任何类型作为此参数。
- 模板定义中 <> 里的内容即**模板参数列表**，不能为空

## 2、函数模板的使用

函数模板本身不是一个函数，函数模板像一个公式，它列好了函数返回值类型、 函数名、函数的参数列表的参数类型，编译器通过这个公式在函数被调用时自动推导参数的类型，然后把这个模板实例化成相应的函数。

```cpp
#include <iostream>

template <typename T>
T minmum(T t1, T t2)
{
	return t1 < t2 ? t1 : t2;
}

int main()
{
	int a = 100, b = 200;
	std::cout << minmum(a, b) << std::endl;
	return 0;
}
```

## 3、模板的实例化

> 函数模板的泛型参数类型的实际类型是在编译期间确定的，这个过程被称为模板实例化。

当编译器遇到一个函数模板的调用时，它会**根据传给模板函数的实参参数类型来推导出模板参数的具体类型**，然后生成针对这些具体类型的函数代码。编译器通过对实参类型的推导，将T确定为所需的类型，然后产生一份专门处理该类型的代码。这个过程叫**实例化函数模板**。

## 4、隐式推导和显式推导

函数模板实例化过程中，其模板参数列表推导过程分为：**隐式推导**和**显式推导**。

### （1）隐式推导

隐式推导也叫自动类型推导

```cpp
int a=100;
int b=200;
int result =minmum(a,b);
```

**注意：** 隐式推导，不可以进行隐式类型转换。例如，下代码编译错误，`char` 不能**隐式转换**为 `int`。

```cpp
int a = 100;
char c = 'A';
int result = minmum(a, c);
cout << result << endl;
```

### （2）显式推导

明确指定参数类型。

```cpp
#include <iostream>

template <typename T>
T minmum(T t1, T t2)
{
	return t1 < t2 ? t1 : t2;
}

int main()
{
	int a = 100;
	char b = 101;
	std::cout << minmum<int>(a, b) << std::endl;//显式推导
	return 0;
}
```

# 四、类模板

> 类模板用于生成类的蓝图，通过类模板建立一个通用类，类中成员的数据类型不用具体指定，使用虚拟类型来表示。

- **与函数模板不同，编译器不能为类模板推断模板的参数类型，需要`显式指定参数类型`；同时`类模板参数可以有默认值`**。

* **类模版和模版函数的定义都要写在一个头文件中，因为编译器需要找到对应模版的完整定义才能实例化！**

## 1、语法

```cpp
template <typename T1, typename T2,...>
class 类模板名
{
// 类内成员定义
};
```

## 2、类模板的定义及使用

```cpp
#include <iostream>

template <typename T>
class MyTemplateClass
{
public:
	MyTemplateClass(T data)
		:data(data)
	{

	}
	void show()
	{
		std::cout << this->data << std::endl;
	}
private:
	T data;
};

int main()
{
	MyTemplateClass<int> test1(100);
	test1.show();

	MyTemplateClass<std::string> test2("Hello World!");
	test2.show();
}
```