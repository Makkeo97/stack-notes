# 一、面向对象与面向过程
## （1）面向过程

对于C语言而言，它完全是一门【面向过程】的语言。关注的是过程，分析出求解问题的步骤，通过函数调用逐步解决问题。

面向过程，简单的来说就是将任务分为不同的步骤，按照步骤去完成编程。

## （2）面向对象

面向对象则是从另一种角度思考，将编程思维设计成对象之间的操作，程序设计的任务包括两个方面：

- 一是设计所需的各种类和对象，即决定把哪些数据和操作封装在一起；
- 二是考虑对象之间的交互，以完成所需的任务。

面向对象是一种以`对象`为中心的编程思想，关注的是谁能完成什么工作，面向过程关注的是完成工作的步骤。一个关注过程，一个关注完成对应任务的个体。

`封装`、`继承`、`多态` 是 `面向对象编程语言的三大特征`

|     | 面向过程                                            | 面向对象                                                             |
| --- | ----------------------------------------------- | ---------------------------------------------------------------- |
| 优点  | 复杂问题流程化，进而简单化。性能上优于面向对象，因为对象在调用的时候需要实例化，涉及内存开销。 | 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护。     |
| 缺点  | 不易维护、复用、扩展。                                     | 性能比面向过程低，编程复杂度高。                                                 |
| 应用  | 适合跟硬件联系紧密的系统开发。单片机、嵌入式开发、Linux/Unix等对性能要求较高的地方。 | 面向对象适合处理复杂的问题领域，如用户需求经常变化，互联网应用，企业内部应用，软件系统开发、游戏开发等。便于团队协作和代码维护。 |

# 二、类和对象

类（Class）是面向对象程序设计实现封装的基础。和int 、char、double等基本数据类型一样，类也是一种数据类型。

## 1、类的概念

> 类是对具有相同属性和行为的一类事物的抽象。

在C++中，类是自定义数据类型，比如在电商系统中，商品都有一些共同的特征，商品名称、价格、型号等等。我们在进行系统设计时，可以对这些事务进行归类，设计出商品类，抽象出它们共同的属性和行为。

程序设计，商品类的定义：
```cpp
#include <iostream>
#include <string>

class Goods
{
public:
	std::string name;
	int price;
	void show()
	{
		std::cout << "名字：" << name << std::endl;
		std::cout << "价格：" << price << std::endl;
	}
};

int main()
{
	Goods tv;
	tv.name = "电视";
	tv.price = 3000;
	tv.show();
}
```

## 2、对象的概念

> 对象是类的一个具体实例。

类是一种数据类型，而不是数据，所以不占据内存空间，不能直接操作或访问。只有定义了该类的对象（称为类的实例化），系统才会给对象分配内存空间。

# 三、类的定义&编程命名规范

通过`class`关键字定义类，后跟类的名称，类的主体是包含在一对花括号中。

```cpp
class 类名
{
	访问修饰符：
		数据成员
		成员函数
}
```

在定义类的过程中，建议对类名、数据成员名、成员函数名等使用不同的命名规范。常见的命名规范：帕斯卡命名法（PascalCase），驼峰命名法（camelCase），蛇形命名法（snake_case）。

- **类名**通常采用大驼峰命名法，并且首字母大写，其后单词首字母大写。
- **变量**一般用小驼峰命名法，首字母小写，其后单词首字母大写。对于**成员变量**，有时会在前面加上`m_`前缀来表示这是一个成员变量。有助于区分成员变量和其他局部变量或参数。
- **函数**一般采用大驼峰命名法，第一个单词首字母大写，其后单词首字母字母大写。
- **常量**全部大写，单词之间用下划线分隔。
* **命名空间名**一般采用小写字母，单词之间可以用下划线分隔。

# 四、访问类中的成员

在定义了一个类后，就可以用它来定义该类的变量，即对象。定义对象的过程称为**类的实例化**。

**C++创建对象的方式有两种：**

- 一种是使用`类名 对象名;`的方式创建类对象，这种方式创建的对象在栈中分配内存，超出作用域范围时由系统自动析构对象并回收内存空间。
- 另一种是`动态创建`，程序运行过程中使用`new`运算符给对象在堆空间中申请内存。动态创建的对象内存空间不会被自动回收，在不再使用该对象时，通过`delete`关键字释放内存空间。

## 1、创建对象

```cpp
//通过类名标识符创建对象。
Student s;
Student s1,s2,s3;
```

## 2、 动态创建对象

使用`new`操作符在堆上分配内存，并创建对象。动态对象的生命周期需手动管理，通过`delete`释放内存。

```cpp
类名* 指针名=new 类名;

Student* s = new Student();
delete s;
```

## 3、访问对象成员

对象创建完成之后，可以通过对象名来访问类中的成员，如果是普通对象使用`.`运算符来访问，如果是对象指针使用`->`运算符访问。

1. 对象的方式

```cpp
对象名.成员名;
对象名.函数名(参数列表);

int main()
{
     //实例化一个学生类类型对象，s是对象名
     Student s;
     //通过对象名访问类中的成员
     s.id = 1001;
     s.name = "hello";
     s.age = 20;
     s.show();
     return 0;
}
```

这里`.`是一个运算符，该运算符的功能是表示对象的成员。

2. 对象指针的方式

对象指针就是指向对象的指针。通过对象指针访问对象的成员，使用`->`运算符。

```cpp
int main()
{
     Student* s; //声明一个对象指针，但并未创建对象。
     s = new Student(); //创建对象
     s->name = "hello";
     s->show();
}
```

# 五、构造函数

> 构造函数是一种特殊的成员函数，构造函数的名称与类名完全相同，并且没有返回类型。构造函数在创建对象时自动被调用。

**构造函数的用途：**

- **初始化成员变量**：其主要职责是在创建对象时执行初始化操作，在构造函数中可以给类中的数据成员设置初始值。
- **执行一些必要的操作**：除了初始化数据成员外，构造函数还可以执行其他必要的操作，如果对象需要分配动态内存或其他资源，比如打开文件、建立数据库连接等构造函数是执行这些操作的理想场所。

C++的构造函数分为无参构造函数（默认）、有参构造函数、复制构造函数等。

## 1、无参构造函数

如果一个类没有定义任何构造函数，编译器会自动生成一个默认构造函数。默认构造函数不接受任何参数，仅用于默认初始化类的成员。

类中内置类型（如`int`, `double`等）的成员，其初始值是未定义的，具有不确定的值。

## 2、有参构造函数

有参构造函数至少接受一个参数，用于在创建对象时初始化其成员变量。可以根据需要定义多个，只要它们的参数列表不同，这些构造函数就是构造函数的重载。

**注意：** 一个类中如果显式的定义了有参构造函数，则默认的无参构造函数将被覆盖掉。如果想调用默认的无参构造则必须显式的定义。

## 3、全缺省构造

C++还允许定义全缺省构造和半缺省构造。**无参构造函数不能和全缺省构造函数共存**，只能有一个，否则系统不知道调用哪一个。

```cpp
#include <iostream>
#include <string>

class Goods
{
public:
	//无参构造
	Goods()
	{
		this->name = "苹果";
		this->price = 100;
	}
	//有参构造
	Goods(std::string name,int price)
	{
		this->name = name;
		this->price = price;
	}
	std::string name;
	int price;
	void show()
	{
		std::cout << "名字：" << name << std::endl;
		std::cout << "价格：" << price << std::endl;
	}
};

int main()
{
	//普通初始化
	Goods tv;
	tv.name = "电视";
	tv.price = 3000;
	tv.show();
	
	//无参构造
	Goods* test1 = new Goods;
	test1->show();
	
	//有参构造
	Goods test2("香蕉", 200);
	test2.show();
}
```

# 六、列表初始化

C++提供了初始化列表语法，用来初始化对象的属性。

```cpp
构造函数():属性1(值1), 属性2(值2), ...{}
```

```cpp
#include <iostream>
#include <string>

class Goods
{
public:
	//有参构造,使用列表初始化，会把传入的值直接初始化，不需要在内部初始化
	//m_name(name)的意思就是把调用Goods的时候的name传给括号外的m_name
	Goods(std::string name, int price) :m_name(name), m_price(price)
	{
		std::cout << "有参构造" << std::endl;
	}
	std::string m_name;
	int m_price;
	void show()
	{
		std::cout << "名字：" << m_name << std::endl;
		std::cout << "价格：" << m_price << std::endl;
	}
};

int main()
{
	//有参构造：列表初始化
	Goods test2("香蕉", 200);
	test2.show();
}
```

# 七、复制构造函数

> 复制构造函数在C++中是一个特殊的构造函数，其主要职责是创建一个新对象作为现有对象的副本。

## 1、复制构造函数的定义

复制构造函数要求有一个类类型的引用参数，并且通常**使用常量方式调用**。**如果没有显式定义复制构造函数，系统会自动生成一个默认形式的复制构造函数。**

```cpp
class Student
{
public:
int id;
string name;
int age;
	//无参构造函数
	Student(){}
	//有参构造函数
	Student(int id, string name, int age): id(id), name(name), age(age) {}
	//定义复制构造函数
	Student(const Student& stu) 
	{
	this->id = stu.id;
	this->name = stu.name;
	this->age = stu.age;
	cout << "执行复制构造函数" << endl;
	}
};
```


## 2、复制构造函数执行时机

**当以下情况发生时，会自动调用复制构造函数：**

1. **用一个已存在的同类型对象初始化新对象：** 对于包含动态分配资源（如指针成员）的类，复制构造函数通常需要实现深拷贝。

2. **函数的形参是按值传递时：** 值传递的本质会拷贝一个临时的副本出来，会调用复制构造函数，将实参的数据拷贝给形参。

3. **函数以值的方式，返回一个局部对象：** 当函数返回一个对象时，如果返回类型不是引用或指针，编译器会在函数内部创建一个临时对象，通过复制构造函数将返回值复制到这个临时对象，然后返回该临时对象。

```cpp
#include <iostream>
#include <string>

class Goods
{
public:
	//无参构造（默认）
	Goods(){}
	//有参构造
	Goods(std::string name, int price):m_name(name),m_price(price)
	{
		std::cout << "执行有参构造" << std::endl;
	}
	//复制构造
	Goods(const Goods &args )//复制构造要常引用，防止修改原对象
	{
		std::cout << "执行拷贝构造" << std::endl;
		this->m_name = args.m_name;
		this->m_price = args.m_price;
	}
	std::string m_name;
	int m_price;
	void show()
	{
		std::cout << "名字：" << m_name << std::endl;
		std::cout << "价格：" << m_price << std::endl;
	}
};

void fun(Goods goods){}

Goods getGoods()
{
      Goods goods;
	  goods.m_name = "TEST";
	  goods.m_price = 888;
      return (Goods)goods; //以值的方式返回，会调用复制构造函数
      //强制了复制语义。告诉编译器创建一个Goods类型的临时对象，并且将goods复制到这个临时对象中，可以避免因为编译器RVO优化而看不到复制构造的执行
}

int main()
{
	Goods test2;
	test2.m_name = "TV";
	test2.m_price = 100;
	test2.show();
	
	//复制构造执行时机：用一个已存在的同类型对象初始化新对象
	Goods test3(test2);
	test3.show();
	//复制构造执行时机：用一个已存在的同类型对象初始化新对象
	Goods test4 = test2;
	test4.show();
	//复制构造执行时机：形参是按值传递时
	Goods test5("APPLE",100);
	test5.show();
	fun(test5);
	//复制构造执行时机：以值的方式，返回一个局部对象
	getGoods();
}
```

**注意：** 新版编译器执行了返回值优化（ RVO）。这些优化技术允许编译器消除不必要的拷贝或移动操作，从而提高性能。

**注意：** 如果只是test1=test2这样，只是赋值运算符，不是复制构造！！！

# 八、析构函数

> 析构函数是一个特殊的成员函数，它在对象的生命周期结束时被自动调用，用于执行对象销毁前的清理工作。

析构函数与构造函数的功能正好相反，构造函数用于初始化对象，而析构函数用于释放对象所使用的资源。

## 1、析构函数的定义

每个类都可以定义自己的析构函数，如果类没有显式定义析构函数，编译器会自动生成一个默认的析构函数。析构函数的名称与类名相同，但前面有一个波浪线（~）作为前缀，且没有返回类型。

**注意：** 析构函数没有参数，不能被重载，因此一个类只能有一个析构函数。

```cpp
～classname()　　
{
 　　　　/*code */ 　　
}
```

## 2、析构函数执行时机

（1）对象生命周期结束时

当一个栈上的局部对象离开其作用域时，其析构函数会被自动调用

（2）堆上通过 `new` 操作符创建的对象被 `delete` 时，析构函数会在 `delete` 之后立即调用；如果没有 delete，析构函数不会被执行。

（3）在所有函数之外创建的对象是全局对象，位于内存分区中的全局数据区，程序在结束执行时会调用这些对象的析构函数。

```cpp
#include <iostream>

class User
{
public:
	User() {
		std::cout << "无参构造" << std::endl;
	}
	User(int num) : ptr(new int(num)), arr(new int[10] {10, 20})
	{
		std::cout << "有参构造" << std::endl;
	}
	~User() {
		delete ptr;
		ptr = nullptr;
		std::cout << "析构函数" << std::endl;
		delete[] arr;
		arr = nullptr;

	}
	int* ptr;
	int* arr;
};

int main()
{
	//堆上通过new操作符创建的对象被delete时，析构函数会在delete之后立即调用
	User* user = new User;
	delete user;
	
	//对象生命周期结束时，自动调用析构函数
	User u;
	User u1(10);
}
```

## 3、使用析构函数释放资源

通过析构函数，程序员可以手动释放对象占用的资源，避免内存泄漏的问题。例如，在一个对象中分配了动态内存，可以在析构函数中进行内存释放，以确保内存被正确释放。

```cpp
class Test
{
public:
	//无参构造
	Test() {}
	//有参构造
	Test(int num) :ptr(new int(num)), data(num) {}
	//析构函数
	~Test()
	{
		if (ptr != nullptr)
		{
			delete ptr;
			ptr = nullptr;
			std::cout << "析构函数" << std::endl;
		}
	}
	int* ptr;
	int data;
};

int main()
{
	Test t1(10);//有参构造
}
```

# 九、深拷贝浅拷贝

在C++中，深拷贝（Deep Copy）和浅拷贝（Shallow Copy）是关于对象复制时两种不同的处理方式，**主要区别在于如何处理对象中指针或引用的资源**。

## 1、浅拷贝

> 浅拷贝是指在复制对象时，只复制对象的基本数据成员，对于指针类型的成员变量，只是复制指针的值（也就是让两个指针都指向了同一块地址）。

这样做的后果是，如果一个对象修改了这块内存的内容，另一个对象的相应内容也会受到影响，这通常不是我们希望看到的结果，尤其是在对象管理动态分配的资源时，可能会导致资源被误删或重复释放。

```cpp
#include <iostream>
class Test
{
public:
	//无参构造
	Test() {}
	//有参构造
	Test(int num) :ptr(new int(num)), data(num) {}
	//拷贝构造
	Test(const Test& t)
	{
		this->data = t.data;
		this->ptr = t.ptr;//浅拷贝的原理
		//this->ptr = new int(*t.ptr);//深拷贝的原理
	}
	//析构函数
	~Test()
	{
		if (ptr != nullptr)
		{
			delete ptr;
			ptr = nullptr;
			std::cout << "析构函数" << std::endl;
		}
	}
	int* ptr;
	int data;
};

int main()
{
	Test t1(10);//有参构造
	Test t2(t1);//拷贝构造
	std::cout << t2.data << std::endl;
	//如果浅拷贝，只复制了指针的地址，两个对象都调用析构函数的时候就会发生重复释放的问题，会报错
	//深拷贝的话，是通过解引用拿到数据，又重新用new分配了一块空间，不会重复释放
}
```

当执行`Test t2(t1);`时，调用的是默认的复制构造函数，该函数执行浅拷贝。这意味着`t2`的`data`指针将指向与`t1`相同的内存地址。如果`t1`或`t2`中的任何一个被销毁，它们都会尝试删除同一个内存地址上的数据，导致未定义行为。

**默认的复制构造函数是浅拷贝，想要深拷贝需要自己显式书写复制构造函数**

## 2、深拷贝

> 深拷贝则是除了复制基本数据成员外，还会为指针类型的成员变量动态分配新的内存地址。

也就是说如果源对象中有指向堆内存的指针，那么深拷贝会为目标对象分配一块新的内存，将源对象指针所指向的数据复制到这块新内存中。因此，深拷贝可以保证两个对象之间的数据完全独立，任何一个对象的修改都不会影响另一个对象。

```cpp
#include <iostream>
class Test
{
public:
	//无参构造
	Test() {}
	//有参构造
	Test(int num) :ptr(new int(num)), data(num) {}
	//拷贝构造
	Test(const Test& t)
	{
		this->data = t.data;
		//this->ptr = t.ptr;//浅拷贝的原理
		this->ptr = new int(*t.ptr);//深拷贝的原理
	}
	//析构函数
	~Test()
	{
		if (ptr != nullptr)
		{
			delete ptr;
			ptr = nullptr;
			std::cout << "析构函数" << std::endl;
		}
	}
	int* ptr;
	int data;
};

int main()
{
	Test t1(10);//有参构造
	Test t2(t1);//拷贝构造
	std::cout << t2.data << std::endl;
	//如果浅拷贝，只复制了指针的地址，两个对象都调用析构函数的时候就会发生重复释放的问题，会报错
	//深拷贝的话，是通过解引用拿到数据，又重新用new分配了一块空间，不会重复释放
}
```

**总结：**

- **浅拷贝**简单地复制指针，可能导致资源共享和意外修改。
- **深拷贝**分配新的内存地址，复制原指针所指向的数据，保证了对象的独立性。

# 十、头文件

C+ +语言支持separate compilation，即单独编译。也就是说`.cpp`源文件是相对独立的，在编译一个`.cpp`文件时是不知道任何其他的`.cpp`文件的存在，只需要在编译成目标文件后再与其他的目标文件做一次链接（link）就行了。

举例来说，在文件`a.cpp`中定义并实现了一个函数void a()；在`b.cpp`中调用这个函数。然后执行：`g++ a.cpp b.cpp`编译。在编译的过程中`a.cpp`与`b.cpp`并不知道对方的存在，而是分别编译成目标文件，然后再由编译器进行链接，整个程序就生成好了。在`b.cpp`中调用`a.cpp`中定义的函数`void a()`之前，先进行声明，这样编译`b.cpp`就会生成一个符号表。像`void a()`这样只有声明没有实现的函数就放在这个表中，链接的时候再去其他目标文件中寻找这个符号的实现，一旦找到了就顺利生成可执行程序，否则便会报错：`Link error: undefined reference to ‘a()’.`

这种编译机制给c++程序带来的好处是：当一个函数被很多的`.cpp`文件调用时，只需要在对应的`.cpp`文件中声明这个函数就可以了。

但是设想假如一个文件中实现了100个函数，而在许多其他文件中都需要这100个函数，那么按照这种机制，你就必须将100个函数的声明都复制一遍，粘贴到需要使用这些函数的`.cpp`文件中，显然是很麻烦的，因此头文件(.h文件)也就诞生了。

## 1、头文件

在C++中，通常将程序分为头文件（.h文件）和源文件（.cpp文件）。

C++中头文件的后缀是`.h`，**头文件是不被编译的，头文件只放各种函数、类、、命名空间、宏等的声明**，在需要这些函数的地方使用宏`#include`包含这个头文件（本质类似复制粘贴），这样就解决了上面的问题。

**类的声明、命名空间的声明**通常包含在头文件中，其中包含了类的所有成员变量和成员函数的声明，需要对声明创建定义的时候，光标移动过去按alt+enter组合键就能自动创建定于了，编写内容即可。

`#pragma once` 是一种非标准但被大多数现代编译器广泛支持的预处理指令，用于避免头文件被重复包含。指示编译器在同一个编译过程中只包含一次该文件。相比于传统的`#ifndef`、`#define`、`#endif`风格的包含守卫，`#pragma once`的使用更加简单。

```cpp
#pragma once
#include <iostream>

namespace myspace
{
	class Goods
	{
	public:
		std::string name;
		int price;
		int* ptr;
		//无参构造
		Goods();
		//有参构造
		Goods(int num, std::string str);
		//复制构造
		Goods(const Goods& goods);
		//析构函数
		~Goods();
	};
}
```

## 2、声明与定义分离

在C++中，类的声明和定义通常会分开进行，以便于代码的模块化和复用。类的声明通常放在头文件（`.h` 或 `.hpp` 文件）中，而类的成员函数的实现通常放在实现文件（`.cpp` 文件）中。

```cpp
#include "Goods.h"

myspace::Goods::Goods()
{
	std::cout << "无参构造" << std::endl;
}

myspace::Goods::Goods(int num, std::string str):price(num),ptr(new int(num)),name(str)
{
	std::cout << "有参构造" << std::endl;
}

myspace::Goods::Goods(const Goods& goods)
{
	this->name = goods.name;
	this->price = goods.price;
	this->ptr = new int(*goods.ptr);//深拷贝
	std::cout << "复制构造" << std::endl;
}

myspace::Goods::~Goods()
{
	if (ptr != nullptr)
	{
		delete ptr;
		ptr = nullptr;
		std::cout << "析构函数" << std::endl;
	}
}
```

**这样的分离的好处是：**

- 重用性，头文件可以被多个源文件包含，从而重用相同的代码。避免在多个源文件中重复定义相同的函数体。
- 提高编译效率，如果多个源文件都包含同一个头文件，在头文件中只包含声明的话，不会导致成员函数的代码被多次编译，从而提高编译速度。

## 3、预编译头文件

> 预编译头文件（Precompiled Header，PCH）是一种在 C++ 中用于提高编译速度的技术。

预编译头文件中通常包含一些稳定且不经常改变的头文件的预编译结果。在大型项目中，头文件的包含和解析可能会消耗大量的时间，而预编译头文件可以将这个过程提前进行，从而减少后续编译的时间开销。

使用预编译文件的步骤：

### （1）创建预编译头文件

- 在 Visual Studio 中，创建一个头文件`stdafx.h`

- 在项目的属性页中，找到 “C/C++” - “预编译头” 选项。将 “创建 / 使用预编译头” 设置为 “创建（/Yc）”，并在 “预编译头文件” 文本框中指定预编译头文件的名称（例如`stdafx.pch`）

- 在 “stdafx.h” 头文件中包含那些很少或几乎不发生变化的头文件。例如，标准库头文件（如`<iostream>`、`<vector>`、`<string>`等），以及项目中广泛使用的自定义头文件（如全局配置文件等）。这些头文件在多次编译过程中内容基本固定，预编译它们可以显著提高编译效率。

- 创建 `stdafx.cpp` 文件中只需要包含 `stdafx.h` 头文件，不需要添加额外代码 **（因为头文件是不会被编译的,添加.cpp是为了能够正常编译）**。

```cpp
//stdafx.h
#pragma once
#include <iostream>
#include <string>
```

```cpp
//stdafx.cpp
#include "stdafx.h"
```

### （2）使用预编译头文件

- 在项目的其他源文件包含该预编译头文件，并在属性页中，将 “C/C++” - “预编译头” 选项中的 “创建 / 使用预编译头” 设置为 “使用（/Yu）”，并在 “预编译头文件” 文本框中指定与创建预编译头文件时相同的名称（如`stdafx.pch`）。

**头文件使用总结**：

1. 防止头文件重复包含。头文件重复包含是一个常见问题，它会导致编译错误。为了防止这种情况，在头文件开头和结尾使用预处理指令`#ifndef`、`#define`和`#endif`，或者`#pragma once`。

 2. 声明与定义分离。在头文件中声明类（包括其成员变量和成员函数），成员函数的具体实现在源文件中。

3. 头文件应尽可能少地包含其他头文件，只包含它真正需要的依赖。这有助于减少编译时间和避免不必要的编译依赖。

4. 避免循环依赖，合理设计类的依赖关系和头文件结构。

5. 使用前向声明来代替包含头文件，如果可能的话。

- 比如，当只需要使用一个类（或结构体）的指针或引用时，很多时候可以使用前向声明来代替包含头文件。例如，有一个函数`void func(MyClass* ptr);`，这里只需要告诉编译器`MyClass`是一个类类型即可，不需要知道`MyClass`的具体定义。
- 如果要创建一个类的对象（而不是指针或引用），就必须包含该类的头文件。例如，`MyClass obj;`这样的代码要求编译器知道`MyClass`的完整定义，包括成员变量的大小和布局等信息，仅靠前向声明是不够的。因为编译器需要知道对象的大小来为其分配内存空间。

# 十一、命名空间

在 C++ 程序中，不同的模块或库可能会定义相同名称的变量、函数、类等。例如，有两个不同的库，一个是数学计算库，一个是图形处理库。数学计算库中有一个函数叫做`calc()`用于数值计算，图形处理库中也有一个同名函数。当同时包含这两个库并使用`calc()`函数时，编译器就不知道该调用哪个函数，这就会导致命名冲突。

因此我们可以通过命名空间的方式来解决这种命名冲突的问题。

## 1、定义命名空间

定义命名空间使用`namespace`，格式如下：

```cpp
namespace 名称
{
     常量、变量、函数等对象的定义
}
```

## 2、访问命名空间中的成员

命名空间定义完成后，通过`::`作用域限定符，引用空间中的成员。

```cpp
int main()
{
     cout << space1::a << endl;
     cout << space2::a << endl;
}
```

## 3、头文件中定义命名空间

在定义命名空间时，**通常在头文件中声明命名空间，在源文件中定义命名空间中的函数**，将程序的声明与定义分开。

```cpp
//Goods.h
#pragma once
#include <iostream>

namespace myspace
{
	class Goods
	{
	public:
		std::string name;
		int price;
		int* ptr;
		//无参构造
		Goods();
		//有参构造
		Goods(int num, std::string str);
		//复制构造
		Goods(const Goods& goods);
		//析构函数
		~Goods();
	};
}



```

```cpp
//Goods.cpp
#include "Goods.h"

myspace::Goods::Goods()
{
	std::cout << "无参构造" << std::endl;
}

myspace::Goods::Goods(int num, std::string str):price(num),ptr(new int(num)),name(str)
{
	std::cout << "有参构造" << std::endl;
}

myspace::Goods::Goods(const Goods& goods)
{
	this->name = goods.name;
	this->price = goods.price;
	this->ptr = new int(*goods.ptr);//深拷贝
	std::cout << "复制构造" << std::endl;
}

myspace::Goods::~Goods()
{
	if (ptr != nullptr)
	{
		delete ptr;
		ptr = nullptr;
		std::cout << "析构函数" << std::endl;
	}
}

```

使用 `using namespace` 可以简化代码，使得在该作用域内可以直接使用该命名空间内定义的标识符（如函数、类、枚举、变量等），而无需在其前面显式地加上命名空间的前缀。

```cpp
using namespace myspace;
int main()
{
    Goods t1;
}
```

## 4、定义嵌套命名空间

```cpp
namespace output
{
    namespace myspace
    {
        void test();
    }
}
```

## 5、使用`using`指令访问

**语法：**`using namespace namespace_name;`

**例如：** 如果使用`using namespace MyNamespace;`，那么在这之后的代码中就可以直接访问`MyNamespace`中的成员，不需要再使用`MyNamespace::`前缀。

不过这种方式在大型项目中可能会导致命名冲突。如果在`using`这个命名空间之后，又引入了其他同名的成员（比如另一个库中的同名函数或变量），就会产生冲突。所以在实际大型项目中一般不建议这样使用。

- 使用`using`声明有选择地访问:
	`using namespace_name::member_name;`。例如，只想在`main`函数中直接访问`MyNamespace`中的`myFunction`，可以使用`using MyNamespace::myFunction;`。