# 注意项

1. 参数可以给默认值
2. 一个参数设置默认值，后面的参数也必须都设置默认值
3. C++支持内联函数
4. 函数重载就是指多个函数具有相同的函数标识符，但参数类型或参数个数不同。C++中支持函数重载，让函数调用更灵活，让实现同一功能的函数支持多类型，多参数，函数重载只和函数名，参数列表（包含参数的个数、类型、顺序）有关，与函数的返回值无关。

# 一、函数的使用

> 函数是一段具有特定功能的、可重用的代码块。

每个 C++ 程序至少有一个函数，即主函数 **main()** 。在C++ 标准库中，提供了大量程序可以调用的内置函数，为程序开发提供了便利。

## 1、函数的定义

C++ 中，函数由`返回值类型`、`函数名`、`参数列表`和`函数主体`组成。

```cpp
return_type function_name( parameter list )
{
    body of the function
}
```

一个函数的所有组成部分：

- **返回类型**：**return_type** 是函数返回的值的数据类型。无返回值的函数使用void关键字表示 。
- **函数名称**：这是函数的实际名称。函数名和参数列表一起构成了函数签名。
- **参数列表**：参数列表包括函数参数的类型、顺序、数量。参数是可选的。
- **函数主体**：函数主体包含一组定义函数执行任务的语句。

## 2、函数的调用

C++中对函数进行了严格的限制，必须先声明或定义函数才能使用该函数。形式如下：

```cpp
void func(int a); 

int main()
{
    func(100);
    return 0;
}

void func(int a)
{
    std::cout << a << std::endl;
}
```

# 二、函数的参数

## 1、有参函数

函数定义时，如果参数列表为空，说明函数是无参函数；如果参数列表不为空，就称之为有参函数。

**参数分为形参和实参两种**：

- 函数声明和定义时的参数称之为`形式参数`，简称`形参`。
- 在函数被调用时具体传入的参数称之为`实际参数`，简称`实参`。

**调用有参函数时，实参与形参的个数、类型、及顺序要保持一致。**

```cpp
#include <iostream>

//定义函数，a和b称之为形参
void myFun(int a, double b)
{
    std::cout << "参数a的值是：" << a << std::endl;
    std::cout << "参数b的值是：" << b << std::endl;
}

int main()
{
    //函数调用时传入的具体参数称之为实参
    int num1 = 10;    //实参
    double num2 = 3.2;    //实参
    myFun(num1, num2);
    return 0;
}
```

* **形参，只有在函数被调用时，才分配内存空间，函数调用结束后，形参所占用的内存空间会被释放。**
* **函数没有被调用时，形参不占用内存中的存储单元。**

## 2、参数传递

C++中参数的传递有多种方式，按值传递、指针传递、引用传递，常量引用传递等。

### （1）按值传递

按值传递就是把实参的值赋给形参。（对于自定义对象来说，会涉及拷贝赋值，我们在面向对象章节中会讲解）

```cpp
// 定义函数，函数参数按值传递，函数内修改形参不会影响实参
void fun(int a)
{
    a = 100;
}

int main()
{
    int num = 1;
    fun(num);
    // 由于是按值传递，这里num的值依然是1，不会被函数内对形参的修改所影响
    std::cout << num << std::endl; 
    return 0;
}
```

按值的参数传递是单向的，只能把实参的值传递给形参，在函数调用的过程中，形参的值发生改变，实参的值不会发生改变。

### （2）指针传递

如果形参是指针类型，调用函数时传递的是地址。

```cpp
#include <iostream>
// 定义函数，参数为指向int类型的指针，通过指针可以修改所指内存的值
void fun(int* a)
{
    *a = 100;
}

int main()
{
    int num = 1;
    fun(&num);
    std::cout << num << std::endl; // 此处会输出100，因为在fun函数中通过指针修改了num的值
    return 0;
}
```

对于自定义对象大小可能会很大，这种情况下使用指针，可以减少拷贝赋值的开销，因为作为参数只需要传递地址大小的数据。

**注意：** 在C++中数组作为函数的参数，是一种特殊的情况，将实参赋值给形参的过程中，数组名会转换成指向第一个元素的指针。这就是我们说的C++中数组退化的问题。

```cpp
void func(int arr[])
{
    std::cout << "arr的地址" << arr << std::endl;//传进来的arr只是一个首地址
}

int main()
{
    int arr[5] = {10, 20, 30, 40, 50};
    std::cout << "arr的地址" << arr << std::endl;
    func(arr);
    return 0;
}
```

如果要利用指针遍历数组，正确的做法是，将数组及数组的长度作为参数传递：

```cpp
void func(int* arr, int len)
{
    for (int i = 0; i < len; i++)
    {
        std::cout << arr[i] << std::endl;
    }
}

int main()
{
    int arr[] = {10, 20, 30, 40, 50};
    int len = sizeof(arr) / sizeof(arr[0]);
    func(arr, len);
    return 0;
}
```

### （3）引用传递

实参与形参之间存在一个分配空间和参数值传递的过程，这个过程是在函数调用时发生的。C++支持引用类型变量，引用类型变量则没有值传递的过程，相当于为实参增加了一个新的名字，他俩访问的根本就是同一个东西，但是也会有一些安全性的问题：形参错误修改了实参的值

```cpp
数据类型 &别名 = 变量名;
```

## 3、参数的默认值

### （1）C中函数的形参没有默认值，C++中函数的形参时可以给默认值。

```cpp
#include <iostream>

void func(int a = 10)
{
    std::cout << a << std::endl;
}
```

### （2）函数调用时，可以给形参传递值，也可以不传，不传就会使用默认值。

```cpp
#include <iostream>

void func(int a = 10)
{
    std::cout << a << std::endl;
}

int main()
{
    func();
    func(20);
    return 0;
}
```

### （3）函数有多个形参时，可以给全部形参或后一半形参赋默认值。

以下设置默认值的方式都是**合法**的：

1. `void func(int a, double b, char c = 'a'){}`
2. `void func(int a, double b = 1, char c = 'a'){}`
3. `void func(int a = 2, double b = 1, char c = 'a'){}`

一旦某个形参被设置了默认值，则其后的所有形参也都应该有默认值，下面的写法是**错误**的：

1. `void func(int a, double b = 1, char c){}`
2. `void func(int a = 2, double b, char c = 'a'){}`
3. `void func(int a = 2, double b = 1, char c){}`

### （4）实参的值只能按照顺序依次赋给对应的形参，不能跳过。

例如，对于下面已经声明的函数：

```cpp
void func(int a = 2, double b = 1, char c = 'a'){}
```

可以使用如下的形式调用：

```cpp
	func();
    func(100);
    func(100, 10);
    func(100, 10, 'b');
```

### （5）当存在函数声明语句时，必须在函数声明语句中指定形参的默认值。

```cpp
void func(int a = 10);

int main()
{
    func();
    return 0;
}

void func(int a)
{
    std::cout << a << std::endl;
}
```

# 三、函数的返回值

- **无返回值函数**，表示函数执行之后不需要返回结果，声明和定义的时候使用`void `关键表示。
- **有返回值的函数**，在定义和声明时必须指定返回值的具体类型，并且通过`return`关键字返回具体结果。

## 1、返回指针

### （1）不要返回局部变量的指针。因为函数执行完，局部变量会被销毁，导致返回的指针变成一个悬挂指针。

下面是一个不安全的例子，展示了返回局部变量地址的函数：

```cpp
#include <iostream>

int* getLocalIntPointer() {
    int localValue = 50;
    return &localValue;
}

int main() {
    int* ptr = getLocalIntPointer();
    std::cout << "The value is: " << *ptr << std::endl;
    return 0;
}
```

### （2）如果函数返回的是动态分配内存的指针，那么函数调用之后，必须进行手动释放指针，否则会导致内存泄漏。

```cpp
int* func()
{
    int* ptr = new int(10);
    return ptr;
}

int main()
{
    int* ptr = func();
    delete ptr;
    // 下面这行代码会导致未定义行为，因为ptr所指内存已被释放，成为悬挂指针了
    // std::cout << *ptr << std::endl;
    ptr = nullptr;//C++中给指针赋值为NULL用nullptr
    return 0;
}
```

为什么在`delete`后要将指针设置为`nullptr`？

- 当使用`delete`释放了指针指向的内存后，原来的指针仍然指向已经被释放的内存区域。这时，该指针被称为`悬挂指针`。再次使用这个悬挂指针可能会导致未定义行为或其他不可预测的结果。
- **避免重复删除**的问题。如果不将指针设置为`nullptr`，并且在后续的代码中再次尝试删除这块内存（即重复删除），会导致运行时错误。

## 2、返回引用

函数返回值可以是引用，函数返回时局部对象时会被销毁，**对于局部对象的引用会变得无效**。

# 四、函数重载

> 所谓函数重载就是指**多个函数具有相同的函数标识符，但参数类型或参数个数不同**。

1. C 语言中不支持函数重载， C 语言的函数名是全局唯一的，如果两个函数的名字相同，编译器会报错。
2. C++中支持函数重载，让函数调用更灵活，让实现同一功能的函数支持多类型，多参数。**函数重载只和函数名，参数列表（包含参数的个数、类型、顺序）有关**，与函数的返回值无关。

以下都是正确的函数重载方式：

1. `void func(int a){}`
2. `void func(int a, string s){}`
3. `void func(string s, int a){}`
4. `int func(int a, int b){}`

**编译器以参数的类型及个数来区分调用哪个函数**

```cpp
int main()
{
    func("hello", 100); //func(string s, int a)
    func(100, 200);  //func(int a, int b)
}
```

**注意：**

一个函数即有重载函数，又带参数默认值时，必须注意彼此能够相互区分，避免引起二义性。例如：

1. `void func(int a, double b, char c = 'a'){}`
2. `void func(int a, double b){}`

在执行函数调用`func(3, 4)`时，系统无法判断应当使用带2个参数还是带3个参数的函数，而导致编译错误。

# 五、内联函数

在C语言中，我们使用宏定义函数这种借助编译器的优化技术来减少程序的执行时间。

## 1、为什么要代替部分宏定义

在C语言中，宏是一种强大的预处理指令，基于预处理指令#define定义宏。当预处理器遇到宏定义时，会将宏名称替换为指定的文本或表达式。这种替换是在编译之前进行的，称为`宏展开`。例如：

`#define NEWLINE  printf("\n")`

在代码中使用`NEWLINE`时，预处理器将其展开为`printf("\n")`。

由于**宏定义在预处理阶段进行文本替换**，没有函数调用的开销，因此可以提高性能、减少代码冗余。

**但是宏也有缺点，由于宏只能是简单的文本替换，不进行语法分析和语义检查，因此建议使用inline去替代宏去调用函数。**

## 2、C++内联函数

C++中内联函数主要是为了提高函数的执行效率。如果一个函数是内联的，那么在**编译期间，编译器会将函数体中的代码插入到函数调用的地方**，减少函数调用带来的开销（寻找函数地址、压栈、返回带来的开销）。

### （1）内联函数的定义

想把一个函数定义为内联函数，只需要在函数定义的时候在函数名字前面使用`inline`关键字即可。inline关键字应该与函数体的定义放在一起，跟声明放在一起不起作用

下面是一个示例，使用内联函数来返回两个数中的最大值：

```cpp
#include <iostream>
using namespace std;

inline int max(int a, int b) {
    return (a > b)? a : b;
}

int main() {
    int a = 20;
    int b = 20;
    int result = max(a, b);
    return 0;
}
```

编译器会在每个调用内联函数的地方对其展开。展开形式如下：

```cpp
#include <iostream>
using namespace std;

inline int max(int a, int b) {
    return (a > b)? a : b;
}

int main() {
    int a = 20;
    int b = 20;
    int result = max(a, b);
    return 0;
}
```

### （2）注意事项

- 类成员函数（类内实现的）默认都是内联函数

- **内联函数是对编译器的一种建议，具体还要看编译器是否选择**。

- 建议在函数实现代码很简短或者调用该函数次数相对较少的情况下将函数定义为内联函数，内联函数通常定义一条返回语句，不能包含循环或者switch语句。

* **比如：** 递归函数不会被内联。递归层次在编译阶段都是未知的，多数编译器都不支持内联递归函数