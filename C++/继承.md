# 一、继承概述

## 1、为什么需要继承

在面向对象的编程语言中，我们可以通过继承来解决代码复用的问题。将重复的代码统一定义在父类中，子类从父类继承。

## 2、什么是继承

> 继承就是一个新类从现有的类派生的过程。新类称之为派生类或子类，原有的类称之为基类或父类；子类可以继承父类中的成员，从而可以提高代码的可重用性。

继承关系下，子类和父类存在 **is a**的 关系。例如，狗是动物，猫是动物，老虎是一个动物等等。那么可以说动物类是一个父类，老虎、猫、狗都是动物类的子类。

在继承关系下父类更通用，子类更具体。也就是说父类拥有子类的共同特性，子类可以具备独有的特性，这样通过继承就可以实现代码的可重用性，减少代码冗余，同时可以实现多态。

# 二、继承的实现

C++中类实现继承的形式如下：

```cpp
//从单个基类继承
class 子类名:继承方式 基类名
{

}

//从多个基类继承
class 子类名:public A, protected B, private C
{

}
```

* 继承方式有3种类型，分别为公有型（public），保护型（protected）和私有型（private）
* `:`是一个运算符，表示基类和派生类之间的继承关系。

# 三、派生类的访问控制

在C++中，类成员的访问权限分为public（公共）、protected（受保护）或private（私有）3种。

其中父类的public和protected成员允许子类继承，private成员不能被继承。

以`public`继承模式为例，访问控制权限如下：

| 访问   | public | protected | private |
| ---- | ------ | --------- | ------- |
| 同一个类 | yes    | yes       | yes     |
| 派生类  | yes    | yes       | no      |
| 类的外部 | yes    | no        | no      |

# 四、继承类型

C++支持三种继承类型，分别是 **public、protected** 及 **private** 类型，这些继承类型影响着基类成员`在派生类中`的访问权限。

## 1、公有继承（Public Inheritance）

> 公有继承允许派生类继承基类的公有和保护成员，并且这些成员**在子类中保持父类其原有的访问级别**。

```cpp
#include <iostream>
using namespace std;

class A
{
public:
	int public_num;
protected:
	int protected_num;
private:
	int privete_num;
};

class B :public A//公有继承的话，权限保持不变
{
public:
	void show()
	{
		cout << public_num << endl;
		cout << protected_num << endl;
		//cout << private_num << endl; //报错：不能访问父类的私有成员
	}
};

int main()
{
	class B test;
	test.public_num;
	//test.protected_num; //报错：protected成员只能在子类内部访问，不能在类外部访问
	//test.privete_num; //报错：不能访问父类的私有成员
	test.show();// show()是public的，可以通过它在类的外部访问父类受保护的成员
}
```

## 2、私有继承 (Private Inheritance)

> 私有继承**使基类的公有和保护成员在派生类中成为私有的**，派生类的外部不能访问，只能在派生类内部访问。

```cpp
#include <iostream>
using namespace std;

class A
{
public:
	int public_num;
protected:
	int protected_num;
private:
	int privete_num;
};

class B :private A
{
public:
	void show()
	{
		cout << public_num << endl;//用私有继承的方法，父类的共有和受保护成员都会变成子类的私有，只能在类内部访问
		cout << protected_num << endl;//用私有继承的方法，父类的共有和受保护成员都会变成子类的私有，只能在类内部访问
		//cout << private_num << endl; //报错：不能访问父类的私有成员
	}
};

class C :public B
{
public:
	void classCshow()
	{
		//cout << public_num << endl;//会报错，因为B用私有继承的话就会将A中所有成员都变成私有，C再继承B的话就访问不了
		//cout << protected_num << endl;//会报错，因为B用私有继承的话就会将A中所有成员都变成私有，C再继承B的话就访问不了
		//cout << private_num << endl; //报错：B类都不能访问A的私有，C更不能
	}
};

int main()
{
	class C c;
	c.show();//因为B中还定义了一个共有的成员show，c就还能访问它，但是B继承自A的成员全部是私有的
}
```

## 3、保护继承 (Protected Inheritance)

> **基类的公有和保护成员在派生类中变为保护的**，可以在派生类内部及其子类中访问，但不能在派生类的外部访问。

```cpp
#include <iostream>
using namespace std;

class A
{
public:
	int public_num;
protected:
	int protected_num;
private:
	int privete_num;
};

class B :protected A
{
public:
	void show()
	{
		cout << public_num << endl;
		cout << protected_num << endl;
		//cout << private_num << endl; //报错：不能访问父类的私有成员
	}
};

int main()
{
	class B test;
	//test.public_num; // 如果classB用保护继承的话，父类中的public也会变成protected，就受保护了，不能在类外部访问
	//test.protected_num; //报错：protected成员只能在子类内部访问，不能在类外部访问
	//test.privete_num; //报错：不能访问父类的私有成员
	test.show();// show()是public的，可以通过它在类的外部访问受保护的继承自父类的成员
}
```

# 五、继承中的构造函数与析构函数

**基类中的构造函数、析构函数和拷贝构造函数不能被派生类继承，但是可以被调用。**

## 1、继承关系下构造函数和析构函数的执行顺序

- 子类对象在创建时会**首先调用父类的构造函数，然后调用子类自己的构造函数**
- **析构函数执行顺序和构造函数相反，先析构子类再析构父类**

```cpp
#include <iostream>
using namespace std;

class A
{
public:
	A()
	{
		cout << "父类构造函数" << endl;
	}
	~A()
	{
		cout << "父类析构函数" << endl;
	}
};

class B :public A
{
public:
	B()
	{
		cout << "子类构造函数" << endl;
	}
	~B()
	{
		cout << "子类析构函数" << endl;
	}
};

int main()
{
	class B b;
	return 0;
}
```

## 2、子类中调用父类构造

1. 如果**父类有默认构造函数（即无参数或者参数都有默认值的构造函数）**，那么子类构造函数在不写初始化列表时，编译器会自动调用父类的默认构造函数。

```cpp
class User {
protected:
    std::string username;
    std::string password;
public:
    User() : username("default_user"), password("default_password") //默认构造
    {
	    
    }  
    User(std::string username, std::string password)
        : username(username), password(password) 
    {
	    
    }
};

class Root : public User {
public:
    Root() //这里编译器会自动调用父类User的默认构造函数
    {
	    
    }  
};
```

2. 当父类中提供了有参数构造函数时，如果想调用父类的有参构造函数,需要在子类初始化列表中**显式调用父类构造函数**。

```cpp
class User {
protected:
    std::string username;
    std::string password;
public:
    User(std::string username, std::string password)
        : username(username), password(password) //父类提供了有参构造函数
    {
	    
    }
};

class Root : public User {
public:
    Root(std::string rootUsername, std::string rootPassword)
        : User(rootUsername, rootPassword) //显式调用父类有参构造函数
    {
	    
    } 
};
```