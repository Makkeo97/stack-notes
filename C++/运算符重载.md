> C++中的运算符重载是一种特殊的多态形式，允许程序员为自定义类型（如类或结构体）重新定义现有运算符的行为。

对于内置的数据类型可以通过`+`号进行运算，但是如果是自定义类（对象）进行`+`运算，编译器则不支持。这种时候，可以重载`+`运算符来让两个自定义的类对象相加。

# 一、运算符重载

运算符重载的目的是，对已有的运算符重新定义，赋予其他的功能。

重载运算符不可以创建新的运算符，只能是C++语言中已有的运算符。可以重载的运算符如下：

- 算术运算符
- 位操作运算符
- 逻辑运算符
- 关系运算符
- 赋值运算符
- 其他运算符：[]、()、->、逗号、new、delete、new[] 、delete[]、->*

- 不允许进行重载的运算符：`.`、`*`、`::`、`?`、`:`

重载的运算符是带有**特殊名称的函数**，函数名是由关键字 `operator` 和其后要**重载的运算符符号**构成。与普通函数一样，重载运算符有一个返回类型和一个参数列表。

```cpp
返回值类型 operator运算符(参数列表);
```

- **当一个运算符作为`成员函数`被重载时，它会隐含地接收`this`指针作为左侧操作数。因此，对于二元运算符（即需要两个操作数的运算符），你只需要为右侧操作数提供一个参数。**

比如我们现在要实现对两个Goods对象进行`+`运算之后，得到两个商品对象的价格之和：

```cpp
#include <iostream>
using namespace std;

class Goods
{
public:
	Goods()
	{

	}
	Goods(int price): price(price)
	{

	}
	Goods operator+(Goods good)
	{
		Goods temp;
		temp.price= this->price + good.price;
		return temp;
	}
	int price;
};

int main()
{
	Goods a(100);
	Goods b(200);
	
	//第一种调用的方法：运算符重载的本质（就是一个函数调用）
	Goods c = a.operator+(b);
	cout << c.price << endl;
	
	//第二种调用的方法，看起来更加直观
	Goods d =a+b;
	cout << d.price << endl;
}
```

除了**成员函数运算符重载**之外，C++中还可以实现**全局函数的运算符重载**。

# 二、全局函数实现运算符重载

运算符重载可以通过成员函数和全局函数两种方式实现。

- **全局函数运算符重载不依赖于任何特定类实例，需要显式地为所有涉及的操作数提供参数，包括左侧和右侧的操作数**。

- **全局函数实现运算符重载需要访问类的私有成员，通常通过友元函数**。

```cpp
#include <iostream>

class Book
{
public:
    Book()
    {
	    
    }
    Book(int price): price(price)
    {
	    
    }
    friend Book operator+(const Book& b1, const Book& b2);
    int getPrice() const
    {
	    return this->price;
    }
private:
    int price;
};

//全局函数重载运算符
Book operator+(const Book& b1, const Book& b2) {
    Book temp;
    temp.price = b1.price + b2.price;
    return temp;
}

int main() {
    Book b1(100);
    Book b2(200);
    Book b3 = b1 + b2;
    std::cout << b3.getPrice() << std::endl;
    return 0;
}
```

# 三、重载位移运算符

**注意：** `位移运算符`涉及到流对象（如`std::cout`）和用户自定义类型的交互。流对象（通常是`std::ostream`或`std::istream`）不是用户自定义类型的一部分，**因此，这类运算符不能作为类的成员函数来实现。** 要通过友元全局函数的形式，以获得访问类中私有成员的权限。

```cpp
#include <fstream>
#include <iostream>

class Goods
{
public:
	Goods()
	{ 
		
	}
	Goods(std::string name, int price)
		:name(name),price(price)
	{
	
	}
	friend std::ostream& operator>>(std::ostream& stream, Goods& good);
	int price;
	std::string name;
};

//必须用引用传递参数的原因：因为按值传递时会调用拷贝构造，而io流的拷贝构造在iostream库里面是禁用的状态。返回流引用是为了连续操作
std::ifstream& operator>>(std::ifstream& stream, Goods& good)
{
	stream >> good.name >> good.price;
	return stream;
}

int main()
{
	std::ifstream fd;
	fd.open("test.txt");
	Goods test;
	fd >> test;//调用重载运算符
	std::cout << test.name << " " << test.price << std::endl;
	return 0;
}
```