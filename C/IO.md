# 什么是标准IO（input/output）
## 概念
* 是指标准I/O库，又称带缓存的I/O，属于ISO实现的输入输出的标准 库函数，内部调用的是底层的系统调用，是在文件IO的基础上封装出来的函数接口，也就是说基于低级IO的一个封装和抽象。它由ANSI C建立的一个 标准I/O模型，是一个标准函数包和 stdio.h 头文件中的定义，具有一定的可移植性。标准I/O库代替用户处理很多细节，比如缓存分配、以优化长度 执行I/O等，提供缓存的目的是为了尽量减少read和write的调用次数。我们 可以使用标准IO 提供的各种c库函数用来进行各种输入和输出功能实现，相比于低级IO ，在使用上更加方便
## 标准IO主要函数分类

|  分类  |            描述            |
| :--: | :----------------------: |
| 文件读写 | 用于文件的打开、关闭、读写或设置读取文件位置等  |
| 标准输入 | 终端进行数据的读取(stdin)，比如scanf |
| 标准输出 | 将数据输出到stdout（终端）中，printf |
| 标准错误 | 将错误信息输出到stderr中 perror（） |
## 文件流指针
## FILE结构体
```c
FILE *fp //可以用来定义一个文件流指针
```
## 文件流指针是什么
* 文件流指针是指指向文件流的指针，文件流指针指向一个包含文件名、文件状态和文件的当前信息等数据结构的结构体的地址。文件流指针是一个文件在c语言程序里的表现形式。每一个文件都有 自己的文件流指针。开发者就可以利用文件流指针以及对应的读取和写入 函数来完成文件数据的读取和写入，
# 缓存机制
## 三种缓存模式
1. **全缓冲（Fully Buffered）（所有文件的操作都是全缓冲的）** 当流是全缓冲的，数据会被积累在缓冲区中，直到缓冲区满了或者你手 动刷新缓冲区（比如使用 fflush 函数），才会进行实际的IO操作。这种 缓冲方式常用于对文件的操作，因为它可以减少对磁盘的读写次数。 
2. **行缓冲（Line Buffered）（所有终端的操作都是行缓存的）** 行缓冲意味着当输入或输出中遇到换行符时，缓冲区的内容才会被写 出。标准输出stdout（向终端输出）和标准输入(stdin)通常是行缓冲的， 这样可以在写出每行之后立即看到结果。
3. **无缓冲（Unbuffered）** 如果一个流是无缓冲的，那么每个输入或输出操作都是直接执行的。标 准错误输出stderr通常是无缓冲的，以保证错误信息可以立即输出。
## 缓存区的触发时间
1. 缓冲区满了自动触发（文件） 
2. 程序结束或调用文件关闭函数自动触发：    fclose    close    exit(0)**（此函数可以用于在子函数中直接结束整个程序！）**    main函数的return    或者程序自然结束 
3. 修改了缓冲区，自动触发一次    setbuf 
4. 手动调用刷新函数    fflush() 
5. 其他方式
# 标准IO函数
## fopen
* 打开文件，返回文件流指针
```c
FILE *fp = fopen("文件路径以及名称", "打开模式");//这里fp是一个文件流指针
```

| 打开模式 | 作用                                                                                                                                                                 |
| ---- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| r    | 以只读的方式打开一个文件， 文件必须存在                                                                                                                                               |
| r+   | 以读写的方式打开这个文件， 文件必须存在。写入操作在读取之后的位置执行，会覆盖掉后续的数据                                                                                                                      |
| w    | 如果文件存在则清空再写，如果文件不存在则创建写入                                                                                                                                           |
| w+   | 如果文件存在则清空读写，如果文件不存在则创建读写                                                                                                                                           |
| a    | 如果文件存在则追加写入，如果文件不存在则先创建在写入                                                                                                                                         |
| a+   | 如果文件不存在则创建文件并 追加写入和读取。 读取时从文件开头开始读取，写入时从文件的末尾开始写入 fseek偏移后 不能进行写入操作，如果进入写入操作，则追加在末尾写入 （不管写之前进行了什么)                                                                 |
| b    | "b" 表示“二进制 （binary）”：在打开文件时， 加上这个字符标志，表示文件 以二进制模式打开，不对文件 内容进行任何新行转换。在处 b 理文本文件时，通常不需要使 用"b"，但在处理二进制文件 open() flag （比如图像、声音、编译好的 程序等）时，必须使用 "b" 来 确保数据正确读写.比如rb或 wb |
* 成功：返回文件流指针，失败：返回NULL
## fclose
* 根据文件流指针进行刷新缓冲区以及关闭该文件的io流，释放对应资源。
```c
fclose(fp);//这里fp是一个文件流指针
```
* 成功：返回  0，失败：返回 EOF== -1（EOF就是文件结束标志：end of file）
## fscanf
* 按格式读取文件中的数据到内存中，可以自己定义一个符合格式的变量来接收
```c
typedef struct Data{
    char title[32];
    char director[16];
    float mark;
    int year;
}Data;
Data movie;
fscanf(fp,"%s %s %f %d\n",movie.title,movie.director,&movie.mark,&movie.year)
```
* 成功：返回成功的项数
* 文件结束(EOF)：如果在读取任何数据之前遇到文件结尾，返回 EOF == -1
* 错误：如果读取过程中发生错误，也返回 EOF == -1
## fprintf
* 按照格式输出数据到文件中,需要从内存中取对应格式的变量中的数据
```c
fprintf(fp,"%s %s %f %d\n",movie.title,movie.director,movie.mark,movie.year)
```
* 成功：返回成功的项数，失败/发生错误：返回一个负数
## fgets
* 读取文件里**一行**内容
```c
fgets(str,13,fp);//依次为独到的数据接收的地址，预期读取字节数，文件流指针
```
1. **预期读取字节数的控制：当'\n'之前的字节个数小于size，遇到换行符时候强行结束读取，但是换行符也会被当做一个字符被读到内存之中，并且会在最后一个字符后添加'\0'.   实际：如果读取换行符时不足size，那么后续的字符就是null。 返回值：当'\n'之前的字节个数大于size,会读到size-1个大小的字节时停止读取会在末尾加上一个'\0'。读取完之后读写指针停留在size-1的后面一个字节。** 
* 例子：给的size为5，实际文件一行有10个。那么会实际读取 4个数据，第5个为\0.下一次读取会继续从文件的第5个字节继续读。
2. 成功：返回字符串首地址，失败/读到文件末尾：返回NULL
## fputs
* int fputs(const char \*str, FILE \*stream)
* 把str字符串写入到文件流指针里面，不追加\n
## putchar
* 向终端输出一个字符
```c
char ch='h';
putchar(ch);
```
## getchar
* 向终端获取一个字符，返回ascall码
```c
int main ()
{
   char c;
   c = getchar();
   printf("输入的字符：");
   putchar(c);
   return(0);
}
```
## gets(已经被废弃，)
* C 库函数 char \*gets(char \*str)从标准输入stdin读取一行，并把它存储在 str 所指向的字符串中。当读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。
```c
int main()
{
   char str[50];
   printf("请输入一个字符串：");
   gets(str);
   printf("您输入的字符串是：%s", str);
   return(0);
}
```
## puts
## scanf
* **如果缓存区有东西，scanf会认为已经输入了内容，不会阻塞程序！！！！一些无限循环bug就是因此引发的** 
* 可以利用fgets或者getchar将缓存区清空，就正常了(gets被废弃了，别用);
```c
int main(){
	bool isRun =true;
	do{
		int choose;
		puts("1. 登录 2. 注册 3. 退出");
		scanf("%d",&choose);//接受缓存区里的第一个遇到的连续数字
		switch(choose){
			case 1: puts("登录函数");break;
			case 2: puts("注册函数");break;
			case 3: isRun = false;break;
		}
		
		while(getchar()!='\n'){};
		//char data[100]="";
		//fgets(data,100,stdin);//接收终端的一行内容，用fgets的话需要搞个新变量，而且有长度                                 //限制，getchar不需要
	}while(isRun);
    return 0;
}

```
## fputc
* 向文件输出一个字符
```c
fputc(ch, fp);
```
## fgetc
* 从指定的文件流中获取一个字符
```c
int fgetc(FILE *stream);
```
* 返回值: 成功: 返回获取到的字符转化成的int类型的数据      失败: 返回 EOF 到达文件末尾 EOF。EOF表示到达文件末尾，可以直接 用在判断逻辑语句中
## fread
* 以字节方式读取文件流
```c
fread(void *ptr, size, count, FILE *stream);
```
  * ptr ：指向一块内存的指针，用来存储读取的数据。 （记得提前分配好空间）
  * size ：每个数据项的大小，以字节为单位。 
  * count ：要读取的数据项个数。 
  * stream ：指向 FILE 对象的指针，代表一个打开的文件。 
* **返回值：** 返回实际读取的数据项个数，如果这个数小于了count，可能是发生了错误或者达到了文件末尾。
### perror
* 输出标准错误:**void perror(const char \*str )** 把一个描述性错误消息输出到标准错误 stderr。首先输出字符串 **str**，后跟一个冒号，然后是一个空格，再后面就是错误信息。
## ftell
* 获取当前光标位置
* C 库函数 **long int ftell(FILE \*stream)** 返回给定文件流的当前光标位置。
## fseek
* 改变光标位置
* C 库函数 **int fseek(FILE \*stream, long int offset, int whence)** 设置流 **stream** 的文件位置为给定的偏移 **offset**，参数 offset 意味着从给定的 **whence** 位置查找的字节数。
    * -**stream** -- 这是指向 FILE 对象的指针，该 FILE 对象标识了流。
    - -**offset** -- 这是相对 whence 的偏移量，以字节为单位：负数向前，正数向后
    - -**whence** -- 这是表示开始添加偏移 offset 的位置。它一般指定为下列常量之一：0为起始，1为当前光标，2为末尾
## rewind
* 重置光标位置为开头
* void rewind(FILE \*filestream);