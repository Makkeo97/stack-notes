# 指针是什么？
* 指针的本质就是一个变量，他保存的是内存的地址！！！
* 指针变量的大小是8个字节
# 解引用操作符（* ）是个什么东西？

它作用是引用指针指向的变量值，引用其实就是引用该变量的地址，“解”就是把该地址对应的东西解开，解出来，就像打开一个包裹一样，那就是该变量的值了，所以称为“解引用”。 也就是说，解引用是返回内存地址中对应的对象。

\*解引用也可以改变该变量的数值。

需要注意的是，在变量声明的时候，\*不能当做解引用使用，只是表示你声明的变量是一个指针类型。
```c
#include <stdio.h>
int main()
{
	int a = 10;
	int *p = &a;//取出a地址，并存放在指针变量中
	//①int说明p指向的对象是int类型 ②*说明p是指针变量
    *p=100;
    printf("%d",*p);//输出100
	return 0;
}
```
# 利用指针操作结构体中的变量
* **(str+i)->number**
# 数组指针&指针数组
## 数组指针
* 数组指针：**指向数组的指针**，一般常见于二维数组中
* 特点:对数组指针进行解引用，拿到的是数组指针指向数组的第一个数据的地址。所以即无论是输出数组指针本身还是对其进行解引用，拿到的都是第一个数据的地址。
```c
int array[3][2]={{1,2},{3,4},{5,6}};
//array本身就是一个数组指针array+1指向第二行，步进为一行，把他解引用*(*(arr+1)+1)就代表第二行的二个元素的内容：4；
//int *p=*array; 代表指向a第一行第一个元素的指针，解一次就是第一个元素,步进为一个int；
int array[3][2]={{1,2},{3,4},{5,6}};
int *p =*array;
int main(){
	printf("%d",*(*(array+1)+1));
	printf("%d",*(p+1));
} 
```
* 问题：为什么这样设计：数组指针更多的是配合二维数组和一维数组以及具体的数据的之间的层级关系。以及数组指针本身没有专属的内存地址，所以我们输出数组指针的地址时会退化为输出其数组第一个数据的地址。
```c
void demo(int arr[3][2],int line,int col);
//1. 定义数组指针  int (*p)[2]  :定义指针变量p，指向一个长度为2 的int一维数组
int main(){
	system("clear");
	int nums[3][2] ={
		{9,6},{1,7},{8,3}
	};
	printf("%p\n",&nums[0][0]);
	printf("%p\n",&nums[0][1]);
	printf("%p\n",&nums[1][0]);
	printf("%p\n",&nums[1][1]);
	printf("%p\n",&nums[2][0]);
	printf("%p\n",&nums[2][1]);
	puts("--------------");
    demo(nums,3,2);
	return 0;
}

void demo(int (*arr)[2],int line,int col){
	//遍历传过来的二维数组:实际传递过来的是数组指针
	//得到的内存地址就是该一维数组第一个数据的地址
	//printf("地址:%p\n",arr);//退化为第一个数据的地址
	//printf("解引用:%p\n",*arr);//标准语法
	//问题：拿到第二个一维数组的第一个数据的地址（标准和退化玩法）
	//arr+1;//指向第二个一维数组（数组指针）。}
	//printf("%p\n",arr+1);//退化
	//printf("%p\n",*(arr+1));//标准语法
	
	//应用：利用数组指针来完成二维数组的遍历
	for(int i=0;i<line;i++){
		//标准方式要两次交换：1.int (*p)[2]=arr +i;//数组指针
		//                   2.int *pp = *p;//拿到数组指针里 第一个数据的地址
		for(int j=0;j<col;j++){
			//标准方式
			//printf("%d\n",*(pp+j));
			//退化方式，只用一次：多次解引用
			printf("%d\n", *(*(arr+i) +j));
		}
	}
}

```
## 指针数组
* 顾名思义：一个数组里面存的全是指针
# 指针运算
1. 指针运算只存在于数组中，本质就是地址以步进长度++--
2. 指针之间可以比较，但前提是同一个数组，不是同一个数组之间没有意义
	* 指针比较：> < =
	* 指针比较获取的是两个指针之间数据位置的差值：比如：**&nums[2]-&nums[4]=-2（不是地址，这里要注意）**
	* **不能加、乘、除，只支持减法！！！**
	* 不同数组的指针也可以比较，但是单纯比较的是地址的大小，没有任何意义
# 多级指针
* 顾名思义，指向指针的指针：类似于套娃一层一层指向上一级指针变量的地址
# 函数指针和指针函数
## 函数指针
* 函数指针就是利用指针调用函数的一种方法，也可以回调函数
* **函数指针不能解引用！！！！**
```c
void chengfa(float n1,float n2){
	printf("结果：%f\n",n1*n2);
}
void chufa(float n1, float n2) {
	if (n2 != 0) {
		printf("结果: %f\n", n1 / n2);
	} else {
		printf("错误: 除数不能为零\n");
	}
}
void jiafa(float n1, float n2) {
	printf("结果: %f\n", n1 + n2);
}
void jianfa(float n1, float n2) {
	printf("结果: %f\n", n1 - n2);
}
int main(){
	float num1,num2;
	char ch;
	puts("请输入计算表达式：");
	scanf("%f%c%f",&num1,&ch,&num2);
	void (*fun)(float n1,float n2);//这里就是函数指针的定义，可以用void实现任意类型函数
	fun=NULL;
	switch(ch){
		case '*':fun=chengfa;fun(num1,num2);break;
		case '/':fun=chufa;fun(num1,num2);break;
		case '+':fun=jiafa;fun(num1,num2);break;
		case '-':fun=jianfa;fun(num1,num2);break;
	}
	return 0;
}
```
## 指针函数
* 指针函数就是返回指针的函数（本质就是返回地址的函数）
```c
struct User{
	char name[16];
	char address[16];
	char phone[16];
};

typedef struct List{
	struct User *users;
	int capacity;
	int length;
}List;
List * init(int capacity);//初始化动态数组
int main(){
	List *l = init(2);
	return 0;
}
List * init(int capacity){	
	List *list=malloc(sizeof(List));//为动态数组分配空间
	list->users=calloc(capacity,sizeof(struct User));//为动态数组中的users数组分配空间
	memset(list->users,0,capacity*sizeof(struct User));//初始化users数组
	list->capacity=capacity;//容量初始化为指定的值
	list->length=0;//长度初始化
	return list;//返回地址
}
```
# 结构体指针
* 结构体指针要注意成员运算符是：->
```C
struct Demo{
	char name[16];
};
struct Demo ds[3]={"www","zzz","ttt"};
int main(){
	for(int i=0;i<3;i++){
		printf("%s\n",(ds+i)->name);
		printf("%s\n",ds[i].name);//这两个都可以，等价的
	}
}
```
