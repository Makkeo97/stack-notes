# 自定义头文件的流程
## 1. 创建xxx.h文件
1. 要先include需要用到的头文件：
```c
#include <stdio.h>
#include......
//把需要用到的C语言标准头文件全部包含进去
```
2. 然后自定义头文件的名字和内容：
```c 
#ifndef PTHREAD_H //自定义头文件的名字（一定要大写加下划线！！！）
#define PTHREAD_H    

//1.声明需要用到的函数以及变量

//一定要先在上面声明再在下面书写函数内容，否则会出问题，上面的函数调用不到下面的函数

//2.书写所有用到的函数

#endif   
```

## 2. 在真正执行代码的目标文件中包含自定义头文件
```c
#include "自定义头文件.h"

//#include<>是从C的标准头文件中调用头文件，#include""是从指定路径下调用头文件
//从当前路径下调用的话直接写文件名字就行，不需要路径
```
## 3. 联合编译所有文件
```c
gcc 要编译的目标文件.c 需要联合编译的自定义头文件.h -lpthread -lSDL2 -lSDL2_mixer

// -后面的是整个目标文件包括自定义头文件所需要的所有参数
```
## 4. 运行编译后的可执行文件
```c
./a.out
```
# 以自定义线程池头文件来举例
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <stdbool.h>
#include <semaphore.h>

#ifndef PTHREADPOOL_H
#define PTHREADPOOL_H

//定义用到的变量
bool pthreadpoolisRun = true;
int waitCount=0;

//声明结构体
//任务结构体
typedef struct Task{
    void* (*fun)(void *args);
    void *args;
}Task;
//队列节点
typedef struct Node{
    Task task;
    struct Node *next;
}Node;
//任务队列结构体
typedef struct TaskQueue{
    Node *head;
    Node *end;
    int length;//任务队列的长度
}TaskQueue;
//线程池结构体
typedef struct Pool{
    pthread_t *pids;//线程池数组（用于存放每一个线程标识符）
    TaskQueue *taskQueue;//指向任务队列的指针（使用指针便于访问任务队列）
    int pCount;//允许创建的线程数量
    sem_t taskSem;//用于线程调度控制的任务量
}Pool;

//声明函数
//初始化线程池
Pool * initPool(int pCount);
//在线程里负责执行的函数，用函数指针便于传入线程操作
void * worker(void *args);
//创建新的队列节点
Node * createNode(Task t);
//入队
bool push(TaskQueue *q,Task t);
//出队
Task pop(TaskQueue *q);
//添加任务
void addTask(Pool *p,Task t);
//测试
void * demo(void *args);
//销毁线程池
void poolDestory(Pool *p);

//具体函数代码
Pool * initPool(int pCount){
    Pool *p=malloc(sizeof(Pool));//分配线程池的空间
    p->pids=malloc(sizeof(pthread_t)*pCount);//分配线程池内部存放标识符的数组空间
    for(int i=0;i<pCount;i++){
        pthread_create( (p->pids)+i,NULL,worker,p );//创建指定数量的线程
    }
    p->taskQueue=malloc(sizeof(TaskQueue));//给线程池内部任务队列分配空间
    //初始化线程池内部任务队列的各项数据
    p->taskQueue->head=NULL;
    p->taskQueue->end=NULL;
    p->taskQueue->length=0;
    //初始化线程池的线程数量为指定值
    p->pCount=pCount;
    //初始化线程池内部调度信号量,因为信号量本质是个数字，用->解出来就是他本身了，所以取地址传进去
    sem_init(&(p->taskSem),0,0);
    return p;
}
void * worker(void *args){
    Pool *p=(Pool*)args;
    pthread_t pid=pthread_self();
    pthread_detach(pid);
    printf("线程创建：%ld\n",pid);
    while(pthreadpoolisRun){
        waitCount++;
        sem_wait(&p->taskSem);
        waitCount--;
        printf("线程执行：%ld\n",pid);
        Task t = pop(p->taskQueue);
        if(t.fun!=NULL){
            t.fun(t.args);//执行任务
        }
    }
}
Node * createNode(Task t){
    Node *newNode=malloc(sizeof(Node));
    newNode->task=t;
    newNode->next=NULL;
    return newNode;
}
bool push(TaskQueue *q,Task t){
    if(q==NULL){
        return false;
    }
    Node *newNode = createNode(t);
    if(q->head==NULL){
        q->head=newNode;
        q->end=newNode;
    }else{
        q->end->next=newNode;
        q->end=newNode;
    }
    q->length++;
    return true;
}
Task pop(TaskQueue *q){
    Task output={0};
    if(q==NULL||q->head==NULL){
        return output;
    }
    output=q->head->task;
    if(q->head==q->end){
        free(q->head);
        q->head=NULL;
        q->end=NULL;
    }else{
        Node *oldHead=q->head;
        q->head=q->head->next;
        free(oldHead);
        oldHead=NULL;
    }
    q->length--;
    return output;
}
void addTask(Pool *p,Task t){
    if(p==NULL){
        return;
    }
    bool isAdd = push(p->taskQueue,t);//只有正确入队才会释放信号量
    if(isAdd){
        sem_post(&p->taskSem);
    }
}

void poolDestory(Pool *p){
    if(p==NULL){
        return;
    }
    while(p->taskQueue->length>0){
        usleep(500*1000);
    }
    pthreadpoolisRun=false;
    for(int i=0;i<waitCount;i++){
		sem_post(&p->taskSem);
	}
    for(int i=0;i<p->pCount;i++){
        pthread_cancel(p->pids[i]);
    }
    free(p->pids);
    free(p->taskQueue);
    sem_destroy(&p->taskSem);
    free(p);
    p=NULL;
}

#endif
```
