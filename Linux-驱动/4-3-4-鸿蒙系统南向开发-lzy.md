## 4-3-4-鸿蒙系统南向开发

### 鸿蒙介绍

#### 谈一谈 HarmonyOS

鸿蒙操作系统是华为自主研发的操作系统，鸿蒙系统也叫做 HarmonyOS，这里的 OS 指的是操作系统，像我们熟悉的 Android IOS Linux Windows 都属于 OS（操作系统）。鸿蒙这个词带有浓重的中国色彩，古人认为开天辟地之前是一团混沌的元气，这团气就叫做“鸿蒙”，是世间万物的起点。华为将自主研发的操作系统命名为“鸿蒙”可以看出华为从零开始的心态以及开天辟地的决心。而在英文中，Harmony 指的是一种和谐相处 互相认可的状态，也就是和谐共存，天下大同。暗示这款操作系统从零开始又肩负天下大同的使命。HarmonyOS 是一款面向万物互联时代的，全新的分布式操作系统。在传统的单设备系统能力基础上，HarmonyOS 提出了基于同一套系统能力，适配多种终端形态的分布式理念，能够支持手机，平板，智能穿戴，智慧屏，车机 ，PC，智能音箱，耳机，AR/VR 眼镜等多种终端设备，提供全场景（移动办公，运动健康，社交通信，媒体娱乐等）业务能力。

鸿蒙操作系统的历史发展可以追溯到华为公司在 2012 年开始对分布式操作系统的研究和探索。

在 2019 年，美国政府对华为实施制裁，禁止华为使用美国的技术和软件，其中包括谷歌的 Android 操作系统。这一制裁对华为的智能手机业务产生了重大影响，迫使华为寻找替代方案。

面对制裁的挑战，华为加快了鸿蒙操作系统的开发进程，经过 7 年的研发并且于 2019 年8 月 9 号正式来到我们面前，鸿蒙的诞生拉开了永久性改变操作系统全球格局的序幕。

在 2020 年 9 月 10 日的华为开发者大会上，华为宣布鸿蒙 2.0 正式发布。和 HarmonyOS1.0版本相比，Harmony2.0 在分布式软总线，分布式数据管理 分布式安全等分布式能力上进行了升级。并扩展了鸿蒙操作系统的应用范围，包括智能手机，平板电脑，智能电视及其智能设备。鸿蒙 2.0 引入了分布式能力，使不同设备之间可以实现无缝连接和协作。

2022 年 11 月 4 日，华为开发者大会 2022 上，华为推出了 HarmonyOS3.1 版本，HarmonyOS3.1 引入了 Stage 模型。

自此，华为继续推动鸿蒙操作系统的发展，将其应用于各种华为产品中。鸿蒙操作系统的版本和功能完善仍在进行中，以满足用户和开发者的需求。

截止2023年11月15日，华为在2023年的8月4日的华为开发者大会上发布了HarmonyOS4，全新升级的鸿蒙开发套件，HarmonyOS Next 开发者预览版等一系列先进技术，CEO 余承东公布鸿蒙生态的最新进展，他说到：“自 2019 年 HarmonyOS 问世以来，凭借简洁、流畅、安全的体验受到大家喜爱，已成为发展最快 的操作系统，鸿蒙生态的设备数量已超过 7 亿 ，已有 220 万 HarmonyOS 开发者投入到鸿蒙世界的开发中来，鸿蒙生态已过万重山！我们期待与众多开发者、合作伙伴们一起继续建设更美好的鸿蒙世界。”

#### OpenHarmony 的诞生及历史发展

OpenHarmony 的诞生离不开 HarmonyOS，Openharmony 是华为公司捐赠的智能终端操作系 统基础能力相关代码，并由全球开发者共同建设的开源分布式操作系统。该操作系统具备面 向全场景和分布式等特点，是一款全新开放的操作系统。

Openharmony开源项目是由开放原子开源基金会孵化和运营的开源项目，由开放原子开源 基金会的 Openharmony 项目群工作委员会项目负责运作。

接下来了解一下开放原子开源基金会

> 开放原子开源基金会（OpenAtom Foundation）是一个致力于促进开源技术和创新的非营利组织。该基金 会旨在推动开源社区的发展，促进开源项目的合作和共享，并提供支持和资源来推动开源技术的采纳和应 用。开放原子开源基金会的使命是通过建立和维护开源项目、组织开源活动和培训，以及提供开源技术咨 询和支持等方式，促进开源社区的生态系统健康发展。

OpenHarmony 是一个快速发展的操作系统 ，迭代速度快 ，版本多 。到 2023 年 12 月 OpenHarmony 一共发布了四个主要版本，分别是第一版（1.x），第二版（2.x）,第三版（3.x）, 第四版（4.x）。openHarmony 的演进图如下图所示

![image-20240722130700570](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722130700570.png)

在 2020 年 9 月 10 日的华为开发者大会上，华为宣布鸿蒙 2.0 正式发布，华为向开放原子 基金会捐赠智能终端操作系统基础能力相关代码，Openharmony1.0 版本正式开源。

2021 年 4 月 1 日，Openharmony 发布首个长期支持版本 Openharmony1.1.0LTS。

2021 年 6 月 1 日，华为将内存为 128MB~4GB 的富设备上运行的代码和内存为 4GB 以上

的大型设备上运行的代码，一次性全部开源，这就是 Openharmony2.0.

2021 年 9 月 30 日，Openharmony 发布了 Openharmony3.0 LTS 版本。

2022 年 3 月 30 日，Openharmony 发布了 Openharmony3.1release 版本。 2023 年 4 月，Openharmony 发布了 Openharmony3.2release 版本。

2023 年 10 月 25 日，Openharmony 发布了 Openharmony4.0release 版本。

除了上述版本，OpenHarmony 还在不断发展和演进中，可能会发布更多的版本，以满足 不同设备和应用场景的需求。每个版本都会带来新的功能、改进和优化，以提升用户体验和 开发者的便利性。

以上是 Openharmony 的简单历史。

#### Openharmony 和 HarmonyOS 区别

经过前面的学习，我们认识到 OpenHarmony 和 HarmonyOS（鸿蒙操作系统）是两个相关 但不完全相同的概念。HarmonyOS 是华为自己使用的商用系统，我们平时使用的华为手机 华 为手表 智慧屏等都是搭载的 HarmonyOS 系统。而 OpenHarmony 是华为把 HarmonyOS  中基 础功能提取出来打包成功的一个项目 。把 Openharmony 捐献给了开源原子基金会。而华为 自己的商业版本 HarmonyOS 并没有捐出，这个商业版本也是基于开源项目 OpenHarmony 开 发的，兼容了 AOSP ，增加了 HMS 。

总结一下，Openharmony 是 HarmonyOS 的开源组成部分，类似于安卓的 AOSP。作为一个 开源项目，Openharmony 提供了操作系统的最基础能力。而 HarmonyOS 则是基于 Openharmony 构建的商用版本，用于商业化发布和应用。

#### HarmonyOS 是 Android 套壳？

和所有新生事物一样，鸿蒙刚刚发布的时候，遭受了很多非议，主要的争议点是鸿蒙采用 了不少安卓系统代码，也正因为如此，鸿蒙系统也被称为套壳安卓。HarmonyOS 和 Android 之 间有什么关系呢？为什么 HarmonyOS 可以兼容运行Android 应用呢？很多人会产生一些疑惑。

鸿蒙操作系统和 Android 是俩个不同的操作系统，它们之间有一些相似之处，也有很多不 同之处。

首先，鸿蒙操作系统是华为开发的分布式操作系统，是一个全新的操作系统，不是基于 Android 开发的，也不是 Android 的套壳，鸿蒙的内核是基于微内核架构设计的，与 Android 的内核有很大的区别。此外，鸿蒙的应用程序和 Android 的应用程序也不兼容，需要重新开发 和适配。

而 Android 是由谷歌开发的移动操作系统，主要是用于智能手机和平板电脑等移动设备。 它是一个闭源的商业软件，由谷歌控制和维护。Android 的源代码是基于 AOSP（Android Open Source Project）开发的，AOSP 是一个开源项目，由谷歌主导，旨在提供一个开放的，可定制 的，可移植的 Android 操作系统。AOSP 的源代码是公开的，任何人都可以下载，修改和使用 它。AOSP 的目标是为开发者提供一个基础的 Android 操作系统，以便它们可以根据自己的需 要进行修改和定制。

HarmonyOS 上面可以运行 Android 应用便是因为 Harmony 上集成了 AOSP，AOSP 是一项重 要的操作系统接口库级别的技术，它为各种操作系统提供了一个平台，只要这些操作系统集 成了这个接口库，就能够运行 Android 应用程序。这项技术并不仅限于 Android 和鸿蒙。实际 上只要愿意接入这个接口库的操作系统都可以运行 Android 应用程序。一个很好的例子就是 windows11 ，它成功集成了 AOSP ，并且可以运行 Android 应用程序 。为了消费者考虑 ， HarmonyOS 现阶段兼容 Android 是一种务实的选择。

虽然 HarmonyOS 在某些方面与 Android 有一些相似之处，在应用开发方面提供了一些兼 容性层和工具，以帮助开发者迁移和兼容 Android 应用，但是这并不意味着 HarmonyOS 套壳 了 Android 系统，而是华为自主研发的独立操作系统。

想必大家还有一个疑惑。HarmonyOS 可以运行 Android APK ，那 Openharmony 可以运行 Android APK 吗？

OpenHarmony 是不含 AOSP 的，现在连 Java 都跑不起来，所以 Openharmony 是不可以运 行 Android APK 的。HarmonyOS 是 OpenHarmony 的厂商定制版。HarmonyOS 在初期确实面临 了生态薄弱的挑战，很多应用缺乏开发者支持，如果直接将初始版本的 Openharmony 推向用 户，新系统可能面临失败的风险，就像给用户提供一个毛坯房一样。然而，幸运的是，经过 多年的不懈努力，HarmonyOS 不断进行迭代升级，其实力已经有了翻天覆地的变化。

在 2023 年的开发者大会上，除了大家期待的 HarmonyOS4 ，华为还公布了一个惊喜，那 就是：HarmonyOS Next 开发者预览版。HarmonyOS Next 作为鸿蒙系统的升级版本，采用了全 新的底层架构，去掉了 AOSP ，仅支持鸿蒙内核和鸿蒙系统应用。我认为，这是鸿蒙迈向更高 峰的必经之路，它能更好地构建自己的鸿蒙生态链，对鸿蒙未来的发展有深远而重要的意义。

### Openharmony 整体框架

#### Openharmony 技术架构

在上个章节中，我们对 Openharmony 有了大概的印象，本章节我们以 Openharmony 源码 框架结构的角度，再次对 Openharmony 进行深层次的认识。注意 OpenHarmony 系统是不断 发展的，随着操作系统版本的升级，功能框架也会跟随着升级，本章节以 OpenHarmony OS 4.0版本为例进行讲解。

首先要为大家介绍 Openharmony 整体架构是如何设计的。Openharmony 的整体功能框架 自下而上分为 4 个层次，分别是内核层，系统服务层，框架层和应用层。系统功能按照“系 统->子系统->功能/模块 ”逐级展开，在多设备部署场景下，支持根据实际需求裁剪某些不必 要的子系统或者模块。OpenHarmony 技术架构如下图所示

![image-20240722130642533](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722130642533.png)

首先我们看一下**内核层**，内核层包括内核子系统和驱动子系统

> 内核子系统：采用多内核（Linux 内核或者 LiteOS）设计，支持针对不同资源受限设备选用适 合的 OS 内核。内核抽象层（KAL ，Kernel Abstract Layer）通过屏蔽多内核差异，对上层提供基 础的内核能力，包括进程/线程管理、内存管理、文件系统、网络管理和外设管理等。
>
> 驱动子系统：硬件驱动框架（HDF）是系统硬件生态开放的基础，提供统一外设访问能力和驱 动开发、管理框架。驱动子系统直接和硬件设备交互，给内核子系统提供服务。

**再上一层是系统服务层**

系统服务层是 OpenHarmony 的核心能力集合，通过框架层对应用程序提供服务。该层包含以 下几个部分：

> （1）系统基本能力子系统集：为分布式应用在多设备上的运行、调度、迁移等操作提供了基 础能力，由分布式软总线、分布式数据管理、分布式任务调度、公共基础库、多模输入、图 形、安全、AI 等子系统组成。
>
> （2）基础软件服务子系统集：提供公共的、通用的软件服务，由事件通知、电话、多媒体、 DFX（Design For X） 等子系统组成。
>
> （3）增强软件服务子系统集：提供针对不同设备的、差异化的能力增强型软件服务，由智慧屏专有业务、穿戴专有业务、IoT 专有业务等子系统组成。
>
> （4）硬件服务子系统集：提供硬件服务，由位置服务、用户 IAM 、穿戴专有硬件服务、IoT 专有硬件服务等子系统组成。

根据不同设备形态的部署环境，基础软件服务子系统集、增强软件服务子系统集、硬件服 务子系统集内部可以按子系统粒度裁剪，每个子系统内部又可以按功能粒度裁剪。

**框架层**

框架层为应用开发提供了 C/C++/JS 等多语言的用户程序框架和 Ability 框架，适用于 JS 语 言的 ArkUI 框架，以及各种软硬件服务对外开放的多语言框架 API。根据系统的组件化裁剪程 度，设备支持的 API 也会有所不同。

**应用层**

应用层包括系统应用和第三方非系统应用。应用由一个或多个 FA（Feature Ability）或 PA （Particle Ability）组成。其中，FA 有 UI 界面，提供与用户交互的能力；而 PA 无 UI 界面，提 供后台运行任务的能力以及统一的数据访问抽象。基于 FA/PA 开发的应用，能够实现特定的 业务功能，支持跨设备调度与分发，为用户提供一致、高效的应用体验。

#### Openharmony 技术特性

OpenHarmony 技术特性有三个：硬件互助，资源共享、一次开发，多端部署、统一 OS ，弹性 部署。

**一、硬件互助，资源共享**

多设备之间实现硬件互助，资源共享依靠的关键技术包括：

**（1）分布式软总线**

分布式软总线是多设备终端的统一基座，为设备间的无缝互联提供了统一的分布式通信能 力，能够快速发现并连接设备，高效地传输任务和数据。一个典型的应用场景是智能家居系 统。在智能家居系统中，有各种智能设备，如智能灯泡，智能插座，智能门锁等。这些设备 需要相互通信和协作，以实现家居的智能化控制和联动操作。通过分布式软总线，这些智能 设备可以连接到一个共享的总线上。每个设备被视为系统中的一个节点，在总线上进行通信。

**（2）分布式数据管理**

分布式数据管理位于基于分布式软总线之上的能力，实现了应用程序数据和用户数据的分 布式管理。用户数据不再与单一物理设备绑定，业务逻辑与数据存储分离，应用跨设备运行 时数据无缝衔接，为打造一致，流畅的用户体验创造了基础条件。还是拿智能家居控制系统 来说，智能家居中的传感器，摄像头，智能音箱等设备可以通过分布式数据管理进行数据共 享和协作。

**（3）分布式任务调度**

分布式任务调度基于分布式软总线、分布式数据管理、分布式 Profile 等技术特性，构建 统一的分布式服务管理（发现、同步、注册、调用）机制，支持对跨设备的应用进行远程启 动、远程调用、绑定/解绑、以及迁移等操作，能够根据不同设备的能力、位置、业务运行状 态、资源使用情况并结合用户的习惯和意图，选择最合适的设备运行分布式任务。

**（4）设备虚拟化**

分布式虚拟化平台可以实现不同设备的资源融合，设备管理，数据管理，将周边设备作为 手机能力的延伸，共同形成一个超级虚拟终端。

分布式软总线，分布式任务调度和数据管理，原子化服务，可以支持 OpenHarmony 设备 间跨端迁移，多端协同，一次开发多端部署，实现可分可合可流转，无设备资源结束的局限， 存在丰富多样化发展的可能性。

**二、一次开发，多端部署**

OpenHarmony 提供用户程序框架、Ability 框架以及 UI 框架，能够保证开发的应用在多终 端运行时保证一致性。一次开发、多端部署。

多终端软件平台 API 具备一致性，确保用户程序的运行兼容性。

l 支持在开发过程中预览终端的能力适配情况（CPU/内存/外设/软件资源等）。

l 支持根据用户程序与软件平台的兼容性来调度用户呈现。

**三、统一 OS ，弹性部署**

OpenHarmony 通过组件化和组件弹性化等设计方法，做到硬件资源的可大可小，在多种 终端设备间，按需弹性部署，全面覆盖了 ARM 、RISC-V 、x86 等各种 CPU ，从百 KiB 到 GiB 级 别的 RAM。

#### OpenHarmony 支持设备类型

在学习 OpenHarmony 开发之前，首先需要了解下 OpenHarmony 支持的系统类型，方便后 续根据自身业务选择对应的系统。

OpenHarmony 支持如下几种系统类型：

**轻量系统（ mini system）**

面向 MCU 类处理器例如 Arm Cortex-M 、RISC-V 32 位的设备，硬件资源极其有限，支持的 设备最小内存为 128KiB，可以提供多种轻量级网络协议，轻量级的图形框架，以及丰富的 IOT 总线读写部件等。可支撑的产品如智能家居领域的连接类模组、传感器设备、穿戴类设备等。

**小型系统（small system）**

面向应用处理器例如 Arm Cortex-A 的设备，支持的设备最小内存为 1MiB ，可以提供更高 的安全能力、标准的图形框架、视频编解码的多媒体能力。可支撑的产品如智能家居领域的 IP Camera 、电子猫眼、路由器以及智慧出行域的行车记录仪等。

**标准系统（standard system）**

面向应用处理器例如 Arm Cortex-A 的设备，支持的设备最小内存为 128MiB ，可以提供增 强的交互能力、3D GPU 以及硬件合成能力、更多控件以及动效更丰富的图形能力、完整的应 用框架。可支撑的产品如高端的冰箱显示屏。

#### 南向开发和北向开发

在 Openharmony 中，Openharmony 开发分为南向开发和北向开发，那么南向开发和北向 开发是什么呢？

南向开发指的是嵌入式开发，是指底层设备和系统交互的开发过程。它主要关注底层硬件 操作和能力封装，旨在实现对硬件设备的控制和管理。南向开发通常使用C 语言，C++ 语言 来控制硬件，编写驱动程序，因为这些语言具有直接操作硬件的能力。南向开发的例子比如 控制 LED 灯的亮灭，读取按键状态，点亮屏幕，配置wifi 蓝牙等等。

而北向开发通常指纯软件的应用开发，也可以称为 APP 开发，它主要关注于业务逻辑的 实现。北向开发使用 Java、JavaScript、TypeScript 等语言来开发应用程序。其目标是满足客户 需求，实现应用的功能。

通过 Openharmony 功能框图可以看出最上面是应用层，最下面是内核层。简单的口诀“上 北下南 ”可以帮助我们理解南向开发和北向开发的区别。上层开发属于北向开发，关注业务 逻辑；下层开发属于南向开发，关注硬件操作和能力封装。

#### OpenHarmony 和安卓应用开发的区别

![image-20240722131105762](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722131105762.png)

OpenHarmony 和 Android 的开发环境都是在 Windows 系统上运行的。开发工具也是有区 别的，OpenHarmony 使用的是 DevEco Studio ，Android 应用开发使用的是 Android Studio。

调试工具方面 Android 系统使用 adb ，OpenHarmony 使用的是 HDC 工具，具体的使用，在后面的章节中会进行讲解。另外在开发语言方面也有差异，Android 使用的是 Java 或者 Kotlin， OpenHarmony 使用的是 JS/arkTS/仓颉语言。另外 OpenHarmony 使用的是自研的方舟开发框 架。OpenHarmony 应用开发编译和运行时使用的是方舟编译器和 Runtime，Android 应用开发 编译和运行时使用的是 Java 编译器和 Runtime 。最后还有一个区别是应用包的格式，Open Harmony 使用的是 HAP ，Android 使用的是 APK。

![image-20240722131456021](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722131456021.png)

### 获取 OpenHarmony 源码

OpenHarmony 当前为开发者提供了以下 4 种获取源码的方式，开发者可根据业务诉求选 用合适的方式获取源码：

获取方式 1：从码云代码仓库获取。通过 repo 或 git 工具从代码仓库中下载，此方式可获取最 新代码。

获取方式 2 ：通过 DevEco Marketplace 网站获取。访问 DevEco Marketplace 网站，查找满足需 求的开源发行版，直接下载（或者定制后下载），再通过 hpm-cli 命令工具将所需的组件及工 具链下载、安装到本地。

获取方式 3 ：从镜像站点下载归档后的发行版压缩文件。如果要获取旧版本的源码，也可通 过此方式获取，此方式下载速度较快。

获取方式 4 ：从 github 代码仓库获取。通过 repo 或 git 工具从代码仓库中下载，此方式可获 取最新代码。

我们这里采用获取方式 1 ：从码云代码仓库获取。OpenHarmony 源码在 Gitee 上获取，浏 览器输入 https://gitee.com/openharmony/ 进入官网，如下图所示：

![image-20240722131707699](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722131707699.png)

![image-20240722131758712](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722131758712.png)

### 初次编译 OpenHarmony 源码

**安装依赖库**

输入以下命令安装依赖库

```shell
sudo apt-get install binutils binutils-dev git git-lfs gnupg flex bison gperf build-essential zip curl zlib1g-dev libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip m4 bc gnutls-bin python3.8 python3-pip ruby genext2fs device-tree-compiler make libffi-dev e2fsprogs pkg-config perl openssl libssl-dev libelf-dev libdwarf-dev u-boot-tools mtd-utils cpio doxygen liblz4-tool openjdk-8-jre gcc g++ texinfo dosfstools mtools default-jre default-jdk libncurses5 apt-utils wget scons python3.8-distutils tar rsync git-core libxml2-dev lib32z-dev grsync xxd libglib2.0-dev libpixman-1-dev kmod jfsutils reiserfsprogs xfsprogs squashfs-tools pcmciautils quota ppp libtinfo-dev libtinfo5 libncurses5-dev libncursesw5 libstdc++6 gcc-arm-none-eabi vim ssh locales libxinerama-dev libxcursor-dev libxrandr-dev libxi-dev
```

如果在安装过程出现错误，导致安装中断了，可以单独安装某个依赖包即可。在未来更新的源码中可能还会用到其他的依赖工具，到时候根据实际需要安装即可。

**切换 python 版本**

Ubuntu20 已自带 python3.8.5 ，执行以下命令切换 python3

```shell
sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 150
```

安装 pip3 ，输入以下命令：

```shell
sudo apt-get -y update

sudo apt-get install python3-pip
```

**修改默认 shell**

> ‌**‌[Bash](https://www.baidu.com/s?rsv_idx=1&wd=Bash&fenlei=256&usm=1&ie=utf-8&rsv_pq=99c8b77500089329&oq=bash和dash的区别&rsv_t=9be5oHtbcCPgYN7uXkXq2AV42DrHBtyFpxOfPpzq3VE39Xsx033CsRECp5g&sa=re_dqa_generate)和‌[Dash](https://www.baidu.com/s?rsv_idx=1&wd=Dash&fenlei=256&usm=1&ie=utf-8&rsv_pq=99c8b77500089329&oq=bash和dash的区别&rsv_t=610fAdQq10O0tKUidU0jRLP3dsxBxEoqmSeqwxvDYbUKBg%2FxBQP%2Fuotoo38&sa=re_dqa_generate)的主要区别在于功能、性能、以及它们在系统中的角色。**‌‌12
>
> - ‌**功能与性能**‌：
>   - Bash（‌[Bourne Again Shell](https://www.baidu.com/s?rsv_idx=1&wd=Bourne Again Shell&fenlei=256&usm=1&ie=utf-8&rsv_pq=99c8b77500089329&oq=bash和dash的区别&rsv_t=f874NvreK8773bmPDLVtA7LEegdXKWNC8H64blI1NHmt0f1hpPX8WJrC%2Bms&sa=re_dqa_generate)）支持更多的高级特性，如命令历史记录、命令补全、作业控制等，这使得它更适合复杂的脚本编写和交互式使用。Bash的语法和功能相对复杂，但同时也更灵活和强大。
>   - Dash（‌[Debian Almquist Shell](https://www.baidu.com/s?rsv_idx=1&wd=Debian Almquist Shell&fenlei=256&usm=1&ie=utf-8&rsv_pq=99c8b77500089329&oq=bash和dash的区别&rsv_t=2be9VCbkIc7pyQ4smo4YsF7aJqOei4xuQy7mt1pB2rMpili43wszas3uQOs&sa=re_dqa_generate)）则设计得更注重轻量化和速度。它的代码更精简，执行速度比Bash快，需要的软件库也较少。Dash的功能集较小，不支持一些Bash的高级特性，如命令补全和作业控制。
> - ‌**系统中的角色**‌：
>   - 在Debian系统中，Dash通常用作/bin/sh（而不是Bash），因为Dash更加符合POSIX标准，并且启动速度更快。
>   - Bash是大多数‌[Linux](https://www.baidu.com/s?rsv_idx=1&wd=Linux&fenlei=256&usm=1&ie=utf-8&rsv_pq=99c8b77500089329&oq=bash和dash的区别&rsv_t=00498TnVfwl8kgPYGPndK2PwP4v2UOLUa1gyJfozjaitw4tO%2BDAe0iDbZgM&sa=re_dqa_generate)发行版及macOS系统的默认shell，提供了更多的功能和选项，适合各种场景，特别是需要交互性和复杂脚本编写的任务。
>
> 综上所述，Bash和Dash的区别主要体现在功能、性能以及它们在系统中的角色上。Bash因其丰富的功能和选项，更适合复杂的脚本编写和交互式使用，而Dash则因其轻量级和高速特性，更适合需要快速执行脚本的环境。

输入以下命令可以查看 Ubuntu 默认使用的 shell ，默认情况下使用的是 dash

```shell
ls -l /bin/sh
```

编译开发 OpenHarmony 需要使用 bash ，打开终端输入以下命令：

```shell
sudo dpkg-reconfigure dash
```

然后选择 No ，将 Ubuntu shell 由 dash 修改为 bash

![image-20240722132101912](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722132101912.png)

再次输入“ls -l /bin/sh”命令，如下图所示：

![image-20240722132120016](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722132120016.png)

现在可以确认shell已经改为了bash。

**编译 OpenHarmony**

进入 OpenHarmony 目录下，执行 prebuilts_download.sh 脚本，安装编译器及二进制工具， 首次编译的时候执行即可，不需要每次都执行。

```shell
bash build/prebuilts_download.sh
```

安装过程中会提示如下所示问题

![image-20240722132220801](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722132220801.png)

输入以下命令升级 pip

```shell
prebuilts/python/linux-x86/3.10.2/bin/python3.10 -m pip install --upgrade
```

进入源码根目录，执行以下命令进行编译

```shell
./build.sh --product-name rk3568 --ccache
```

编译完成后，log 会提示编译成功。编译成功后会在 out/rk3568/packages/phone/images/生成镜像文件。

#### OpenHarmony 镜像简介

OpeHarmony 编译出来的镜像文件具有不同的作用和功能。下面是对每个镜像文件的简要 说明。

![image-20240722132411228](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722132411228.png)

### 搭建windows开发环境

DevEco Device Tool 采用 Windows+Ubuntu 混合开发环境，在 Windows 上主要进行代码开发、 代码调试、镜像烧录等操作，在 Ubuntu 环境实现源码编译。其具有以下特点：

> \- 支持 Openharmony 的组件按需定制
>
> \- 支持代码编辑 编译 烧录和调试
>
> \- 支持 C 和 C++语言
>
> \- 以插件的形式部署在 Visual Studio Code 上

这个工具具体来说有这样 4 个主要功能，这个工具打开之后是这样的界面。DevEco Device Tool 工具主要分为 4 个功能区域。

![image-20240722132604809](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722132604809.png)

l 基本功能区：DevEco Device Tool 菜单栏，提供基本的工程创建，源码导入，工程配置等功能。

l 开发板任务区：在工程界面，提供开发板相关操作任务，如源码的编译，镜像的烧录，Monitor

串口工具等。

l 代码编辑器：提供代码的查看，编写和调试等开发功能。 

l 输出控制区：提供日志打印，调试指令输入， 命令行指令输入等。

在嵌入式开发中，很多开发者习惯在windows 上进行代码的编辑，比如使用vscode 进行 Openharmony 代码的开发，但是大部分开发板的源码还不支持在windows 环境下编译，所以 使用 Ubuntu 的编译环境对源码进行编译。但是使用 Ubuntu 进行南向开发，操作过程麻烦， 基于这样的设备开发场景，我们可以搭建一套 Windows+Ubuntu 混合开发的环境，其中使用 DevEco Tool 可视化界面进行相关操作，通过远程连接的方式对接 Ubuntu 下的 DevEco Device Tool（ubuntu 下可以不安装 Vscode），然后对 Ubuntu 下的源码进行开发，编译，烧录等操作

![image-20240722132641211](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722132641211.png)

1. 下载安装 DevEco Device Tool 最新 Windows 版本软件包。打开链接

https://device.harmonyos.com/cn/develop/ide#download

注意！！！Windows 系统和 Ubuntu 系统要满足以下要求：

![image-20240722132727357](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722132727357.png)

Windows 和 Ubuntu 上安装的 DevEco Device Tool 要为最新版本，并且版本号需要相同。我们 将 Windows 和 Linux 版本都下载下来。然后将 Windows 版本拷贝到 D 盘。

2. 解压 DevEco Device Tool 压缩包，双击安装包程序，单击下一步进行安装。

3. 请详细阅读以下界面的用户协议和隐私声明，需勾选“我接受许可证协议中的条款”后，才 能继续下一步的安装。

4. 设置 DevEco Device Tool 的安装路径，请注意安装路径不能包含中文字符，不建议安装到 C盘目录，单击下一步。

5. 其中，安装：按照默认路径及参数直接安装。自定义安装：安装前可以自行修改安装路径及其他设置 参数。安装完成后，各软件状态显示为 OK。

6. 依赖的工具安装完成后，单击安装，开始安装 DevEco Device Tool。
7. 继续等待 DevEco Device Tool 安装向导自动安装 DevEco Device Tool 插件，直至安装完成，单 击完成，关闭 DevEco Device Tool 安装向导。
8. 打开 Visual Studio Code ，进入 DevEco Device Tool 工具界面。至此，DevEco Device Tool Windows 开发环境安装完成。

### 搭建 Ubuntu 环境

**系统要求:**

l Ubuntu 系统要求：Ubuntu18.04~21.10 版本。推荐使用 20.04 版本，内存 16GB 及以上， 硬盘 100GB 及以上。

l Ubuntu 系统的用户名不能包含中文字符。

l 建议 Ubuntu 和 Windows 系统上安装的 DevEco Device Tool 为最新版本，且版本号需相同。

**操作步骤:**

1. 将 Ubuntu Shell 环境修改为 bash 。执行如下命令，确认输出结果为 bash。

2. 如果输出结果不是 bash ，将 Ubuntu shell 修改为 bash 。打开终端工具，执行如下命令，输 入密码，然后选择 No ，将 Ubuntu shell 由 dash 修改为 bash。

```shell
sudo dpkg-reconfigure dash
```

3. 下载 [DevEco Device Tool](https://gitee.com/link?target=https://device.harmonyos.com/cn/ide%23download)最新 Linux 版本软件包。

4. 解压 DevEco Device Tool 软件包并对解压后的文件夹进行赋权。进入 DevEco Device Tool 软件 包目录，执行如下命令解压软件包，其中 devicetool-linux-tool-{Version}.zip 为软件包名称，请 根据实际进行修改。

5. 进 入 解 压 后 的 文 件 夹 ， 执 行 如 下 命 令 ， 赋 予 安 装 文 件 可 执 行 权 限 ， 其 中 devicetool-linux-tool-{Version}.sh 请根据实际进行修改。

   ```shell
   chmod u+x devicetool-linux-tool-{Version}.sh
   ```

6. 执行如下命令，安装 DevEco Device Tool ，其中 devicetool-linux-tool-{Version}.sh 请根据实际 进行修改。

   ```shell
   sudo ./devicetool-linux-tool-{Version}.sh
   ```

7. 在用户协议和隐私声明签署界面，请详细阅读用户协议和隐私声明，需签署同意用户协议 和隐私声明才能进行下一步的安装，可通过键盘的上下按键进行选择。

8. 安装完成后，当界面输出“DevEco Device Tool successfully installed.”时，表示 DevEco Device Tool 安装成功。

**配置远程访问环境**

在搭建了 Windows 和 Ubuntu 开发环境后，需要通过下述设置，使得 Windows 可以远程 访问 Ubuntu ，为后续烧录文件的传输做好准备。

在 Ubuntu 系统中，打开终端工具，执行如下命令安装 SSH 服务。

```shell
sudo apt-get install openssh-server
```

执行如下命令，启动 SSH 服务。

```shell
sudo systemctl start ssh
```

**远程连接 Ubuntu 环境**

打开 Windows 系统的 Visual Studio Code ，在 SSH TARGETS 下，单击+。

![image-20240722133347803](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722133347803.png)

在弹出的 SSH 连接命令输入框中输入“ssh username@ip_address”，其中 ip_address 为要连 接的远程计算机的 IP 地址，username 为登录远程计算机的帐号。

![image-20240722133355546](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722133355546.png)

在弹出的输入框中，选择 SSH configuration 文件，选择默认的第一选项即可。

![image-20240722133402799](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722133402799.png)

在 SSH TARGETS 中，找到远程计算机，打开远程计算机。

![image-20240722133426007](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722133426007.png)

在弹出的输入框中，选择 Linux，然后在选择 Continue，然后输入登录远程计算机的密码，连接远程计算机。

#### 免密连接

在 Windows 系统远程访问 Ubuntu 过程中，需要频繁的输入密码进行连接，为解决该问题，您可以使用 SSH 公钥来进行设置，设置方法请参考注册远程访问 Ubuntu 环境的公钥。

打开 Windows 系统下的 Visual Studio Code，在插件市场的搜索输入框中输入“remote-ssh”。

点击 Remote-SSH 的 Install，安装 Remote-SSH。安装成功后，在 INSTALLED 下可以看到已安装 Remote-SSH。

完成上述操作之后，就可以通过 Windows 远程连接 Ubuntu 环境进行开发了，但是在每次打开 vscode 时，总是需要重新输入密码，比较麻烦，可以通过环境公钥设置来解决。

1 在 Windows 下打开 git bash 命令行窗口，并输入以下命令生成 SSH 公钥

```shell
ssh-keygen -t rsa

ssh-copy-id -i ~/.ssh/id_rsa.pub username@ip
```

注意！这里的 username 是远程 ubuntu 的登录账号，ip 为远程 Ubuntu 的 IP 地址。 执行指令 ssh-keygen 之后，会有几个需要确认的地方，这里直接默认回车就行

执行 ssh-copy-id 后，输入登录密码即可。

2  配置 SSH key

打开 VSCode ，并在“远程资源管理器 ”中设置连接的 config 文件。 在 config 文件中添加 SSK Key 文件信息:

```
C:\Users\Administrator/.ssh/id_rsa
```

这个文件路径，在安装 ssh-keygen 是有打印。

此时再打开远程连接，发现已经不需要输入密码了。

### OpenHarmony 源码目录

#### tree 命令

输入以下命令安装tree 命令

```shell
sudo apt-get install tree
```

tree 是一个在命令行界面下用于以树状结构显示目录和文件的实用工具。它可以帮助您 以清晰的方式查看文件系统的层次结构。以下是 tree 命令的一些简单用法示例：

1. 显示当前目录的树状结构：

   ```shell
   tree
   ```

2. 显示指定目录的树状结构：

   ```shell
   tree /path/to/directory
   ```

3. 显示完整目录树，包括隐藏文件和目录：

   ```shell
   tree -a
   //使用 -a 选项，tree 将显示所有文件和目录，包括以点开头的隐藏文件和目录。
   ```

4. 限制显示的深度级别：

   ```shell
   tree -L <depth>
   //将 <depth>替换为要显示的深度级别。例如，tree -L 2 将仅显示当前目录及其直接子目录 的树状结构。
   ```

5. 以图形符号显示树状结构：

   ```shell
   tree -F
   使用 -F 选项，tree 将在文件名后面添加一个符号，以指示文件类型（斜杠表示目录，星号 表示可执行文件等）。
   ```

6. 只显示目录：

   ```shell
   tree -d
   ```

7. 对需要显示的文件进行过滤

   ```shell
   tree -P ‘*L1*’ --prune
   只显示包含“L1 ”字符串的文件，并将过滤后的空目录也同时过滤掉
   ```

#### 总览一二级目录

可以输入 tree -L 2 命令总览 OpenHarmony 源码目录

![image-20240722134311017](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722134311017.png)

#### applications 

放置内置的示例应用程序。

在 standard 文件夹中，放置标准系统的示例应用程序，包括 launcher,settings,systemui 等。

sample/camera 中放小型系统的示例应用程序，包括 launcher,settings,camera。

#### arkcompiler

**ets_frontend**: ets_frontend 组件是方舟运行时子系统的前端工具，结合 ace-ets2bundle 组件， 支持将 ets 文件转换为方舟字节码文件。

**ets_runtime**:方舟 eTS 运行时是 OpenHarmony 上默认的 ArkTS 语言运行时。支持 Ecmascript 规 范定义的标准库和高效 container 容器库，提供完备的 C++交互 ArkTS NAPI 和各种高性能的垃 圾回收器，驱动着万物互联时代的 OpenHarmony 应用程序。

**runtime_core：**方舟编译器运行时公共组件（ArkCompiler Runtime Core）是 OpenHarmony 中 语言运行时的公共组件。主要由与语言无关的基础运行库组成，包含承载字节码以及执行字 节码所需要相关信息的 ArkCompiler File 文件组件、支持运行时调试的 Debugger Tooling 工具 组件、提供不同系统平台公共接口的 ArkCompiler Base 基础库组件、以及与语言无关的公共指 令集体系结构 ISA 等。

**toolchain：**方舟工具链（ArkCompiler Toolchain）为开发者提供了一套 OpenHarmony 应用程序 调试调优工具，其功能包括单步调试、断点调试、Watch 变量及表达式、CPU Profiler 和 Heap Profiler 等，并支持多实例和 Worker 调试。

#### base

![image-20240722134842706](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722134842706.png)

base 文件夹存放基础软件服务子系统集，和硬件服务子系统集，可根据需要进行裁剪。

account 在标准系统上，帐号子系统主要提供系统帐号生命周期管理，分布式帐号登录状态管 理和应用帐号添加删除等基础管理能力。

customization/config_policy 配置策略组件为各业务模块提供获取各配置层级的配置目录 或配置文件路径的接口。

customization/enterprise_device_management 企业设备管理组件 EDM(Enterprise Device Management)给企业 MDM（Mobile Device Management）应用开发者提供管理应用开发框架， 设定管理模式以及提供企业设备管理功能能力集。为企业环境下的应用提供系统级别的管理 功能 API。

global：全球化子系统，提供多语言支持，多文化的资源管理，以及国际化能力

hiviewdfx：DFX 框架子系统，提供日志和系统事件的打印，输出功能

**inputmethod**：inputmethod/imf 输入法框架，主要作用是拉通应用和输入法，保证应用可以 通过输入法进行文本输入

**iothardware**：iothardware/peripheral IOT（The Internet of Things）硬件设备操作的 接口。本模块提供设备操作接口有：FLASH,GPIO,I2C,PWM,UART,WATCHDOG 等

**location**：位置服务组件

**msdp**:msdp/device_status MSDP 设备状态感知框架能够识别出目前设备的状态并传递给订 阅者，整个框架是基于 MSDP 算法库和系统SensorHDI 组件组成的

**notification**:

**notification/common_****event_service** OpenHarmony 通过 CES（Common Event Service，公 共事件服务）为应用程序提供订阅、发布、退订公共事件的能力。

**notification/distributed_notification_service** OpenHarmony 通 过 ANS （ Advanced Notification Service，通知系统服务）对通知类型的消息进行管理，支持多种通知类型， 包括文本，长文本，多文本，图片，社交，媒体等。所有系统服务以及应用都可以通过通知 接口发送通知消息，用户可以通过 SystemUI 查看所有通知消息。

**notification/eventhandler** EventHandler 提供了 OpenHarmony 线程间通信的基本能力，可 以通过 EventRunner 创建新线程，将耗时的操作抛到新线程上执行，从而实现在不阻塞原来 的线程的基础上合理地处理耗时任务

**power**:电源管理服务子系统，提供系统各模块的电源状态管理等接口

**print/print_fwk**:打印框架服务（Distributed Print Service，DPS） 支持三方应用创建打印任务，拉起后台打印任务管理，管理打印扩展和打印任务。

提供打印扩展框架，实现三方打印扩展的接入，管理打印任务与打印机之间的关系，启动、 暂停/恢复、取消打印任务，查询打印进度等。

打印框架服务覆盖范围包含：打印管理、打印管理服务和打印扩展管理

**request/request**：Request 服务向三方应用提供文件下载/上传能力，以支撑应用开发者方 便、高效地使用下载/上传业务的功能。

**security：**安全子系统，提供系统安全，数据安全，应用安全等能力

**sensors：**传感器服务子系统，提供轻量级传感器服务基础框架

**startup**：启动恢复子系统，负责在内核启动之后，到应用启动之前的系统关键进程和服务的 启动过程，并提供系统属性查询，修改及设备恢复出厂设置的功能。

**telephony**：电话服务子系统，提供了一系列的API用于获取无线蜂窝网络和SIM 卡相关的一 些信息。应用可以通过调用API来获取当前注册网络名称、网络服务状态、信号强度以及SIM 卡的相关信息。

**theme\screenlock_mgr** 锁屏管理服务是 OpenHarmony 中系统服务，为锁屏应用提供注册亮屏、 灭屏、开启屏幕、结束休眠、退出动画、请求解锁结果监听，并提供回调结果给锁屏应用。 锁屏管理服务向三方应用提供请求解锁、查询锁屏状态、查询是否设置锁屏密码的能力。

**theme\wallpaper_mgr** 该仓主要为系统提供壁纸管理服务能力，支持系统显示、设置、切换 壁纸等功能。

**time\time_service：**在整个 OpenHarmony 架构中提供管理系统时间时区和定时的能力，支持 设置获取时间、 日期、时区和系统定时器功能。

**update**：OpenHarmony 升级子系统用来支持 OpenHarmony 设备的 OTA(Over The Air)升级。

**usb/usb_manager**：Usb 设备作为 host 设备连接 device 设备进行数据传输。

**/useriam/face_auth**：人脸认证 （faceauth）支持用户人脸的录入，删除和认证功能。

**useriam/pin_auth：**口令认证（pinauth）模块支持用户口令的设置，删除和认证功能。与用 户 IAM 子系统基础框架配合，也可以支持用户口令修改的功能。

**useriam/user_auth_framework：**统一用户认证框架 

**weh/ohos_nweb** 是 OpenHarmony webview 组件的 Native 引擎，基于 Chromium 和 CEF 构建。

#### build 

编译构建子系统提供了一个基于 Gn 和 ninja 的编译构建框架。

![image-20240722134918822](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722134918822.png)

#### commonlibrary

![image-20240722134935586](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722134935586.png)

**c_utils**：C++公共基础类库为标准系统提供了一些常用的 C++开发工具类

**ets_utils：**ets_utils 组件共提供四个子模块，分别是：js_api_module、js_util_module、 js_sys_module 和 js_worker_module 

**memory_utils**：内存基础库部件位于公共基础库子系统中，为上层业务提供对应的操作内存 的系统库，保证上层业务的稳定性。
**utils_lite**： 轻量级公共基础库存放 OpenHarmony 通用的基础组件 。这些基础组件可被 OpenHarmony 各业务子系统及上层应用所使用

#### developtools

常用开发工具集合

developtools\ace_ets2bundle 提供声明式范式的语法编译转换，语法验证，丰富友好的语法报 错提示能力。

#### docs

此仓库存放 OpenHarmony 网站提供的设备开发、应用开发对应的开发者文档。

#### drivers

OpenHarmony 驱动子系统采用 C 面向对象编程模型构建，通过平台解耦、内核解耦，兼 容不同内核，提供了归一化的驱动平台底座，旨在为开发者提供更精准、更高效的开发环境， 力求做到一次开发，多系统部署。

**hdf_core** 该仓主要存放 OpenHarmony 驱动子系统核心源码信息（包括驱动框架、配置管理、 配置解析、驱动通用框架模型、硬件通用平台能力接口等），旨在为开发者提供更精准、更 高效的开发环境，力求做到一次开发，多系统部署。

**interface** 该仓库用于管理各模块 HDI(Hardware Device Interface)接口定义，接口定义使 用 IDL 语言描述并以 idl文件形式保存。

**liteos** 内核驱动是软件与硬件交互的桥梁，通过文件系统接口访问 OpenHarmony 内核的硬件 资源，是用户与内核之间、进程与进程之间通信的一种方式。每类驱动代表一种能力，用户 可以根据需求选择对应驱动，完成数据的传输

**peripheral** 此仓主要包含各外设器件驱动相关的 HDI（Hardware Driver Interface）接口、 HAL 实现、驱动模型及测试用例等，根据模块划分不同目录。

#### interface

interface/sdk-js

JS/TS API 公共仓，用来提交 API d.ts 声明文件以及 API 相关工具。

#### kernel

OpenHarmony 针对不同量级的系统，分别使用了不同形态的内核，分别为 LiteOS 和 Linux。在 轻量系统、小型系统可以选用 LiteOS；在小型系统和标准系统上可以选用 Linux。

**linux:**不同版本的Linux 内核，以及不同芯片平台适配Linux 内核的相关配置，编译脚本等 等

**liteos_a:**OpenHarmony LiteOS-A 内核是基于 Huawei LiteOS 内核演进发展的新一代内核， HuaweiLiteOS 是面向 IoT 领域构建的轻量级物联网操作系统。在 IoT 产业高速发展的潮流中， OpenHarmony LiteOS-A 内核能够带给用户小体积、低功耗、高性能的体验以及统一开放的生态系统能力，新增了丰富的内核机制、更加全面的 POSIX 标准接口以及统一驱动框架 HDF （OpenHarmony Driver Foundation）等，为设备厂商提供了更统一的接入方式，为 OpenHarmony 的应用开发者提供了更友好的开发体验

**liteos_m:**OpenHarmony LiteOS-M 内核是面向 IoT 领域构建的轻量级物联网操作系统内核， 具有小体积、低功耗、高性能的特点，其代码结构简单，主要包括内核最小功能集、内核抽 象层、可选组件以及工程目录等，分为硬件相关层以及硬件无关层，硬件相关层提供统一的 HAL（Hardware Abstraction Layer）接口，提升硬件易适配性，不同编译工具链和芯片架构 的组合分类，满足 AIoT 类型丰富的硬件和编译工具链的拓展

**uniproton:**UniProton 主要目的在于为上层业务软件提供一个统一的操作系统平台，屏蔽底 层硬件差异，并提供强大的调试功能。使得业务软件可在不同的硬件平台之间快速移植，方 便产品芯片选型，降低硬件采购成本和软件维护成本。

### 整体移植方案

> 1. soc级别的移植
>
>    把操作系统的源码拿过来，适配不同的芯片。难度大
>
> 2. 开发板级的移植
>
>    芯片厂已经适配好了芯片和操作系统，但对于不同的外设，还要需要适配。难度比soc级别的移植要简单



![image-20240722135510405](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722135510405.png)

我 们 可 以 把 OpenHarmony  简 单 分 为 OpenHarmony=OpenHarmony  内 核 态 层 +OpenHarmony 用户态层。其中内核态层可以看到主要由内核本身（Linux kernel,liteOS）和一 些运行在内核态的一些特性组成，比如 HDF 。用户态层主要由系统服务层，框架层，应用层 组成。这里我们将这三层整体称为“OpenHarmony 用户态层”

为什么要这么区分呢？

因为我们现在考虑是的如何将 OpenHarmony 移植到三方芯片平台上，而 OpenHarmony 的用户态层整体来说和三方芯片平台的耦合度不高，移植较为方便。而内核态层中的内核本 身以及 HDF 驱动框架等和三方芯片平台的耦合度较高，是移植的重难点。我们先做这个区分， 就是为了先把聚光灯打到我们最需要关注的 OpenHarmony 内核态层上，开始分析和解题。注 意！ 在以后的移植过程中，只包括 Linux 内核的移植，不包含 liteOS 的移植。

接下来继续内核态层的分解。

OpenHarmony 内核态层= OpenHarmony Linux 内核+ OpenHarmony 内核态特性（可选特性 或者必选特性，如必选特性 HDF ，可选特性 HMDFS 等）

而 OpenHarmony Linux 内核= 标准 LTS Linux 内核 + 三方Soc 芯片平台代码+ OpenHarmony 内核态基础代码（支撑 OpenHarmony 用户态运行的最基础代码）

因此，OpenHarmony 内核态层 = 标准 LTS Linux 内核 + 三方 Soc 芯片平台代码+ OpenHarmony 内核态基础代码 + OpenHarmony 内核态特性。

![image-20240722135543207](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722135543207.png)

将前两项组合，OpenHarmony 内核态层 = 标准 LTS Linux 内核，其实就是一个三方 Linux 内核 的基础组成。从上面的推导可以看出，OpenHarmony 内核态层其实能够由俩种方法得到。

方法一 ： OpenHarmony 内核态层 = 三方 Linux 内核 + OpenHarmony 内核态基础代码+ OpenHarmony 内核态特性。也就是直接借助三方 Linux 内核，再加上基础 OpenHarmony 内核 态基础代码，以及 HDF 等 OpenHarmony 内核态特性。

方法二：OpenHarmony 内核态层 = OpenHarmony Linux 内核 + OpenHarmony 内核态特性。

| **方法** | 方法一基于原厂内核驱动移 植 OpenHarmony 内核修改 | 方法二基于 OpenHarmony 内 核移植原厂驱动                     |
| -------- | ------------------------------------------------ | ------------------------------------------------------------ |
| **质量** | 质量高，内核驱动稳定，经过 原厂的商用打磨        | 质量低，大量原厂驱动可能不 稳定，再加上一些原厂闭源驱 动是没有办法移植的。 |

#### RK3568 移植方案

当前方法二中 OpenHarmony 内核支持的三方芯片平台还不够丰富，我们要移植的芯片是 RK3568 ，所以默认是支持的。所以我们选用方法二来进行移植。

现在我们手里有俩套源码，一套是 OpenHarmony 源码，一套是三方厂家瑞芯微提供的源 码。采用方案一是基于 OpenHarmony 内核移植或重写原厂驱动。

移植步骤：

1  移植准备

搭建编译环境，获取源码，编译框架搭建

2 移植内核

移植芯片架构，移植芯片厂商 SDK ，添加内核子系统

3 移植子系统

移植启动子系统，移植文件子系统，添加安全子系统，添加通信子系统，添加外设驱动子 系统，配置其他子系统

4 移植验证

Openharmony 兼容性测试，厂商 SDK 功能性测试 更具体一点，拆分任务：

移 植 OpenHarmony 系 统 就 是 要 编 译 出 可 以 烧 录 到 iTOP-RK3568 开 发 板 上 可 以运 行 的 OpenHarmony 镜像。

可以烧录包括烧录工具的修改和烧录镜像的适配编译

可以运行包括整个开发板底板外设的南向设备开发，迅为 3568 底板外设，如下所示

![image-20240722135643944](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722135643944.png)

#### 编译框架基本概念

OpenHarmony 的编译框架是基于模块化的，从大到小依次划分为产品，子系统集（领域）， 子系统，部件，模块，特性。这种模块化的树状编译框架，非常方便根据目标产品硬件资源 的大小进行灵活的裁剪，从而实现“统一 OS ，弹性部署 ”的目标。

**产品**

产品是基于解决方案为开发板的完整产品，主要包含产品对 OS 的适配、部件拼装 配置、启动配置和文件系统配置等。build.sh 编译的时候通过–product-name 编译选项指 定；hb 编译的时候通过 hb set 进行设置。

**子系统集**

OpenHarmony 技术架构中有四大子系统集：“系统基本能力子系统集 ”、“基 础软件服务子系统集 ”、“增强软件服务子系统集 ”、“硬件服务子系统集 ” 。四大子 系统不会直接出现在编译选项或者参数中，而是有对应的一级源代码文件夹：“系统基本 能力子系统集 ”对应源码 foundation 文件夹；“基础软件服务子系统集 ”和“硬件服务子 系统集 ”对应源码 base 文件夹；“增强软件服务子系统集 ”对应源码 domains 文件夹。

**子系统**

子系统是一个逻辑概念，它具体由对应的部件构成。在多设备部署场景下，支持 根据实际需求裁剪某些非必要的子系统或部件。

**部件**

对子系统的进一步拆分，可复用的软件单元，它包含源码、配置文件、资源文件和 编译脚本；能独立构建，以二进制方式集成，具备独立验证能力的二进制单元。

**模块**

模块就是编译子系统的一个编译目标，部件也可以是编译目标。

**特性**

特性是部件用于体现不同产品之间的差异。

**各部分间的关系**

一个产品（product） 可以包含 n 个子系统（subsystem）, 一个子系统可以包含 n 个部件 (component),一个部件只能属于一个子系统。一个部件可以包含 n 个模块(module) ，一个模块 只能属于一个部件。

不同产品中的相同部件可以通过特性（feature）进行差异化定义 ,子系统集（domain）在源 码一级根目录有体现。

![image-20240722135930026](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722135930026.png)

#### 内核编译脚本

linux 内核编译脚本的是放在 device/board/hihope/rk3568/kernel 目录下的build_kernel.sh文件，

我们来分析下这个脚本

```
#!/bin/bash
# Copyright (c) 2021-2023 HiHope Open Source Organization . # Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License. # You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and
# limitations under the License. set -e
# 将当前目录切换到第一个参数指定的目录
pushd ${1}
# 设置根目录路径
ROOT_DIR=${5}
# 设置产品路径
export PRODUCT_PATH=${4}
# 设置设备公司名称
export DEVICE_COMPANY=${6}
# 设置设备名称
export DEVICE_NAME=${7}
# 设置产品公司名称
export PRODUCT_COMPANY=${8}
# 内核形式
KERNEL_FORM=${9}
# 内核产品
KERNEL_PROD=${10}
# 是否启用-LTO-O0
ENABLE_LTO_O0=${11}
# 内核源码临时路径
KERNEL_SRC_TMP_PATH=${ROOT_DIR}/out/kernel/src_tmp/linux-5.10
# 内核目标临时路径
KERNEL_OBJ_TMP_PATH=${ROOT_DIR}/out/kernel/OBJ/linux-5.10
# 内核源码路径
KERNEL_SOURCE=${ROOT_DIR}/kernel/linux/linux-5.10
# 内核补丁路径
KERNEL_PATCH_PATH=${ROOT_DIR}/kernel/linux/patches/linux-5.10
# 内核补丁文件
KERNEL_PATCH=${ROOT_DIR}/kernel/linux/patches/linux-5.10/rk3568_patch/kernel.patch
# 构建脚本路径
BUILD_SCRIPT_PATH=${3}
# newip 补丁文件
NEWIP_PATCH_FILE=${ROOT_DIR}/kernel/linux/common_modules/newip/apply_newip.sh
# tzdriver 等等各种补丁文件
TZDRIVER_PATCH_FILE=${ROOT_DIR}/kernel/linux/common_modules/tzdriver/apply_tzdriver.sh
...
```

### 鸿蒙系统开发

#### 修改调试串口波特率

修改OpenHarmony-v4.1-Release/OpenHarmony/linux-5.10/arch/arm64/boot/dts/rockchip/rk3568-linux.dtsi 文件中的 rockchip,baudrate 的值改为 115200。

![image-20240722140817405](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722140817405.png)

在修改完成后，请重新编译 OpenHarmony 源码，并将镜像烧写。请注意，在打开串口终 端时，将串口波特率设置为 115200 。随后，串口终端将显示大量信息。由于底板上的其他外 设尚未配置，可能会有许多错误打印，这可能会干扰输入。为了解决这个问题，我们可以通 过输入命令“dmesg -n 1 ”来设置打印日志的等级。

#### 修改产品信息

系统属性定义在源码 /base/startup/init/services/etc/param/ohos.para 配置文件中，开发板 配置在/system/etc/param/ohos.para 文件中。

> 下面是对每个键值对的详细注释：
>
> const.actionable_compatible_property.enabled=false
>
> 该常量用于指示是否启用可操作兼容属性。其值为`false`，表示禁用。
>
> const.postinstall.fstab.prefix=/system
>
> 该常量定义了后安装阶段的 fstab 前缀路径。在该示例中，路径设置为`/system`。
>
> const.secure=0
>
> 此常量表示系统的安全性级别。值为`0`，表示安全性未启用。
>
> security.perf_harden=1
>
> 该键用于控制性能增强的安全设置。值为`1`，表示性能增强已启用。
>
> const.allow.mock.location=0
>
> 此常量表示是否允许模拟位置信息。值为`0`，表示禁止模拟位置信息。
>
> const.debuggable=1
>
> 该常量表示应用程序是否可以进行调试。值为`1`，表示应用程序是可调试的。
>
> const.build.characteristics=default
>
> 此常量定义了构建的特性。在该示例中，特性设置为`default`。
>
> const.product.model=北京迅为电子开发板
>
> 该常量表示产品的型号。在该示例中，型号设置为"北京迅为电子开发板"。
>
> const.product.name="TOPEET" 
>
> 该常量表示产品的名称。在该示例中，名称设置为"TOPEET"。
>
> const.sandbox=enable
>
> 此常量表示是否启用沙箱。在该示例中，沙箱已启用。
>
> const.product.devicetype=default
>
> 该常量表示产品的设备类型。在该示例中，设备类型设置为"default"。
>
> const.software.model=default
>
> 此常量定义了软件的型号。在该示例中，型号设置为"default"。
>
> const.product.manufacturer=TOPEET
>
> 该常量表示产品的制造商。在该示例中，制造商设置为"TOPEET"。
>
> const.product.brand=TOPEET
>
> 该常量表示产品的品牌。在该示例中，品牌设置为"TOPEET"。
>
> const.build.product=TOPEET
>
> 该常量表示构建的产品。在该示例中，产品设置为"TOPEET"。
>
> const.product.hardwareversion=default
>
> 该常量表示产品的硬件版本。在该示例中，硬件版本设置为"default"。
>
> const.product.bootloader.version=bootloader
>
> 该常量表示产品的引导加载程序版本。在该示例中，引导加载程序版本设置为"bootloader"。
>
> const.product.cpu.abilist=default
>
> 该常量表示产品的 CPU 架构列表。在该示例中，CPU 架构列表设置为"default"。
>
> const.product.software.version=OpenHarmony 4.0.10.18
>
> 该常量表示产品的软件版本。在该示例中，软件版本设置为"OpenHarmony 4.0.10.18"。
>
> const.product.incremental.version=default
>
> 该常量表示产品的增量版本。在该示例中，增量版本设置为"default"。
>
> const.product.firstapiversion=1
>
> 该常量表示产品的首个 API 版本。在该示例中，首个 API 版本设置为"1"。
>
> const.product.build.type=default
>
> 该常量表示产品的构建类型。在该示例中，构建类型设置为"default"。
>
> const.product.build.user=default
>
> 该常量表示产品构建的用户。在该示例中，构建用户设置为"default"。
>
> const.product.build.host=default
>
> 该常量表示产品构建的主机。在该示例中，构建主机设置为"default"。
>
> const.product.build.date=default
>
> 该常量表示产品构建的日期。在该示例中，构建日期设置为"default"。
>
> const.product.hardwareprofile=default
>
> 该常量表示产品的硬件配置文件。在该示例中，硬件配置文件设置为"default"。
>
> const.ohos.buildroothash=default
>
> 该常量表示获取当前版本的哈希值。在该示例中，构建根哈希值设置为"default"。

在源码中直接修改 /base/startup/init/services/etc/param/ohos.para 文件 ，然后编译烧录固件即可。如果想要临时修改的话，可以使用 HDC 工具进行操作，具体步骤如下所示：

> \# 将 ohos.para 文件从开发板提取至 windows 电脑
>
> hdc file recv ./system/etc/param/ohos.para C:\Users\Admin\Desktop
>
> \# 将系统改为可读写
>
> hdc shell mount -o remount,rw /
>
> \# 修改 ohos.para 后，将其传输回开发板
>
> hdc file send C:\Users\Admin\Desktop\ohos.para /system/etc/param/
>
> \# 重启系统即可
>
> hdc shell reboot

#### 修改开机 logo

替换 OpenHarmony 源码 device/board/hihope/rk3568/kernel 目录下的 logo 文件。

注意事项：图片的分辨率需要和设备匹配

然后修改 build_kernel.sh，添加如下图所示的内容。

![image-20240722141232482](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722141232482.png)

修改完成之后，删除 out 目录，重新编译源码，然后重新烧写编译好的镜像。

#### 修改开机动画

graphic 图形子系统包含了开机动画模块，开机动画模块在源码foundation/graphic/graphic_2d/frameworks/bootanimation 目录下，开机动画模块 bootanimation

源码结构如下所示：

![image-20240722141313471](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240722141313471.png)

 bootpic.zip 包括了开机动画的所有图片帧和 json 播放配置文件，在 3.2 版本中通过该方式实现，在 4.1release 版本中，仅仅替换 bootvideo.mp4 就可以了。

 bootsound.wav 是开机音效

 include 下是开机动画模块的头文件

 src 下是开机动画的源文件

直接替换开机动画

foundation/graphic/graphic_2d/frameworks/bootanimation/data/bootvideo.mp4 即可。

修改完成之后，删除 out 目录，重新编译源码，然后重新烧写编译好的镜像。