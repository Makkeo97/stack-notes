# 注册字符设备

## 字符设备初始化

字符设备初始化所用到的函数为 cdev_init(...),在对该函数讲解之前，首先对 cdev 结构体进行介绍。

Linux 内核中将字符设备抽象成一个具体的数据结构 (struct cdev), 我们可以理解为字符设备对象，cdev 记录了字符设备号、内核对象、文件操作 file_operations 结构体（设备的打开、读写、关闭等操作接口）等信息，struct cdev 结构体定义在“内核源码/include/linux/cdev.h”文件中（在编写驱动程序的时候要加入该文件的引用），

```c
struct cdev {
  struct kobject kobj; //内嵌的内核对象. 
  struct module *owner; //该字符设备所在的内核模块的对象指针. 
  const struct 	file_operations *ops; //该结构描述了字符设备所能实现的方法，是极为关键的一个结构体.
  struct list_head list; //用来将已经向内核注册的所有字符设备形成链表. 
  dev_t dev; //字符设备的设备号，由主设备号和次设备号构成. 
  unsigned int count; //隶属于同一主设备号的次设备号的个数. 
};
```

关于该结构体参数的注释在上图已经添加，设备初始化所用到的函数为 cdev_init(),该函数同样在“内核源码/include/linux/cdev.h”文件中所引用如下

```c
void cdev_init(struct cdev *, const struct file_operations *);
```

该函数的详细内容在“内核源码/fs/char_dev.c”文件中定义.

```c
void cdev_init(struct cdev *cdev, const struct file_operations *fops)
{
	memset(cdev, 0, sizeof *cdev);//将整个结构体清零；
	INIT_LIST_HEAD(&cdev->list);//初始化 list 成员使其指向自身；
	kobject_init(&cdev->kobj, &ktype_cdev_default);//初始化 kobj 成员；
	cdev->ops = fops;//初始化 ops 成员，建立 cdev 和 file_operations 之间的连接
}
```

> **函数作用：**
>
> 初始化传入的 cdev 类型的结构体，并与自定义的 file_operations * 类型的结构体进行链接。
>
> **参数含义：**
>
> cdev: 要传入的 cdev 类型结构体，为要初始化的字符设备。
>
> fops：要传入的 file_operations * 类型结构体，关于 file_operations 结构体的相关的知识会在下一章节进行讲解。
>
> **函数返回值：**无返回值。

## 字符设备注册

字符设备添加所用到的函数为 cdev_add()，该函数在“内核源码/include/linux/cdev.h”文

件中所引用.

```c
int cdev_add(struct cdev *, dev_t, unsigned);
```

> **函数原型：**
>
> int cdev_add(struct cdev *p, dev_t dev, unsigned count)
>
> **函数作用：**
>
> 该函数向内核注册一个 struct cdev 结构体
>
> **参数含义：**
>
> (1)第一个参数为要添加的 struct cdev 类型的结构体
>
> (2)第二个参数为申请的字符设备号
>
> (3)第三个参数为和该设备关联的设备编号的数量。
>
> 这两个参数直接赋值给 struct cdev 的 dev 成员和 count 成员。
>
> **函数返回值：**添加成功返回 0，添加失败返回负数。

**字符设备的注销：**

字符设备删除所用到的函数为 cdev_del()，该函数同样在“内核源码/include/linux/cdev.h”文件中所引用.

```c
void cdev_del(struct cdev *);
```

> **函数原型：**
>
> void cdev_del(struct cdev *p)
>
> **函数作用：**
>
> 该函数会向内核删除一个 struct cdev 类型结构体
>
> **参数含义：**
>
> 该函数只有一个参数，为要删除的 struct cdev 类型的结构体

实现代码

```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/kdev_t.h>
#include <linux/cdev.h>

static dev_t dev_num;//定义dev_t类型（32位大小）的变量dev_num,用来存放设备号
static struct cdev cdev_test;//定义cdev结构体类型的变量cdev_test
static struct file_operations cdev_test_ops = {
	.owner=THIS_MODULE,//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块
};//定义file_operations结构体类型的变量cdev_test_ops

static int __init module_cdev_init(void)//驱动入口函数
{
    int ret;//定义int类型变量ret，进行函数返回值判断
    int major,minor;//定义int类型的主设备号major和次设备号minor
    ret = alloc_chrdev_region(&dev_num,0,1,"chrdev_name");//自动获取设备号，设备名为chrdev_name
    if (ret < 0){
        printk("alloc_chrdev_region is error\n");
    }
    printk("alloc_register_region is ok\n");
    major = MAJOR(dev_num);//使用MAJOR()函数获取主设备号
    minor = MINOR(dev_num);//使用MINOR()函数获取次设备号
    printk("major is %d\n",major);
    printk("minor is %d\n",minor);          	
    cdev_init(&cdev_test,&cdev_test_ops);//使用cdev_init()函数初始化cdev_test结构体，并链接到cdev_test_ops结构体
	cdev_test.owner = THIS_MODULE;//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块
    ret = cdev_add(&cdev_test,dev_num,1);//使用cdev_add()函数进行字符设备的添加
    if(ret < 0 ){
        printk("cdev_add is error\n");
    }
    printk("cdev_add is ok\n");
    return 0;
}

static void __exit module_cdev_exit(void)//驱动出口函数
{
    cdev_del(&cdev_test);//使用cdev_del()函数进行字符设备的删除
    unregister_chrdev_region(dev_num,1);//释放字符驱动设备号 
    printk("module exit \n");
}

module_init(module_cdev_init);//注册入口函数
module_exit(module_cdev_exit);//注册出口函数
MODULE_LICENSE("GPL v2");//同意GPL开源协议
MODULE_AUTHOR("woniu");  //作者信息  
```

## 查看所有已注册的字符设备和其设备号：

```shell
cat /proc/devices
```

# 设备节点

在 Linux 操作系统中一切皆文件，设备访问也是通过文件的方式来进行的，对于用来进行设备访问的文件称之为设备节点，设备节点被创建在/dev 目录下，将内核中注册的设备与用户层进行链接，这样应用程序才能对设备进行访问。

根据设备节点的创建方式不同，分为了手动创建设备节点和自动创建设备节点，下面对两种设备节点创建方式进行介绍。

## 手动创建设备节点

使用 mknod 命令手动创建设备节点，mknod 命令格式为：

> mknod NAME TYPE MAJOR MINOR

参数含义：

> NAME: 要创建的节点名称
>
> TYPE: b 表示块设备，c 表示字符设备，p 表示管道
>
> MAJOR：要链接设备的主设备号
>
> MINOR: 要链接设备的从设备号

例如使用以下命令创建一个名为 device_test 的字符设备节点，链接设备的主设备号和从设备号分别为 236 和 0

> mknod /dev/device_test c 236 0

## 自动创建设备节点

设备文件的自动创建是利用 udev(mdev)机制来实现，多数情况下采用自动创建设备节点的方式。udev(mdev)可以检测系统中硬件设备状态，可以根据系统中硬件设备状态来创建或者删除设备文件。在驱动中首先使用 class_create(…)函数对 class 进行创建，这个类存放于/sys/class/ 目录下，之后使用 device_create(…)函数创建相应的设备，在进行模块加载时，用户空间中的 udev 会自动响应 device_create()函数，寻找对应的类从而创建设备节点。

**class_create(…)**函数

该函数在“内核源码/include/linux/device.h”文件中所引用（由于上一小节中引用的 cdev.h

文件已包含 device.h，所以不需要再重复引用）.

```c
//570行
#define class_create(owner, name) \
({ \
static struct lock_class_key __key; \ __class_create(owner, name, &__key); \
})
```

> **函数作用：**
>
> 用于动态创建设备的逻辑类，并完成部分字段的初始化，然后将其添加进 Linux 内核系统。
>
> **参数含义：**
>
> owner：struct module 结构体类型的指针，指向函数即将创建的这个 struct class 的模块。
>
> 一般赋值为 THIS_MODULE。
>
> name：char 类型的指针，代表即将创建的 struct class 变量的名字。
>
> 返回值：struct class * 类型的结构体。

**class_destroy(...)**函数

该函数在“内核源码/include/linux/device.h”文件中所引用.

> extern void class_destroy**(**struct class *****cls**);**

> **函数作用：**
>
> 用于删除设备的逻辑类，即从 Linux 内核系统中删除设备的逻辑类。
>
> **参数含义：**
>
> owner：struct module 结构体类型的指针，指向函数即将创建的这个 struct class 的模块。
>
> 一般赋值为 THIS_MODULE。
>
> name：char 类型的指针，代表即将创建的 struct class 变量的名字。

**device_create(...)**函数

该函数在“内核源码/include/linux/device.h”文件中所引用

> struct device *****device_create**(**struct class *****cls**,** struct device *****parent**,** dev_t devt**,** void *****drvdata**,** const char *****fmt**, ...);**

> **函数作用：**
>
> 用来在 class 类中下创建一个设备属性文件，udev 会自动识别从而进行设备节点的创建。最终是在/dev/下创建一个设备节点
>
> **参数含义：**
>
> cls：指定所要创建的设备所从属的类。
>
> parent:指定该设备的父设备，如果没有就指定为 NULL。
>
> devt:指定创建设备的设备号。
>
> drvdata:被添加到该设备回调的数据，没有则指定为 NULL。
>
> fmt：添加到系统的设备节点名称。
>
> **返回值：**struct device * 类型结构体

**device_destroy(...)**函数

在“内核源码/include/linux/device.h”文件中所引用

> extern void device_destroy**(**struct class *****cls**,** dev_t devt**);**

> **函数作用：**
>
> 用来删除 class 类中的设备属性文件，udev 会自动识别从而进行设备节点的删除。
>
> **参数含义：**
>
> cls：指定所要创建的设备所从属的类。
>
> devt:指定创建设备的设备号。

实验代码

```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/kdev_t.h>
#include <linux/cdev.h>

static dev_t dev_num;//定义dev_t类型变量dev_num来表示设备号
static struct cdev cdev_test;//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备
static struct file_operations cdev_fops_test = {
    .owner = THIS_MODULE,//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块
};//定义file_operations结构体类型的变量cdev_test_ops
static struct class *class_test;//定于struct class *类型结构体变量class_test，表示要创建的类

static int __init chrdev_fops_init(void)//驱动入口函数
{
	int ret;//定义int类型的变量ret，用来对函数返回值进行判断
    int major,minor;//定义int类型的主设备号major和次设备号minor
	ret = alloc_chrdev_region(&dev_num,0,1,"chrdev_name");//自动获取设备号，设备名chrdev_name
    if (ret  < 0){
        printk("alloc_chrdev_region is error \n");
    }
    printk("alloc_chrdev_region is ok \n");
    major = MAJOR(dev_num);//使用MAJOR()函数获取主设备号
    minor = MINOR(dev_num);//使用MINOR()函数获取次设备号
    printk("major is %d\n",major);
	printk("minor is %d\n",minor);
    cdev_init(&cdev_test,&cdev_fops_test);//使用cdev_init()函数初始化cdev_test结构体，并链接到cdev_test_ops结构体
	cdev_test.owner = THIS_MODULE;//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块
	ret = cdev_add(&cdev_test,dev_num,1); //使用cdev_add()函数进行字符设备的添加
    if (ret < 0){
         printk("cdev_add is error \n");
    }
    printk("cdev_add is ok \n");                                                                                
    class_test  = class_create(THIS_MODULE,"class_test");//使用class_create进行类的创建，类名称为class_test
    device_create(class_test,NULL,dev_num,NULL,"device_test");//使用device_create进行设备的创建，设备名称为device_test
    return 0;
}

static void __exit chrdev_fops_exit(void)//驱动出口函数
{
    cdev_del(&cdev_test);//删除添加的字符设备cdev_test
	unregister_chrdev_region(dev_num,1);//释放字符设备所申请的设备号
    device_destroy(class_test,dev_num);//删除创建的设备
    class_destroy(class_test);//删除创建的类
    printk("module exit \n");
}

module_init(chrdev_fops_init);//注册入口函数
module_exit(chrdev_fops_exit);//注册出口函数
MODULE_LICENSE("GPL v2");//同意GPL开源协议
MODULE_AUTHOR("woniu");//作者信息
```

## 查看所有的设备类

```shell
ls /sys/class/
```

## 查看所有的设备节点

```shell
ls /dev/
```

# 文件操作集file_operations

在进行注册字符设备实验章节中，使用 cdev_init(...)函数对 struct cdev 结构体类型变量和struct file_operations 结构体类型变量相链接，struct file_operations 结构体就是把系统调用和驱动程序关联起来的关键数据结构。该结构体的每一个成员都对应着一个系统调用，读取file_operation 中响应的函数指针，接着把控制权转交给函数，从而完成了 Linux 设备驱动程序的工作。

file_operations 结构体定义在“内核源码/include/linux/fs.h”文件中

> struct module *****owner**;**

owner 是第一个 file_operations 成员，它并不是一个操作, 而一个指向拥有该结构的模块的指针，避免正在操作时被卸载，一般为初始化为 THIS_MODULES (在 <linux/module.h> 中定义的宏)



> ssize_t **(\***read**) (**struct file ***,** char __user ***,** size_t**,** loff_t ***);**

read 函数指针用来从设备中同步读取数据，读取成功返回读取的字节数。与应用程序中的read 函数对应。



> ssize_t **(\***write**) (**struct file ***,** const char __user ***,** size_t**,** 

write 函数指针用来发送数据给设备. 写入成功返回写入的字节数。与应用程序中的 write函数对应。



> long **(\***unlocked_ioctl**) (**struct file ***,** unsigned int**,** unsigned long**);**

unlocked_ioctl 函数指针提供对于设备的控制功能，与应用程序中的 ioctl 函数对应。



> int **(\***open**) (**struct inode ***,** struct file ***);**

open 函数指针用于打开设备,与应用程序中的 open 函数对应。



> int **(\***release**) (**struct inode ***,** struct file ***);**

release 函数指针在 file 结构体释放时被调用



至此对于 file_operations 文件操作集的部分常用函数就介绍完了，填充了部分常用函数的file_operations 结构体如下

```c
static struct file_operations cdev_fops_test = {
	.owner = THIS_MODULE,//将 owner 字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块
	.open = chrdev_open,//将 open 字段指向 chrdev_open(...)函数
	.read = chrdev_read,//将 open 字段指向 chrdev_read(...)函数
	.write = chrdev_write,//将 open 字段指向 chrdev_write(...)函数
	.release = chrdev_release,//将 open 字段指向 chrdev_release(...)函数
 };//定义 file_operations 结构体类型的变量 cdev_test_ops
```



实验代码

```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/kdev_t.h>
#include <linux/cdev.h>

static int chrdev_open(struct inode *inode, struct file *file)
{
	printk("This is chrdev_open \n");
	return 0;
}

static ssize_t chrdev_read(struct file *file,char __user *buf, size_t size, loff_t *off)
{
	printk("This is chrdev_read \n");
	return 0;
}

static ssize_t chrdev_write(struct file *file,const char __user *buf,size_t size,loff_t *off)
{
	printk("This is chrdev_write \n");
	return 0;
}
static int chrdev_release(struct inode *inode, struct file *file)
{
	return 0;
}
static dev_t dev_num;//定义dev_t类型变量dev_num来表示设备号
static struct cdev cdev_test;//定义struct cdev 类型结构体变量cdev_test，表示要注册的字符设备
static struct file_operations cdev_fops_test = {
    .owner = THIS_MODULE,//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块
	.open = chrdev_open,
	.read = chrdev_read,
	.write = chrdev_write,
	.release = chrdev_release,
};//定义file_operations结构体类型的变量cdev_test_ops
static struct class *class_test;//定于struct class *类型结构体变量class_test，表示要创建的类

static int __init chrdev_fops_init(void)//驱动入口函数
{
	int ret;//定义int类型的变量ret，用来对函数返回值进行判断
    int major,minor;//定义int类型的主设备号major和次设备号minor
	ret = alloc_chrdev_region(&dev_num,0,1,"chrdev_name");//自动获取设备号，设备名chrdev_name
    if (ret  < 0){
        printk("alloc_chrdev_region is error \n");
    }
    printk("alloc_chrdev_region is ok \n");
    major = MAJOR(dev_num);//使用MAJOR()函数获取主设备号
    minor = MINOR(dev_num);//使用MINOR()函数获取次设备号
    printk("major is %d\n",major);
	printk("minor is %d\n",minor);
    cdev_init(&cdev_test,&cdev_fops_test);//使用cdev_init()函数初始化cdev_test结构体，并链接到cdev_test_ops结构体
	cdev_test.owner = THIS_MODULE;//将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块
	ret = cdev_add(&cdev_test,dev_num,1); //使用cdev_add()函数进行字符设备的添加
    if (ret < 0){
         printk("cdev_add is error \n");
    }
    printk("cdev_add is ok \n");                                                                                
    class_test  = class_create(THIS_MODULE,"class_test");//使用class_create进行类的创建，类名称为class_test
    device_create(class_test,NULL,dev_num,NULL,"device_test");//使用device_create进行设备的创建，设备名称为device_test
    return 0;
}

static void __exit chrdev_fops_exit(void)//驱动出口函数
{
	device_destroy(class_test,dev_num);//删除创建的设备
    class_destroy(class_test);//删除创建的类
    cdev_del(&cdev_test);//删除添加的字符设备cdev_test
	unregister_chrdev_region(dev_num,1);//释放字符设备所申请的设备号
    printk("module exit \n");
}

module_init(chrdev_fops_init);//注册入口函数
module_exit(chrdev_fops_exit);//注册出口函数
MODULE_LICENSE("GPL v2");//同意GPL开源协议
MODULE_AUTHOR("woniu");//作者信息
```

调用代码

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

int main(int argc,char *argv[])
{
    int fd;//定义int类型的文件描述符
    char buf[32];//定义读取缓冲区buf
    fd=open(argv[1],O_RDWR,0666);//调用open函数，打开输入的第一个参数文件，权限为可读可写
    if(fd<0){
        printf("open is error\n");
        return -1;
    }
    printf("open is ok\n");
	/*如果第二个参数为read，条件成立，调用read函数，对文件进行读取*/                                                                                                                                  
    if(!strcmp(argv[2], "read")){
        read(fd,buf,32);
        }
	/*如果第二个参数为write，条件成立，调用write函数，对文件进行写入*/  
    else if(!strcmp(argv[2], "write")){
        write(fd,"hello\n",6);
    }
    close(fd);//调用close函数，对取消文件描述符到文件的映射
    return 0;
}
```

# 杂项设备驱动

在 Linux 中，把无法归类的五花八门的设备定义成杂项设备。相较于字符设备，杂项设备有以下两个优点:

(1)节省主设备号:杂项设备的主设备号固定为 10，而字符设备不管是动态分配还是静态分配设备号，都会消耗一个主设备号，进而造成了主设备号浪费。当系统中注册了多个 misc 设备驱动时，只需使用子设备号进行区分即可。

(2)使用简单：当使用普通的字符设备驱动时，如果开发人员需要导出操作接口给用户空间，就需要注册对应的字符驱动，并创建字符设备 class 从而自动在/dev 下生成设备节点，而 misc驱动只需要将基本信息通过结构体传递给相应处理函数即可。

在 驱 动 中 使 用 miscdevice 结 构 体 描 述 misc 设 备 ， 该 结 构 体 定 义 在 “ 内 核 源 码/include/linux/miscdevice.h”文件中（在下面的实验代码中需要加入该头文件的引用），具体内容如下所示：

```c
struct miscdevice {
	int minor; /* 子设备号 需要用户填写*/
	const char *name;/* 设备名 需要用户填写*/
	const struct file_operations *fops;/* 设备操作集 需要用户填写*/
	struct list_head list;
	struct device *parent;
	struct device *this_device;
	const struct attribute_group **groups;
	const char *nodename;
	umode_t mode;
};
```

定义一个 misc 设备，一般只需要填充 minor、name、fops 这三个成员变量。minor 指次设备号，可以从“内核源码/include/linux/miscdevice.h”文件中预定义的次设备号挑选，也可以自行定义子设备号（没有被其他设备使用即可），通常情况下将该参数设置为MISC_DYNAMIC_MINOR，表示自动分配子设备号。

name 表示 misc 设备的名字。misc 设备驱动注册成功之后，会在 dev 目录下生成名为 name的设备节点。

fops 指向了 file_operations 的结构体，表示字符设备的操作集合。

## 杂项设备的注册和卸载

不同于字符设备的注册和卸载的繁琐，杂项设备的注册可以直接使用函数 misc_register 函数来完成，杂项设备的卸载可以直接使用 misc_deregister 函数来完成。上述两个函数均定义在“内核源码/include/linux/miscdevice.h”文件当中。

杂项设备的注册：

> **函数原型：**
>
> int misc_register(struct miscdevice *misc)
>
> **函数作用：**
>
> 基于misc_class构造一个设备，将miscdevice结构挂载到misc_list列表上，并初始化与linux
>
> 设备模型相关的结构。进而起到杂项设备注册的作用。
>
> **参数含义：**
>
> misc: 杂项设备的结构体指针
>
> **函数返回值：**申请成功返回 0，申请失败返回负数

杂项设备的卸载：

> **函数原型：**
>
> int misc_deregister(struct miscdevice *misc)
>
> **函数作用：**
>
> 从 mist_list 中删除 miscdevice，进而起到杂项设备卸载的作用。
>
> **参数含义：**
>
> misc: 杂项设备的结构体指针
>
> **函数返回值：**卸载成功返回 0，申请失败返回负数



实验代码

```c
#include <linux/init.h>              //初始化头文件
#include <linux/module.h>            //最基本的文件，支持动态添加和卸载模块。
#include <linux/miscdevice.h>        //注册杂项设备头文件
#include <linux/fs.h>                //注册设备节点的文件结构体

struct file_operations misc_fops = { //文件操作集
    .owner = THIS_MODULE ////将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模
};
struct miscdevice misc_dev = {       //杂项设备结构体
    
    .minor = MISC_DYNAMIC_MINOR,     //动态申请的次设备号
    .name = "test",                  //杂项设备名字是hello_misc
    .fops = &misc_fops,              //文件操作集

};
static int __init misc_init(void)           
{ 
    int ret;
    ret = misc_register(&misc_dev); //在初始化函数中注册杂项设备
    if (ret < 0)
    {
        printk("misc registe is error \n"); //打印注册杂项设备失败
    }
    printk("misc registe is succeed \n");//打印注册杂项设备成功
    return 0;
}
static void __exit misc_exit(void)
{ 

    misc_deregister(&misc_dev);     //在卸载函数中注销杂项设备
    printk(" misc goodbye! \n");
}
module_init(misc_init);
module_exit(misc_exit);
MODULE_LICENSE("GPL v2");//同意GPL开源协议
MODULE_AUTHOR("woniu");//作者信息
```

# 内核空间与用户空间

Linux 系统将可访问的内存空间分为了两个部分，一部分是内核空间，一部分是用户空间。操作系统和驱动程序运行在内核空间（内核态），应用程序运行在用户空间（用户态）。

那么为什么要区分用户空间和内核空间呢？

（1）内核空间中的代码控制了硬件资源，用户空间中的代码只能通过内核暴露的系统调用接口来使用系统中的硬件资源，这样的设计可以保证操作系统自身的安全性和稳定性。

（2）从另一方面来说，内核空间的代码更偏向于系统管理，而用户空间中的代码更偏重业务逻辑实现，俩者的分工不同。

硬件资源管理都是在内核空间完成的，应用程序无法直接对硬件进行操作，只能通过调用相应的内核接口来完成相应的操作。比如应用程序要对磁盘上的一个文件进行读取，应用程序可以向内核发起一个“系统调用”申请——我要读取磁盘上的文件。这个过程其实是通过一个特殊的指令让进程从用户态进入到了内核态。在内核空间中，CPU 可以执行任何命令，包括从磁盘上读取数据，具体过程是先把数据读取到内核空间中，然后再把数据拷贝到用户空间并从内核态切换到用户态。此时应用程序已经从系统调用中返回并拿到了想要的数据，可以继续往下执行了。

进程只有从用户空间切换到内核空间才可以使用系统的硬件资源，切换的方式有三种：系统调用，软中断，硬中断.

![image-20240704201148519](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240704201148519.png)

## 用户空间和内核空间数据交换

内核空间和用户空间的内存是不能互相访问的。但是很多应用程序都需要和内核进行数据的交换，例如应用程序使用 read 函数从驱动中读取数据，使用 write 函数向驱动中写数据，上述功能就需要使用 copy_from_user 和 copy_to_user 俩个函数来完成。copy_from_user 函数是将用户空间的数据拷贝到内核空间。copy_to_user 函数是将内核空间的数据拷贝到用户空间。

这俩个函数定义在了 kernel/include/linux/uaccess.h 文件下。

copy_to_user

> **函数原型：**
>
> unsigned long copy_to_user(void __user *to, const void *from, unsigned long n);
>
> **函数作用：**
>
> 把内核空间的数据复制到用户空间。
>
> **参数含义：**
>
> *to 是用户空间的指针
>
> *from 是内核空间的指针
>
> n 是从内核空间向用户空间拷贝的字节数



copy_from_user

> **函数原型：**
>
> unsigned long copy_from_user(void *to, const void __user *from, unsigned long n)
>
> **函数作用：**
>
> 把用户空间的数据复制到内核空间。
>
> **参数含义：**
>
> *to 是内核空间的指针
>
> *from 是用户空间的指针
>
> n 是从用户空间向内核空间拷贝的字节数



实验代码

```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kdev_t.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>

static dev_t dev_num;  //设备号
static int major = 0;        //主设备号
static int minor = 0;        //次设备号
struct cdev cdev_test;   // cdev

struct class *class;          //类
struct device *device;    //设备

/*打开设备函数*/
static int cdev_test_open(struct inode *inode, struct file *file)
{
    printk("This is cdev_test_open\r\n");
    return 0;
}

/*向设备写入数据函数*/
static ssize_t cdev_test_write(struct file *file, const char __user *buf, size_t size, loff_t *off)
{
    /*本章实验重点******/
    char kbuf[32] = {0};   //定义写入缓存区kbuf
    if (copy_from_user(kbuf, buf, size) != 0) // copy_from_user:用户空间向内核空间传数据
    {
        printk("copy_from_user error\r\n");//打印copy_from_user函数执行失败
        return -1;
    }
    printk("This is cdev_test_write\r\n");

    printk("kbuf is %s\r\n", kbuf);
    return 0;
}

/**从设备读取数据*/
static ssize_t cdev_test_read(struct file *file, char __user *buf, size_t size, loff_t *off)
{
    /*本章实验重点******/
    char kbuf[32] = "This is cdev_test_read!";//定义内核空间数据
    if (copy_to_user(buf, kbuf, strlen(kbuf)) != 0) // copy_to_user:内核空间向用户空间传数据
    {
        printk("copy_to_user error\r\n"); //打印copy_to_user函数执行失败
        return -1;
    }

    printk("This is cdev_test_read\r\n");
    return 0;
}

static int cdev_test_release(struct inode *inode, struct file *file)
{
    printk("This is cdev_test_release\r\n");
    return 0;
}

/*设备操作函数，定义file_operations结构体类型的变量cdev_test_fops*/
struct file_operations cdev_test_fops = {
    .owner = THIS_MODULE, //将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块
    .open = cdev_test_open, //将open字段指向chrdev_open(...)函数
    .read = cdev_test_read,  //将open字段指向chrdev_read(...)函数
    .write = cdev_test_write, //将open字段指向chrdev_write(...)函数
    .release = cdev_test_release, //将open字段指向chrdev_release(...)函数
};

static int __init chr_fops_init(void) //驱动入口函数
{
    /*注册字符设备驱动*/
    int ret;
    /*1 创建设备号*/
    ret = alloc_chrdev_region(&dev_num, 0, 1, "alloc_name"); //动态分配设备号
    if (ret < 0)
    {
        printk("alloc_chrdev_region is error\n");//打印动态分配设备号失败
    }
    printk("alloc_chrdev_region is ok\n");

    major = MAJOR(dev_num); //获取主设备号
    minor = MINOR(dev_num); //获取次设备号

    printk("major is %d \r\n", major); //打印主设备号
    printk("minor is %d \r\n", minor); //打印次设备号
     /*2 初始化cdev*/
    cdev_test.owner = THIS_MODULE;
    cdev_init(&cdev_test, &cdev_test_fops);

    /*3 添加一个cdev,完成字符设备注册到内核*/
    cdev_add(&cdev_test, dev_num, 1);

    /*4 创建类*/
    class = class_create(THIS_MODULE, "test");

    /*5  创建设备*/
    device = device_create(class, NULL, dev_num, NULL, "test");

    return 0;
}

static void __exit chr_fops_exit(void) //驱动出口函数
{
    /*注销字符设备*/
    unregister_chrdev_region(dev_num, 1); //注销设备号
    cdev_del(&cdev_test);                                     //删除cdev
    device_destroy(class, dev_num);               //删除设备
    class_destroy(class);                                        //删除类
}
module_init(chr_fops_init);   //注册入口函数
module_exit(chr_fops_exit);  //注册出口函数
MODULE_LICENSE("GPL v2");
MODULE_AUTHOR("woniu");
```



app

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

int main(int argc, char *argv[])  //主函数
{
    int fd;   //定义int类型的文件描述符
    char buf1[32] = {0}; //定义读取缓存区buf1
    char buf2[32] = "nihao"; //定义写入缓存区buf2
    fd = open("/dev/test", O_RDWR);  //打开字符设备驱动
    if (fd < 0)
    {
        perror("open error \n");
        return fd;
    }
    read(fd, buf1, sizeof(buf1));//从/dev/test文件读取数据
    printf("buf1 is %s \r\n", buf1); //打印读取的数据

    write(fd,buf2,sizeof(buf2));//向/dev/test文件写入数据
    close(fd);
    return 0;
}
```

## 文件私有数据

Linux 中并没有明确规定要使用文件私有数据，但是在 linux 驱动源码中，广泛使用了文件私有数据，这是 Linux 驱动遵循的“潜规则”，实际上也体现了 Linux 面向对象的思想。struct file 结构体中专门为用户留了一个域用于定义私有数据。

文件私有数据的概念在 Linux 驱动中有着非常广泛的应用，文件私有数据就是将私有数据private_data 指向设备结构体。通过它可以将私有数据一路从 open 函数带到 read, write 函数层层传入。一般是在 open 的时候赋值，read、write 时使用。open 函数中私有数据的使用如下所示：

```c
struct device_test dev1;
static int cdev_test_open(struct inode *inode,struct file *file){
	file->private_data=&dev1;
	return 0;
};
```

在上述代码中，定义了一个设备结构体 dev1，然后在 open 函数中，将私有数据 private_data指向了设备结构体 dev1。

我们可以在 read write 函数中通过 private_data 访问设备结构体，如下所示：

```c
static ssize_t cdev_test_write(struct file *file,const char _user *buf, size_t size,loff_t *off_t){
	struct device_test *test_dev=(struct device_test *)file->private_data;
	return 0;
}
```

实验代码

```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kdev_t.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>

struct device_test{
    dev_t dev_num;              //设备号
     int major ;                         //主设备号
    int minor ;                          //次设备号
    struct cdev cdev_test;  // cdev
    struct class *class;         //类
    struct device *device;   //设备
    char kbuf[32];                  //缓存区buf
};

struct  device_test dev1;  //定义一个device_test结构体变量


/*打开设备函数*/
static int cdev_test_open(struct inode *inode, struct file *file)
{
    
    file->private_data=&dev1;  //设置私有数据
    printk("This is cdev_test_open\r\n");

    return 0;
}

/*向设备写入数据函数*/
static ssize_t cdev_test_write(struct file *file, const char __user *buf, size_t size, loff_t *off)
{
     struct device_test *test_dev=(struct device_test *)file->private_data; //在write函数中读取private_data

    if (copy_from_user(test_dev->kbuf, buf, size) != 0) // copy_from_user:用户空间向内核空间传数据
    {
        printk("copy_from_user error\r\n");
        return -1;
    }
    printk("This is cdev_test_write\r\n");

    printk("kbuf is %s\r\n", test_dev->kbuf); //打印kbuf的值
    return 0;
}

/**从设备读取数据*/
static ssize_t cdev_test_read(struct file *file, char __user *buf, size_t size, loff_t *off)
{
    
    struct device_test *test_dev=(struct device_test *)file->private_data;
    
    if (copy_to_user(buf, test_dev->kbuf, strlen( test_dev->kbuf)) != 0) // copy_to_user:内核空间向用户空间传数据
    {
        printk("copy_to_user error\r\n");
        return -1;
    }

    printk("This is cdev_test_read\r\n");
    return 0;
}

static int cdev_test_release(struct inode *inode, struct file *file)
{
    printk("This is cdev_test_release\r\n");
    return 0;
}

/*设备操作函数*/
struct file_operations cdev_test_fops = {
    .owner = THIS_MODULE,         //将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块
    .open = cdev_test_open,         //将open字段指向chrdev_open(...)函数
    .read = cdev_test_read,            //将open字段指向chrdev_read(...)函数
    .write = cdev_test_write,         //将open字段指向chrdev_write(...)函数
    .release = cdev_test_release,//将open字段指向chrdev_release(...)函数
};

static int __init chr_fops_init(void) //驱动入口函数
{
    /*注册字符设备驱动*/
    int ret;
    /*1 创建设备号*/
    ret = alloc_chrdev_region(&dev1.dev_num, 0, 1, "alloc_name"); //动态分配设备号
    if (ret < 0)
    {
        printk("alloc_chrdev_region is error\n");
    }
    printk("alloc_chrdev_region is ok\n");

    dev1.major = MAJOR(dev1.dev_num); //获取主设备号
   dev1.minor = MINOR(dev1.dev_num); //获取次设备号

    printk("major is %d \r\n", dev1.major); //打印主设备号
    printk("minor is %d \r\n", dev1.minor); //打印次设备号
     /*2 初始化cdev*/
    dev1.cdev_test.owner = THIS_MODULE;
    cdev_init(&dev1.cdev_test, &cdev_test_fops);

    /*3 添加一个cdev,完成字符设备注册到内核*/
    cdev_add(&dev1.cdev_test, dev1.dev_num, 1);

    /*4 创建类*/
  dev1. class = class_create(THIS_MODULE, "test");

    /*创建设备*/
  dev1.device = device_create(dev1.class, NULL, dev1.dev_num, NULL, "test");

    return 0;
}

static void __exit chr_fops_exit(void) //驱动出口函数
{
    /*注销字符设备*/
    unregister_chrdev_region(dev1.dev_num, 1); //注销设备号
    cdev_del(&dev1.cdev_test);                 //删除cdev
    device_destroy(dev1.class, dev1.dev_num);       //删除设备
    class_destroy(dev1.class);                 //删除类
}
module_init(chr_fops_init);
module_exit(chr_fops_exit);
MODULE_LICENSE("GPL v2");
MODULE_AUTHOR("woniu");
```

调用代码

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

int main(int argc, char *argv[]) //主函数
{
    int fd;
    char buf1[32] = "nihao";  //定义写入缓存区buf1
    fd = open("/dev/test", O_RDWR); //打开/dev/test设备
    if (fd < 0)
    {
        perror("open error \n");
        return fd;
    }
    write(fd,buf1,sizeof(buf1)); //向/dev/test设备写入数据
    close(fd);
    return 0;
}
```

## 兼容驱动

container_of 在 Linux 内核中是一个常用的宏，用于从包含在某个结构中的指针获得结构本身的指针，通俗地讲就是通过结构体变量中某个成员的首地址进而获得整个结构体变量的首地址。那么可以使用这个函数获取不同设备的地址，来对不同的设备进行操作，从而一个驱动可以兼容不同的设备。

container_of

> **函数原型：**
>
> container_of(ptr,type,member)
>
> **函数作用：**
>
> 通过结构体变量中某个成员的首地址获取到整个结构体变量的首地址。
>
> **参数含义：**
>
> ptr 是结构体变量中某个成员的地址。
>
> type 是结构体的类型
>
> member 是该结构体变量的具体名字

container_of 宏的作用是通过结构体内某个成员变量的地址和该变量名，以及结构体类型。找到该结构体变量的地址。

实验代码

```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kdev_t.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>

struct device_test
{

    dev_t dev_num;             //设备号
    int major;                          //主设备号
    int minor;                         //次设备号
    struct cdev cdev_test; // cdev
    struct class *class;        //类
    struct device *device; //设备
    char kbuf[32];
};

struct device_test dev1;   //定义一个device_test结构体变量dev1
struct device_test dev2;  //定义一个device_test结构体变量dev2

/*打开设备函数*/
static int cdev_test_open(struct inode *inode, struct file *file)
{
    dev1.minor = 0;    //设置dev1的次设备号为0
    dev2.minor = 1;   //设置dev2的次设备号为1

//inode->i_rdev 为该 inode 的设备号，使用container_of函数找到结构体变量dev1 dev2的地址
//然后设置私有数据
    file->private_data = container_of(inode->i_cdev, struct device_test, cdev_test);
    printk("This is cdev_test_open\r\n");

    return 0;
}

/*向设备写入数据函数*/
static ssize_t cdev_test_write(struct file *file, const char __user *buf, size_t size, loff_t *off)
{
    struct device_test *test_dev = (struct device_test *)file->private_data;

    //如果次设备号是0，则为dev1
    if (test_dev->minor == 0)
    {

        if (copy_from_user(test_dev->kbuf, buf, size) != 0) // copy_from_user:用户空间向内核空间传数据
        {
            printk("copy_from_user error\r\n");
            return -1;
        }
        printk(" test_dev->kbuf is %s\r\n", test_dev->kbuf);
    }
    //如果次设备号是1，则为dev2
    else if(test_dev->minor == 1)
    {
        if (copy_from_user(test_dev->kbuf, buf, size) != 0) // copy_from_user:用户空间向内核空间传数据
        {
            printk("copy_from_user error\r\n");
            return -1;
        }
        printk(" test_dev->kbuf is %s\r\n", test_dev->kbuf);
    }
    return 0;
}

/**从设备读取数据*/
static ssize_t cdev_test_read(struct file *file, char __user *buf, size_t size, loff_t *off)
{

    struct device_test *test_dev = (struct device_test *)file->private_data;

    if (copy_to_user(buf, test_dev->kbuf, strlen(test_dev->kbuf)) != 0) // copy_to_user:内核空间向用户空间传数据
    {
        printk("copy_to_user error\r\n");
        return -1;
    }

    printk("This is cdev_test_read\r\n");
    return 0;
}

static int cdev_test_release(struct inode *inode, struct file *file)
{
    printk("This is cdev_test_release\r\n");
    return 0;
}

/*设备操作函数,定义file_operations结构体类型的变量cdev_test_fops*/
struct file_operations cdev_test_fops = {
    .owner = THIS_MODULE, //将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块
    .open = cdev_test_open, //将open字段指向chrdev_open(...)函数
    .read = cdev_test_read, //将open字段指向chrdev_read(...)函数
    .write = cdev_test_write, //将open字段指向chrdev_write(...)函数
    .release = cdev_test_release, //将open字段指向chrdev_release(...)函数
};

static int __init chr_fops_init(void) //驱动入口函数
{
    /*注册字符设备驱动*/
    int ret;
    /*1 创建设备号,,这里注册2个设备号*/
    ret = alloc_chrdev_region(&dev1.dev_num, 0, 2, "alloc_name"); //动态分配设备号
    if (ret < 0)
    {
        printk("alloc_chrdev_region is error\n");
    }
    printk("alloc_chrdev_region is ok\n");

    dev1.major = MAJOR(dev1.dev_num); //获取主设备号
    dev1.minor = MINOR(dev1.dev_num); //获取次设备号

    printk("major is %d \r\n", dev1.major); //打印主设备号
    printk("minor is %d \r\n", dev1.minor); //打印次设备号

    //对设备1进行操作
    /*2 初始化cdev*/
    dev1.cdev_test.owner = THIS_MODULE;
    cdev_init(&dev1.cdev_test, &cdev_test_fops);

    /*3 添加一个cdev,完成字符设备注册到内核*/
    cdev_add(&dev1.cdev_test, dev1.dev_num, 1);

    /*4 创建类*/
    dev1.class = class_create(THIS_MODULE, "test1");

    /*5 创建设备*/
    dev1.device = device_create(dev1.class, NULL, dev1.dev_num, NULL, "test1");

    dev2.major = MAJOR(dev1.dev_num + 1); //获取主设备号
    dev2.minor = MINOR(dev1.dev_num + 1); //获取次设备号

    printk("major is %d \r\n", dev2.major); //打印主设备号
    printk("minor is %d \r\n", dev2.minor); //打印次设备号

    //对设备2进行操作
  /*2 初始化cdev*/
    dev2.cdev_test.owner = THIS_MODULE;
    cdev_init(&dev2.cdev_test, &cdev_test_fops);

    /*3 添加一个cdev,完成字符设备注册到内核*/
    cdev_add(&dev2.cdev_test, dev1.dev_num + 1, 1);

    /*4 创建类*/
    dev2.class = class_create(THIS_MODULE, "test2");

    /*5  创建设备*/
    dev2.device = device_create(dev2.class, NULL, dev1.dev_num + 1, NULL, "test2");

    return 0;
}

static void __exit chr_fops_exit(void) //驱动出口函数
{
    /*注销字符设备*/
    unregister_chrdev_region(dev1.dev_num, 1); //注销设备号
    unregister_chrdev_region(dev1.dev_num + 1, 1); //注销设备号
    cdev_del(&dev1.cdev_test);                 //删除cdev
    cdev_del(&dev2.cdev_test);                     //删除cdev
    device_destroy(dev1.class, dev1.dev_num);  //删除设备
    device_destroy(dev2.class, dev1.dev_num + 1);  //删除设备
    class_destroy(dev1.class);                 //删除类
    class_destroy(dev2.class);                     //删除类
    
}
module_init(chr_fops_init);
module_exit(chr_fops_exit);
MODULE_LICENSE("GPL v2");
MODULE_AUTHOR("woniu");
```

app代码

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

int main(int argc, char *argv[])
{
    int fd1;  //定义设备1的文件描述符
    int fd2;  //定义设备2的文件描述符
    char buf1[32] = "nihao /dev/test1";   //定义写入缓存区buf1
    char buf2[32] = "nihao /dev/test2";   //定义写入缓存区buf2
    fd1 = open("/dev/test1", O_RDWR);  //打开设备1：test1
    if (fd1 < 0)
    {
        perror("open error \n");
        return fd1;
    }
    write(fd1,buf1,sizeof(buf1));  //向设备1写入数据
    close(fd1); //取消文件描述符到文件的映射

    fd2= open("/dev/test2", O_RDWR); //打开设备2：test2
    if (fd2 < 0)
    {
        perror("open error \n");
        return fd2;
    }
    write(fd2,buf2,sizeof(buf2));  //向设备2写入数据
    close(fd2);   //取消文件描述符到文件的映射

    return 0;
}
```

# LED实验

**RK3568的GPIO**

1. GPIO0
   1. A0-A7
   2. B0-B7
   3. C0-C7
   4. D0-D7
2. GPIO1
3. GPIO2
4. GPIO3
5. GPIO4

设置复用关系寄存器，把GPIO0B7引脚设置为GPIO功能



## 点亮开发板上的LED灯GPIO0_B7

1. 通过查看原理图→LED9位于GPIO0_B7

2. 通过查看RK3568技术手册→GPIO0的基地址是0xFDD60000

![Pasted image 20250116174632.png](./assets/Pasted image 20250116174632.png)

3. 通过查看RK3568技术手册的GPIO章节→GPIO0_B7位于GPIO0寄存器的第15位（所以由低16位数据寄存器和低16位方向寄存器控制）

![Pasted image 20250116175000.png](./assets/Pasted image 20250116175000.png)

4. 通过查看RK3568技术手册的GPIO章节→低16位方向寄存器（GPIO_SWPORT_DDR_L）偏移地址：0x0008，所以它的地址就是0xFDD60000+0x0008=0xFDD60008，然后它的高16位控制写使\失能（0失能，1使能），低16位控制的是读写方向（0输入，1输出）

![Pasted image 20250116175114.png](./assets/Pasted image 20250116175114.png)

5. 通过查看RK3568技术手册的GPIO章节→低16位数据寄存器（GPIO_SWPORT_DR_L）偏移地址0x0000，所以它的地址就是0xFDD60000+0x0000=0xFDD60000，然后它的高16位控制写使\失能（0失能，1使能），低16位是电平的状态（0是低，1是高）

![Pasted image 20250116175539.png](./assets/Pasted image 20250116175539.png)












GPIO0B7这个引脚的复用关系寄存器地址为：0xFDC20000+0x000C

值需要把12-14位设置成0

设置方向寄存器

DDR_L  控制A0-B7

DDR_H 控制C0-D7

GPIO0的基地址是：0xFDD60000 ，所以方向控制寄存器的地址是0xFDD60000+0x0008 =0xFDD60008

第15和31位要设置成1

设置数据寄存器

数据寄存器的偏移量是0x0000,也就是说数据寄存器的值是0xFDD60000 

第15和31位要设置成1，表示输出高电平，灯亮  写入0x80008040

第31位为1，第15位为0，表示输出低电平，灯灭 写入0x80000040

![image-20240704204023291](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240704204023291.png)

LED 灯是由 GPIO0_B7 控制的。当 GPIO0_B7 为高电平时，三极管 Q16导通，LED9 点亮。当 GPIO0_B7 为低电平时，三极管 Q16 截止，LED9 不亮。

在接下来的实验中需要对GPIO 进行配置，一般情况下需要对 GPIO 的复用寄存器，方向寄存器，数据寄存器进行配置。接下来我们打开 RK3568 的参考手册 part1 查找这几个寄存器的地址。

打开参考手册 part1 的第三章，GPIOB 的复用寄存器的偏移地址如下

![image-20240704204125330](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240704204125330.png)

搜索 gpio0b7，如下所示，gpio0b7_sel 在 PMU_GRF_GPIO0B_IOMUX_H 上，所以偏移地址为 0x000C。gpio0b7 可以通过控制[14:12]位来选择复用为哪个功能，我们要控制led 灯，所以功能要复用为 gpio。

![image-20240704204159167](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240704204159167.png)

复用寄存器的基地址如下图

![image-20240704204216746](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240704204216746.png)

所以复用寄存器地址=基地址+偏移地址=0xFDC2000C 。使用 io 命令查看此寄存器的地址

> io -r -4 0xFDC2000C

![image-20240704204246899](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240704204246899.png)

寄存器值为 00000001，[14:12]位为 000，如下图（图 18-6）所示，所以默认设置的为 gpio 功能.

打开参考手册 part1 的第 16 章节，数据寄存器的偏移地址如下图

![image-20240704204323227](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240704204323227.png)

GPIO 有四组 GPIO，分别是 GPIOA，GPIOB，GPIOC，GPIOD。每组又以 A0~A7, B0~B7, C0~C7, D0~D7 作为编号区分。GPIO0B7 在 GPIO_SWPORT_DDR_L 上所以，方向寄存器的偏移地址为 0x0008。接着查看 GPIO_SWPORT_DDR_L 寄存器的具体描述，如下图

![image-20240704204403511](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240704204403511.png)

如上图所示，[31:16]位属性是 WO，也就是只可写入。这[31:16]位是写标志位，是低 16 位的写使能。如果低 16 位中某一位要设置输入输入输出，则对应高位写标志也应该设置为 1。 [15：0] 是数据方向控制寄存器低位，如果要设置某个 GPIO 为输出，则对应位置 1，如果要设置某个 GPIO 为输入，则对应位置 0。那么 GPIO0 B7 ，我们要设置第 15 位为输入还是输出，那么对应的[31:16]位写使能也要置 1。

打开参考手册 part1 的 1.1 小节 Address Mapping。

![image-20240704204438910](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240704204438910.png)

![image-20240704204448661](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240704204448661.png)

GPIO0 的基地址为 0xFDD60000。方向寄存器的地址=基地址+偏移地址=0xFDD60000+0x0008=0xFDD60008然后使用 IO 命令查看该寄存器的值，如下所示

![image-20240704204513466](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240704204513466.png)

数据寄存器的偏移地址如下

![image-20240704204602300](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240704204602300.png)

所以数据寄存器的地址为基地址+偏移地址=0xFDD60000。使用 IO 命令查看地址的值，如下所示

![image-20240704204636660](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240704204636660.png)

我们来看一下这个数据寄存器的描述，

![image-20240704204654271](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240704204654271.png)

分析上图的方法和在分析方向寄存器的方法同理，由上图可知，如果要控制第 15 位为高电平（置 1），需要设置 31 位为 1，那么点亮灯，需要向数据寄存器写入 0x8000c040.

如果要灭灯，需要设置第 15 位为 0 ，第 31 位为 1，那么向数据寄存器中写入 0x80004040.

总结：

> * 复用关系寄存器的基地址为 0xFDC20000 ，偏移地址为 000C ，所以要操作的地址为基地
>
> 址+偏移地址=0xFDC2000C
>
> * GPIO 的基地址为 0xFDD60000，偏移地址为 0x0008，所以方向寄存器要操作的地址为基地
>
> 址+偏移地址=0xFDD60008
>
> * GPIO 的基地址为 0xFDD60000，偏移地址为 0x0000，所以数据寄存器要操作的地址为基地
>
> 址+偏移地址=0xFDD60000
>
> * 默认的数据寄存器的值：0x8000c040 亮灯，0x80004040 灭灯



实验代码

```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kdev_t.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/io.h>

#define  GPIO_DR 0xFDD60000

struct device_test{
   
    dev_t dev_num;  //设备号
     int major ;  //主设备号
    int minor ;  //次设备号
    struct cdev cdev_test; // cdev
    struct class *class;   //类
    struct device *device; //设备
    char kbuf[32];
    unsigned int *vir_gpio_dr;
};

struct  device_test dev1;  


/*打开设备函数*/
static int cdev_test_open(struct inode *inode, struct file *file)
{
    file->private_data=&dev1;//设置私有数据
    printk("This is cdev_test_open\r\n");

    return 0;
}

/*向设备写入数据函数*/
static ssize_t cdev_test_write(struct file *file, const char __user *buf, size_t size, loff_t *off)
{
     struct device_test *test_dev=(struct device_test *)file->private_data;

    if (copy_from_user(test_dev->kbuf, buf, size) != 0) // copy_from_user:用户空间向内核空间传数据
    {
        printk("copy_from_user error\r\n");
        return -1;
    }
    if(test_dev->kbuf[0]==1){   //如果应用层传入的数据是1，则打开灯
            *(test_dev->vir_gpio_dr) = 0x8000c040;   //设置数据寄存器的地址
              printk("test_dev->kbuf [0]  is %d\n",test_dev->kbuf[0]);  //打印传入的数据
    }
    else if(test_dev->kbuf[0]==0)  //如果应用层传入的数据是0，则关闭灯
    {
            *(test_dev->vir_gpio_dr) = 0x80004040; //设置数据寄存器的地址
            printk("test_dev->kbuf [0]  is %d\n",test_dev->kbuf[0]); //打印传入的数据
    }
    return 0;
}

/**从设备读取数据*/
static ssize_t cdev_test_read(struct file *file, char __user *buf, size_t size, loff_t *off)
{
    
    struct device_test *test_dev=(struct device_test *)file->private_data;
    
    if (copy_to_user(buf, test_dev->kbuf, strlen( test_dev->kbuf)) != 0) // copy_to_user:内核空间向用户空间传数据
    {
        printk("copy_to_user error\r\n");
        return -1;
    }

    printk("This is cdev_test_read\r\n");
    return 0;
}

static int cdev_test_release(struct inode *inode, struct file *file)
{
    printk("This is cdev_test_release\r\n");
    return 0;
}

/*设备操作函数*/
struct file_operations cdev_test_fops = {
    .owner = THIS_MODULE, //将owner字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块
    .open = cdev_test_open, //将open字段指向chrdev_open(...)函数
    .read = cdev_test_read, //将open字段指向chrdev_read(...)函数
    .write = cdev_test_write, //将open字段指向chrdev_write(...)函数
    .release = cdev_test_release, //将open字段指向chrdev_release(...)函数
};

static int __init chr_fops_init(void) //驱动入口函数
{
    /*注册字符设备驱动*/
    int ret;
    /*1 创建设备号*/
    ret = alloc_chrdev_region(&dev1.dev_num, 0, 1, "alloc_name"); //动态分配设备号
    if (ret < 0)
    {
       goto err_chrdev;
    }
    printk("alloc_chrdev_region is ok\n");

    dev1.major = MAJOR(dev1.dev_num); //获取主设备号
   dev1.minor = MINOR(dev1.dev_num); //获取次设备号

    printk("major is %d \r\n", dev1.major); //打印主设备号
    printk("minor is %d \r\n", dev1.minor); //打印次设备号
     /*2 初始化cdev*/
    dev1.cdev_test.owner = THIS_MODULE;
    cdev_init(&dev1.cdev_test, &cdev_test_fops);

    /*3 添加一个cdev,完成字符设备注册到内核*/
   ret =  cdev_add(&dev1.cdev_test, dev1.dev_num, 1);
    if(ret<0)
    {
        goto  err_chr_add;
    }
    /*4 创建类*/
  dev1. class = class_create(THIS_MODULE, "test");
    if(IS_ERR(dev1.class))
    {
        ret=PTR_ERR(dev1.class);
        goto err_class_create;
    }
    /*5  创建设备*/
  dev1.device = device_create(dev1.class, NULL, dev1.dev_num, NULL, "test");
    if(IS_ERR(dev1.device))
    {
        ret=PTR_ERR(dev1.device);
        goto err_device_create;
    }
/*本实验重点*****/
    dev1.vir_gpio_dr=ioremap(GPIO_DR,4);  //将物理地址转化为虚拟地址
    if(IS_ERR(dev1.vir_gpio_dr))
    {
        ret=PTR_ERR(dev1.vir_gpio_dr);  //PTR_ERR()来返回错误代码
        goto err_ioremap;
    }


return 0;

err_ioremap:
        iounmap(dev1.vir_gpio_dr);

 err_device_create:
        class_destroy(dev1.class);                 //删除类

err_class_create:
       cdev_del(&dev1.cdev_test);                 //删除cdev

err_chr_add:
        unregister_chrdev_region(dev1.dev_num, 1); //注销设备号

err_chrdev:
        return ret;
}




static void __exit chr_fops_exit(void) //驱动出口函数
{
    /*注销字符设备*/
    unregister_chrdev_region(dev1.dev_num, 1); //注销设备号
    cdev_del(&dev1.cdev_test);                 //删除cdev
    device_destroy(dev1.class, dev1.dev_num);       //删除设备
    class_destroy(dev1.class);                 //删除类
}
module_init(chr_fops_init);
module_exit(chr_fops_exit);
MODULE_LICENSE("GPL v2");
MODULE_AUTHOR("woniu");
```

调用代码

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>

int main(int argc, char *argv[])  
{
    int fd;
    char buf[32] = {0};   
    fd = open("/dev/test", O_RDWR);  //打开led驱动
    if (fd < 0)
    {
        perror("open error \n");
        return fd;
    }
    buf[0] =atoi(argv[1]);    // atoi()将字符串转为整型，这里将第一个参数转化为整型后，存放在 buf[0]中
    write(fd,buf,sizeof(buf));  //向/dev/test文件写入数据
    close(fd);     //关闭文件
    return 0;
}
```

## 点亮自定义引脚GPIO4_C6

### 1、查看技术参考手册 Address Mapping 章节，找到GPIO4的基地址

![Pasted image 20250218092232.png](./assets/Pasted image 20250218092232.png)

### 2、查看技术参考手册的 GPIO4C_IOMUX 设置复用关系寄存器

![Pasted image 20250218094217.png](./assets/Pasted image 20250218094217.png)

### 3、查看技术参考手册 Address Mapping章节，找到 SYS_GRF 的基地址

![Pasted image 20250218095423.png](./assets/Pasted image 20250218095423.png)

### 4、计算出 GPIO4C 的复用关系寄存器的地址

**计算出 GPIO4C 的复用关系寄存器的地址：0xFDC60000+0x0074=0xFDC60074**

### 5、

![Pasted image 20250218142913.png](./assets/Pasted image 20250218142913.png)