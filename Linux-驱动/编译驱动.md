# 一、编译驱动的两种方法

## （一）编译成模块

## （二）编译进内核

> 1. 把驱动编译成模块：适合驱动开发
> 2. 把驱动编译进内核：适合生产环境

### Kconfig

图形化配置界面中的每一个界面都会对应一个 Kconfig 文件。所以图形化配置界面的每一级菜单是由 Kconfig 文件来决定的。

图形化配置界面有很多菜单。所以就会有很多 Kconfig 文件，这也就是为什么我们会在内核源码的每个子目录下，都会看到 Kconfig 文件的原因。

1. mainmenu

   mainmenu 顾名思义就是主菜单，也就是我们输入完“make menuconfig”以后默认打开的

   界面，mainmenu 用来设置主菜单的标题。

   > mainmenu "Linux/$(ARCH) $(KERNELVERSION) Kernel Configuration"

   ![image-20240703223420516](./assets/image-20240703223420516.png)

2. source

   source 用于读取另一个 Kconfig 文件，比如“source "init/Kconfig"”就是读取 init 目录下的Kconfig 文件。

3. menu/endmenu

   menu/endmenu 条目用于生成菜单，如下所示，生成了 Watchdog Timer Support的菜单。

   ```shell
   menu "Watchdog Timer Support" 
   config HW_WATCHDOG
   bool
   config WDT
   bool "Enable driver model for watchdog timer drivers" depends on DM
   help
   Enable driver model for watchdog timer. At the moment the API.
   ...... 
   endmenu
   ```

   menu 之后的字符串是菜单名，“menu”是菜单开始的标志，“endmenu”是菜单结束的标志，这俩个是成对出现的。“menu”和“endmenu”之间有很多 config 条目。在 kernel 目录下输入 make menuconfig，如下图（图 7-6）所示，可以看到上述代码描述的"Watchdog TimerSupport"菜单。

   进入“ Watchdog Timer Support ---> ”可以看到很多 config 定义的条目

4. if/endif 

   语句是一个条件判断，定义了一个 if 结构。

   当没有选中 "Enable CAN" 选项时，下面通过 if 判断的 Enable CAN1 选项并不会显示出来。当上一级菜单选中 "Enable CAN" 时，Enable CAN1 选项才会显示。

   ```shell
   menu "Hardware Drivers Config" 
   	menuconfig BSP_USING_CAN
   	bool "Enable CAN" 
   	default n
   	select RT_USING_CAN
   	if BSP_USING_CAN
   		config BSP_USING_CAN1
   			bool "Enable CAN1" default n
   	endif
   endmenu
   ```

5. choice/endchooice

   choice 条目将多个类似的配置选项组合到一起，供用户选择，用户选择是从“choice”开始，从“endchoice”结束，“choice”和“endchoice”之间有很多的 config 条目，这些 config 条目是提供用户选择的。

   ```shell
   choice
     bool "Parade TrueTouch Gen5 MultiTouch Protocol" 
     depends on TOUCHSCREEN_CYPRESS_CYTTSP5
     default TOUCHSCREEN_CYPRESS_CYTTSP5_MT_B
     help
     	This option controls which MultiTouch protocol will be used to
     	report the touch events. 
   config TOUCHSCREEN_CYPRESS_CYTTSP5_MT_A
     bool "Protocol A" 
     help
     	Select to enable MultiTouch touch reporting using protocol A
     	on Parade TrueTouch(tm) Standard Product Generation4 touchscreen
     	controller. 
    config TOUCHSCREEN_CYPRESS_CYTTSP5_MT_B
     bool "Protocol B" 
     help
     	Select to enable MultiTouch touch reporting using protocol B
     	on Parade TrueTouch(tm) Standard Product Generation4 touchscreen
     	controller. 
   endchoice
   ```

   我们在内核目录下输入 make menuconfig 可以看到，如下（图 7-10）所示，“Parade TrueTouchGen5 MultiTouch Protocol”是 choice 选项名称，“Protocol B”是 Kconfig 里面默认选择的。“-->”代表此菜单能进入，需要键盘操作进入。

   ![image-20240703224459969](./assets/image-20240703224459969.png)

   进入“Parade TrueTouch Gen5 MultiTouch Protocol”后，可以看到多选项提供给用户进行选择.

   ![image-20240703224508322](./assets/image-20240703224508322.png)

6. comment

   comment 语句出现在界面的第一行，用于定义一些提示信息。

   > comment "Compiler: $(CC_VERSION_TEXT)" 

​	![image-20240703224555215](./assets/image-20240703224555215.png)

7. config

   使用关键字 config 来定义一个新的选项

   ```shell
   config helloworld
   bool “hello world support” 
   default y
   help
   hello world
   ```

   如上所示，使用 config 关键字定义了一个“helloworld”选项，每个选项都必须指定类型，类型包括 bool，tristate,string,hex,int。最常见的是 bool,tristate,string 这三个。

   > bool 类型取值只有“y”和“n”
   >
   > tristate 类型的变量取值有 3 种：“y”,“n”,“m”
   >
   > string 类型取值为字符串
   >
   > hex 类型取值为十六进制的数据
   >
   > int 类型取值为十进制的数据

   help 表示帮助信息，当我们在图形化界面按下 h 按键，弹出来的就是 help 的内容。

8. depends on

   Kconfig 中 depends on 关键字用来指定依赖关系，当依赖的选项被选中时，当前的配置选项的信息才会在菜单中显示出来，才能操作该选项的内容。举例来说，如下所示，选项 A 依赖选项 B，只有当选项 B 被选中时，选项 A 才可以被选中。

   ```shell
   config A
   depends on B
   ```

9. select

   Kconfig 中 select 关键字用来表示反向依赖关系，当指定当前选项被选中时，此时 select 后面的选项也会被自动选中。举个例子来说，如下所示，在选项 A 被选中的情况下，选项 B 自动被选中。

   ```shell
   config A
   select on B
   ```

10. menuconfig

    menuconfig 可以认为是 config 中的升级版。menuconfig 也是一个正常的配置项，通过自己的配置值来决定另外一组配置项是否作为子菜单的形式显示出来并供用户配置。

    ```shell
    menuconfig NETDEVICES
    default y if UML
    depends on NET
    bool "Network device support"
    ---help---
    if NETDEVICES
    config MII
    tristate
    config NET_CORE
    default y
    bool "Network core driver support"
    ---help--- 
    You can say N here if you do not intend to use any of the
    networking core drivers (i.e. VLAN, bridging, bonding, etc.)
    ```

    以上代码中通过 menuconfig 配置了一个 bool 类型的配置项，在图形化配置界面中显示.

    ![image-20240703224954308](./assets/image-20240703224954308.png)

    当我们选中"Network device support"配置项时，其子菜单被显示出来.

    ![image-20240703225012206](./assets/image-20240703225012206.png)

### .config

我们在图形化配置界面配置好了以后，会得到一个.config 配置文件。在编译内核的时候会根据这个.config 文件来编译内核。这样是不是就实现了通过图像化界面的配置来配置内核呀。用通俗的话来说，Kconfig 就是饭店的菜单，.config 就是客人点完的菜。然后厨师会根据客人点的菜，也就是.config 来做菜，对应的操作就是编译内核。

那.config 是如何产生的呢？对应上面的例子就是要有服务员给我们点菜呀。

当我们使用 make menuconfig 的时候，会通过 mconf 程序去解析 Kconfig 文件，然后生成对应的配置文件.config。所以这个 mconf 就是服务员。

mconf 程序源码在内核源码 scripts/kconfig 目录下，如下图所示，这里不对 Kconfig 文件的解析流程进行分析，感兴趣的同学可以自行分析下 mconf 的源码。

有了.config 配置文件以后，内核就可以根据这个配置文件来编译内核，比如控制某些驱动编译进内核，或者控制某些驱动不编译内核。

### defconfig

defconfig 文件和.config 文件都是 linux 内核的配置文件，defconfig 文件在内核源码的arch/$(ARCH)/configs 目录下，是 Linux 系统默认的配置文件。

比如说瑞芯微平台 Linux 源码默认的配置文件为：kernel/arch/arm64/configs/rockchip_linux_defconfig。

如果.config 文件存在，make menuconfig 界面的默认配置也就是当前.config 文件的配置，

如果修改了图形化配置界面的设置并保存，那么.config 文件会被更新。

如果.config 文件不存在，使用命令“make XXX_defconfig”命令会根据 arch/$(ARCH)/configs目录下的 XXX_defconfig 自动生成.config。make menuconfig 界面的默认配置则为 defconfig 文件中的默认配置，比如说瑞芯微平台 Linux 内核源码目录下输入“make rockchip_linux_defconfig” 会自动生成.config 文件。那么此时 rockchip_linux_defconfig 的配置项和.config 的配置项是相同的。

### 自定义菜单实验

#### 添加菜单

1. 在kernel/drivers/下创建一个woniu目录

2. 在kernel/drivers/char/Kconfig文件中添加

   > source "drivers/woniu/Kconfig"

3. 在kernel/drivers/woniu目录中添加Kconfig文件

   > touch Kconfig

4. 在新建的Kconfig文件中添加以下内容：

   ```shell
   menu "config kunkun"
   config LOOK
   bool "shuai bu shuai"
   default y
   help
           shuai
   
   config HOBBY
   string "ai hao"
   default ctrl
   help
           kunkun
   
   endmenu
   ```

5. 在内核菜单中make menuconfig就可以看到新的菜单

   >  Device Drivers  ---> Character devices  ---> 

   ![image-20240704155533306](./assets/image-20240704155533306.png)

   ![image-20240704155544064](./assets/image-20240704155544064.png)

#### 为菜单关联驱动

> obj-m和obj-y是两个变量，这两个变量中存储了要编译的驱动。
>
> obj-y 里面存储的是要编译进内核的驱动
>
> obj-m 面存储的是要编译成模块的驱动

1. 在kernel/drivers/woniu目录中创建Makefile文件，并添加以下内容

   > obj-$(CONFIG_LOOK) += helloworld.o
   >
   > //$()中的是CONFIG_自己的菜单配置中config后面的值

2. 在上级目录的Makefile文件中添加以下内容

   > obj-y                           += woniu/

3. 进入菜单，配置驱动，复制.config文件覆盖默认配置文件

4. 再一次编译内核，可以看到已经将helloworld.o文件编译出来了

![image-20240704165034196](./assets/image-20240704165034196.png)

5. 烧录镜像，启动开发板，可以看到有输出驱动中的内容。说明驱动已经被编译进了内核

   ![image-20240704165131209](./assets/image-20240704165131209.png)

> 驱动是编译进内核还是编译成模块？
>
> 如果在生产环境，而且希望驱动能自动加载，那就编译进内核。
>
> 在开发阶段，一般都编译成模块。

### 申请字符设备号

> 字符设备：通信的时候以字符的方式传输，就是字符设备。网络的数据传输，led
>
> 块设备：以区域管理为主，像硬盘，U盘。

在 Linux 系统中每一个设备都有相应的设备号，通过该设备号查找对应的设备，从而进行之后的文件操作。设备号有主设备号与次设备号之分，主设备号用来表示一个特定的驱动，次设备号用来管理下面的设备。

> 主设备号用于区别不同类型的设备
>
> 次设备号用于区别不的设备

#### 申请方式

在 Linux 驱动中可以使用以下两种方法进行设备号的申请：

1. 通过 register_chrdev_region(dev_t from, unsigned count, const char *name)函数进行静态申请设备号。

2. 通 过 alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,const char *name)函数进行动态申请设备号。

两个函数在“内核源码/include/linux/fs.h”文件中引用(在编写驱动程序的时候要加入该文件的引用)，

> //2693行
>
> extern int alloc_chrdev_region**(**dev_t ***,** unsigned**,** unsigned**,** const char ***);**
>
> extern int register_chrdev_region**(**dev_t**,** unsigned**,** const char ***);**

静态申请设备号：

> **函数原型：**
>
> register_chrdev_region(dev_t from, unsigned count, const char *name)
>
> **函数作用：**
>
> 静态申请设备号，对指定好的设备号进行申请。
>
> **参数含义：**
>
> from: 自定义的 dev_t 类型设备号
>
> count: 申请设备的数量
>
> name: 申请的设备名称
>
> **函数返回值：**申请成功返回 0，申请失败返回负数

动态申请设备号：

> **函数原型：**
>
> alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,const char *name)
>
> **函数作用：**
>
> 动态申请设备号，内核会自动分配一个未使用的设备号，相较于静态申请设备号，动态申请会避免注册设备号相同引发冲突的问题。
>
> **参数含义**
>
> dev *: 会将申请完成的设备号保存在 dev 变量中
>
> baseminor: 次设备号可申请的最小值
>
> count: 申请设备的数量
>
> name: 申请的设备名称
>
> **函数返回值：**申请成功返回 0，申请失败返回负数

#### 设备号类型

申请的设备号类型为 dev_t ，在“内核源码/include/linux/types.h” 文件中定义。

dev_t 为 u32 类型，而 u32 定义在文件 “内核源码/include/uapi/asm-generic/int-ll64.h”文件中。

__u32 为 unsigned int 类型，所以 dev_t 是一个无符号的 32 位整形类型。其中高 12 位表示主设备号，低 20 位表示次设备号。在“内核源码/include/linux/kdev_t.h”中提供了设备号相关的宏定义。

```c
#define MINORBITS 20 /*次设备号位数*/
#define MINORMASK ((1U << MINORBITS) - 1) /*次设备号掩码*/
#define MAJOR(dev) ((unsigned int) ((dev) >> MINORBITS))/*dev 右移 20 位得到主设备号*/
#define MINOR(dev) ((unsigned int) ((dev) & MINORMASK)) /*与次设备掩码与，得到次设备号*/
#define MKDEV(ma,mi) (((ma) << MINORBITS) | (mi))/*MKDEV 宏将主设备号（ma）左移 20 位，然后与
次设备号（mi）相与，得到设备号*/
```

不论是静态申请设备号还是动态申请设备号都会用到上述宏，例如在静态申请设备号时需要将指定的主设备号和从设备号通过 MKDEV(ma,mi)宏进行设备号的转换，在动态申请设备号时可以用 MAJOR(dev) 和 MINOR(dev)宏将动态申请的设备号转化为主设备号和从设备号。

#### 申请设备号实验

```c
#include <linux/init.h>
#include <linux/module.h>


#include <linux/kdev_t.h>
static int major;//定义静态加载方式时的主设备号参数major
static int minor;//定义静态加载方式时的次设备号参数minor
module_param(major,int,S_IRUGO);//通过驱动模块传参的方式传递主设备号参数major
module_param(minor,int,S_IRUGO);//通过驱动模块传参的方式传递次设备号参数minor
static dev_t dev_num;//定义dev_t类型(32位大小)的变量dev_num

static int __init dev_t_init(void)//驱动入口函数
{
	int ret;//定义int类型的变量ret，用来判断函数返回值
	/*以主设备号进行条件判断，即如果通过驱动传入了major参数则条件成立，进入以下分支*/
	if(major){
    	dev_num = MKDEV(major,minor);//通过MKDEV函数将驱动传参的主设备号和次设备号转换成dev_t类型的设备号
    	printk("major is %d\n",major);
    	printk("minor is %d\n",minor);
    	ret = register_chrdev_region(dev_num,1,"chrdev_name");//通过静态方式进行设备号注册
        if(ret < 0){
            printk("register_chrdev_region is error\n");
        }
        printk("register_chrdev_region is ok\n");
    }
	/*如果没有通过驱动传入major参数，则条件成立，进入以下分支*/
    else{
        ret = alloc_chrdev_region(&dev_num,0,1,"chrdev_num");//通过动态方式进行设备号注册
        if(ret < 0){
            printk("alloc_chrdev_region is error\n");
        }                                                                                                                                              
        printk("alloc_chrdev_region is ok\n");
        major=MAJOR(dev_num);//通过MAJOR()函数进行主设备号获取
        minor=MINOR(dev_num);//通过MINOR()函数进行次设备号获取
        printk("major is %d\n",major);
        printk("minor is %d\n",minor);
    }
    return 0;
}

static void __exit dev_t_exit(void)//驱动出口函数
{
    unregister_chrdev_region(dev_num,1);//注销字符驱动
    printk("module exit \n");
}

module_init(dev_t_init);//注册入口函数
module_exit(dev_t_exit);//注册出口函数
MODULE_LICENSE("GPL v2");//同意GPL开源协议
MODULE_AUTHOR("woniu");  //作者信息

```

查看现有设备号

> cat /proc/devices



```
export ARCH=arm64

cp arch/arm64/configs/rockchip_linux_defconfig.bak arch/arm64/configs/rockchip_linux_defconfig

cp .config arch/arm64/configs/rockchip_linux_defconfig


```