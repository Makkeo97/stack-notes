
> 有的厂商提供的Linux源码可能会把Uboot, Kernel,Rootfs 分开打包
>
> Uboot：是Linux的引导程序，主要作用就是引导内核启动
>
> Kernel：操作系统的内核，驱动主要就是在内核中运行，驱动开发工程师接触的最多
>
> Rootfs（文件系统）：系统开发工程师接触最多。

# RK3568_Linux_SDK 源码介绍

![Pasted image 20250217200200.png](./assets/Pasted image 20250217200200.png)

> *app : 存放上层应用程序的目录，主要是 qcamera/qfm/qplayer/settings 等一些应用程序。
>
> buildroot ：基于 buildroot开发的根文件系统。是一个用来制作根文件系统的工具
>
> build.sh ：编译用的脚本
>
> debian ：基于 debian 10 开发的根文件系统。
>
> device/rockchip ：存放每个平台的一些编译和打包固件的脚步和预备文件。
>
> docs ：存放 RK 开发指导文件、平台支持列表、工具使用文档、Linux 开发指南等。
>
> envsetup.sh ：要修改文件系统时候要设置的环境脚本。
>
> external : 存放相关的库，包括音频，视频等。
>
> kernel ：kernel 源码。
>
> Makefile ：整个 SDK 包编译的 Makefile。
>
> mkfirmware.sh ：固件打包使用的脚本，默认在当前路径下的 rockdev 目录。
>
> prebuilts : 存放交叉编译工具链。
>
> rkbin: 存放固件和工具。
>
> rkflash.sh : linux 下的系统烧录脚本
>
> rockdev：存放编译输出固件的目录(整个 SDK 包编译完成后就会创建)。
>
> tools ：存放固件和工具的目录。
>
> u-boot ：U-boot 源码目录。
>
> yocto：基于 yocto gatesgarth 开发的根文件系统。*

## 系统编译

1. 图形化界面编译

2. 首先在 linux 源码目录下输入 ./build.sh 命令进入编译的 UI 界面 

![Pasted image 20250217201852.png](./assets/Pasted image 20250217201852.png)

3. 然后选择第五个 all，就会进入到文件系统类型选择页面，如下所示

![Pasted image 20250217201957.png](./assets/Pasted image 20250217201957.png)

4. 等很长时间编译完成后在 rockdev 目录下就生成了打包完成的 update.img

5. 也支持单独编译，例如单独编译内核：./build.sh kernel 生成的 boot.img 文件在Kernel目录下

## 单独烧写

以内核为例：从kernel目录中复制boot.img到烧录工具的image目录中

![image-20240703143330582](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240703143330582.png)

## 内核裁剪

## 内核源码

![image-20240702203250300](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240702203250300.png)

> *arch 存放不同平台体系相关代码
> block 存放块设备相关代码
> crypto 存放加密、压缩、CRC 校验等算法相关代码
> Documentation 存放相关说明文档，很多实用文档，包括驱动编写等
> *drivers 存放 Linux 内核设备驱动程序源码。该目录包含众多驱动，目录按照设备类别进行分类，如char、block 、input、i2c、spi、pci、usb 等。
>
> firmware 存放处理器相关的一些特殊固件
> fs 存放虚拟文件系统代码
> *include 存放内核所需、与平台无关的头文件
> init Linux 系统启动初始化相关的代码
> ipc 存放进程间通信代码kernel Linux 内核的核心代码，包含了进程调度子系统，以及和进程调度相关的模块。
> lib 库文件代码， 实现需要在内核中使用的库函数，例如 CRC、FIFO、list、MD5等。
> mm 实现存放内存管理代码
> net 存放网络相关代码
> samples 存放提供的一些内核编程范例
> scripts 存放一些脚本文件
> security 存放系统安全性相关代码
> sound 存放声音、声卡相关驱动
> tools 一些常用工具，如性能剖析、自测试等
> usr 用于生成 initramfs 的代码。
> virt 提供虚拟机技术（KVM 等）的支持

在内核源码目录下输入以下命令，打开图形化配置界面。

> //配置架构，RK3568是arm64架构
>
> export ARCH=arm64
>
> //获取默认配置
>
> make rockchip_linux_defconfig
>
> //打开配置菜单
>
> make menuconfig
>
> //复制.config文件
>
> cp .config arch/arm64/configs/rockchip_linux_defconfig
>
>  Device Drivers  --->  LED Support  --->LED Trigger support  ---> 

打开 menuconfig 图形化配置界面以后，可以使用以下方式进行操作.

![image-20240702210402983](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240702210402983.png)

修改内核日志输出级别：

 Kernel hacking  --->   printk and dmesg options  ---> 

![image-20240703150413832](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240703150413832.png)

修改led出发配置

Device Drivers  ---> [\*] LED Support  ---> -*-   LED Trigger support  ---> 

![image-20240703150707462](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240703150707462.png)

## ubuntu和开发板互传文件

> 前提：开发板和ubuntu在同一网络

7. ubuntu安装nfs

   > apt-get install nfs-kernel-server

8. 修改配置

   > vim /etc/exports
   >
   > //要共享的目录
   >
   > /home/ *(rw,sync,no_root_squash)

   /home/：要共享的目录；“/home/nfs/ ”目录需要自己建，默认 Ubuntu 中是没有的。

   *：代表允许所有的网络段访问；

   rw：是可读写权限；

   sync：是资料同步写入内存和硬盘；

   no_root_squash：是 Ubuntu nfs 客户端分享目录使用者的权限，如果客户端使用的是 root

   用户，那么对于该共享目录而言，该客户端就具有 root 权限；

   其他 Ubuntu nfs 常用的参数有：

   ro：只读访问

   async ：nfs 在写入数据前可以相应请求

   secure： nfs 通过以下的安全 TCP/IP 端口发送

   insecure： nfs 通过 1024 以上的端口发送

   wdelay：如果多个用户要写入 NFS 目录，则归组（默认）

   no_wdelay：如果多个用户要写入 NFS 目录，则立即写入，当使用 async 时，无需此设

   置

   hide：在 nfs 共享目录中不共享妻子目录

   no_hide：共享 nfs 目录的子目录

   subtree_check：如果共享/usr/bin 之类的子目录时，强制 nfs 检查父目录的权限（默认）

   no_subtree_check：和上面相对，不检查父目录权限

   all_squash：共享文件的 UID 和 GID 映射匿名用户 anonymous，适合公用目录

   no_all_squash：保留共享文件的 UID 和 GID（默认）

   root_squash root：用户的所有请求映射成如 anonymous 用户一样的权限（默认）

   no_root_squash root：用户具有根目录的完全管理访问权限

   anonuid=xxx：指定 nfs 服务器/etc/passwd 文件中匿名用户多的 UID

   anongid=xxx：指定 nfs 服务器/etc/passwd 文件中匿名用户的 GID

9. 重启

   > //重启 rpcbind 服务
   >
   > /etc/init.d/rpcbind restart
   >
   > //重启 nfs 服务
   >
   > /etc/init.d/nfs-kernel-server restart
   >
   > //查看是否成功挂载 nfs 目录（这里也可能要重启 ubuntu 才会又挂载目录）
   >
   > showmount -e

10. 挂载

   在开发板串口终端使用以下命令挂载到 nfs 服务器

   > mount -t nfs -o nfsvers=3,nolock 192.168.114.118:/aa/ /mnt/

# 交叉编译

交叉编译器在

> /prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin

配置一个环境变量

> vim /etc/profile
>
> export PATH=$PATH:/aa/rk356x_linux/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin
>
> 配置好之后要source profile 让配置文件生效

编译程序：

> aarch64-linux-gnu-gcc  main.c

# Makefile

make 工具是编译辅助工具， 用来解决使用命令编译工程非常繁琐的问题。
调用这个命令工具： 我们在 windows 上编程使用 ide ， 我们有图形界面， 有相应的按钮，比如说 build或者 run 来编译。 其实 make 这个编译辅助工具使用也是非常简单的， 我们在控制台上直接输入 make 命令，它就会自动调用 make 工具。

Makefile 就是描述了整个工程编译连接等规则的文件。 我们在终端输入完 make 命令之后， 调用 make工具， make 就会在当前目录按照文件名就会找 makefile 文件， Makefile 的命名必须是 makefile 或Makefile ， m 大写小写都是可以的。

![image-20240813143017997](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240813143017997.png)

## Makefile语法

Makefile 文件是由一些列的规则组合而成的，格式如下：

> target（目标文件） ...: prerequisites（依赖的文件） ... 
>
> command（命令）
>
> ...
>
> ...

> main.o：main.c
>
> gcc -c main.c

这条规则的 main.o 是目标文件（将要生成的文件），main.c 是依赖的文件（生成 main.o 需要的文件），“gcc -c main.c”是生成 main.o 需要运行的命令。**Makefile 中每行的脚本如果有缩进的情况，必须使用“Tab”键缩进，切记不能使用空格缩进（这是 Makefile 的语法要求），大家一定要切记！**

![image-20240813143341095](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240813143341095.png)

![image-20240813143352633](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240813143352633.png)

![image-20240813143410689](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240813143410689.png)

然后我们输入命令“ make clean ”就可以直接执行 rm -rf *.o hello 命令。

但是，我们在当前目录下不能和 makefile 目标名一样的文件。比如我在当前目录下创建一个名为 clean的文件，然后执行“ make clean ”命令就会报错。

为了解决这个问题，makefile 引入了一个新的概念，叫做伪目标，我们使用伪目标来声明 clean 就可以避免与当前目录下的同名文件发生冲突。

伪目标格式;

.PHONY：目标

所以，我们可以把上面的代码修改成如下图所示：

![image-20240813143541986](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240813143541986.png)

然后我们在执行 make clean 命令。尽管当前目录下有 clean 同名文件， make clean 命令也可以执行成功。

## **Makefile** **变量和变量赋值**

变量可以对许多地方使用，比如目标，依赖。或者命令。

变量的赋值可以使用：“ = ” “ ？= ” “ := ” “ += ”

变量的使用：通过$() 来完成变量的引用。

![image-20240813143625886](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240813143625886.png)

使用“ ：=” 给变量赋值，是立刻赋值，在执行 var：=aaa 的同时变量值已经被确定了，所以最后打印为 aaabbb，而不是 cccbbb，

![image-20240813143634784](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240813143634784.png)

使用“=”来赋值，是延迟赋值，使用它来赋值是 makefile 里面最后被指定的值。因为我们最后给变量var1 赋值为 ccc ,所以最后打印为 cccbbb ，而不是 aaabbb 

![image-20240813143727560](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240813143727560.png)

使用“?=”来赋值，如果 var1 变量前面没有被赋值，那么就给它赋值为 ccc ，如果前面已经赋值了，就适应前面的值，所以，打印为 aaabbb ,而不是 cccbbb

然后我们注释掉第一行代码，makefile 中的注释为 #

![image-20240813143752494](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240813143752494.png)

![image-20240813143806140](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240813143806140.png)

使用“+=”赋值是追加赋值，是在我们前面定义的好的字符串里面在添加进去新的字符串，所以运行会打印 aaa bbbccc 。不过中间会有空格.

## **自动化变量**

自动化变量就是不用定义且会随着上下程序的不同而发生变化的变量叫做自动化变量。

这里介绍三个最常用的自动化变量：

![image-20240813143920399](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240813143920399.png)

![image-20240813143954742](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240813143954742.png)

使用这个 makefile 虽然也可以成功编译，但是，一旦编译的文件多了，如果我们还这样来编写 makefile就会变得非常复杂。所以，自动化变量就派上用场啦。

接下来我们一步一步的来简化这个 makefile 。

简化一：用变量表示依赖文件

![image-20240813143944143](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240813143944143.png)

后面如果我们在增加依赖文件的话，我们直接在变量 var 后面增加就可以了。

简化二：

使用通配符 % ，和自动化变量 $< 、$@ 代替依赖和目标，简化完如下图所示：

![image-20240813144032040](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240813144032040.png)

简化三：

使用自动化变量 “$^”表示所有文件依赖的列表，简化完如下图所示：

![image-20240813144046761](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240813144046761.png)

## **wildcard** **函数**

格式： $ (wildcard PATTEN)

功能： 展开指定的目录

举例：

在 /home/topeet/test 目录有一个“a.c”的 c 文件和一个 test 的文件夹，在/home/topeet/test/test 文件夹下有一个 “b.c”的文件。

我们在当前目录下创建的 makefile 里面写下如下代码，echo 前面加了@ 符号，echo 这个命令就不显示：

![image-20240813144139641](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240813144139641.png)

![image-20240813144146741](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240813144146741.png)

## **notdir** **函数**

格式： $ (notdir $ (var) )

功能：去掉路径。

举例：

我们在上面的 makefile 中加上以下代码，因为上面的例子我们得到的结果是 ./a.c 和 ./test/b.c 是有路径的，我们可以直接使用这个变量。

![image-20240813144216149](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240813144216149.png)

![image-20240813144229005](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240813144229005.png)

因为 notdir 函数可以去掉路径，所以 /a.c 和 ./test/b.c 去掉路径就得到了 a.c 和 b.c

## **dir** **函数**

格式： $(dir <names...>)

功能：取出目录，这里的目录指的是最后一个反斜杠/ 之前的部分，如果没有反斜杠/就返回当前。

举例：

我们在上面的例子中加入以下代码，如下图所示：

![image-20240813144306655](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240813144306655.png)

因为 var2 的值为 ./a.c 和 ./test/b.c ，所以取出目录就是 ./ 和 ./test ，如下图所示：

![image-20240813144318689](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240813144318689.png)

## **patsubst** **函数**

格式： $(patsubst 原文件，目标文件，文件列表）

功能：替换文件后缀

举例

我们在上面的例子中加入以下代码，如下图所示：

![image-20240813144342619](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240813144342619.png)

这个函数会把 var1 变量的 a.c 和 b.c 的 .c 后缀替换为 .o ，如下图所示：

![image-20240813144357432](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240813144357432.png)

但是这个替换并不会改变当前目录下的后缀名。这个函数能做什么呢？我们可以用这个函数来替换我们的后缀名，进行其他的操作，这个函数都是会配合其他函数来用的。

替换我们可以使用这个函数，也可以使用 $(var：a=b) 这个格式来替换，var 代表我们要替换的文件的名字，a 是原文件，b 是目标文件。我们来改一下上面的代码，如下图所示：

![image-20240813144413912](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240813144413912.png)

![image-20240813144420587](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240813144420587.png)

## **foreach函数**
```json
{
  "configurations": [
    {
      "name": "windows-gcc-x64",
      "includePath": [
        "Z:\\aa\\rk356x_linux\\kernel\\include",
        "Z:\\aa\\rk356x_linux\\kernel\\arch\\arm64\\include",
        "Z:\\aa\\rk356x_linux\\kernel\\arch\\arm64\\include\\generated\\",
        "${workspaceFolder}/**"
      ],
      "defines": [
        "_DEBUG",
        "UNICODE",
        "_UNICODE"
      ],
      "compilerPath": "D:/work/qt/Tools/mingw1120_64/bin/gcc.exe",
      "cStandard": "${default}",
      "cppStandard": "${default}",
      "intelliSenseMode": "windows-gcc-x64"
    }
  ],
  "version": 4
}
```

格式：$（foreach <var>,<list>,<text>）

功能:把参数<list>中的单词逐一取出放到参数<var>所指定的变量中，然后再执行<text> 所包含的表达式。每一次 <text> 会返回一个字符串



因为 var2 变量的值为 ./ 和 ./test ，所以先把 ./ 取出来放在 n 变量，然后再执行 wildcard 函数取出 ./test 和 ./test 下面的 c 文件的路径。所以执行结果如下图所示：

# 驱动开发HelloWorld

#### 搭建开发环境

vscode设置



#### 编写代码

#include <linux/module.h>
#include <linux/kernel.h>
static int __init helloworld_init(void) //驱动入口函数
{
	printk(KERN_EMERG "helloworld_init\r\n");//注意：内核打印用 printk 而不是 printf
	return 0;
}
static void __exit helloworld_exit(void) //驱动出口函数
{
	printk(KERN_EMERG "helloworld_exit\r\n");
}
module_init(helloworld_init); //注册入口函数
module_exit(helloworld_exit); //注册出口函数
MODULE_LICENSE("GPL v2"); //同意 GPL 开源协议
MODULE_AUTHOR("woniu"); //作者信息


#### 将驱动编译为模块

11. 准备交叉编译器

   > gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu

12. 设置交叉编译器的环境变量，可以实现在任意地方都可以直接使用交叉编译器

   > 1. 打开/etc/profile： vim /etc/profile
   >
   > 2. 在最后添加： 
   >
   >    export PATH=$PATH:/home/driver/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/
   >
   > 3. source profile  让它生效

13. 编写Makefile

   ```makefile
   export ARCH=arm64
   #指定交叉编译器的前缀
   export CROSS_COMPILE=aarch64-linux-gnu-
   obj-m+=helloworld.o #helloworld.c 对应.o 文件的名称。名称要保持一致。
   #内核源码所在虚拟机 ubuntu 的实际路径
   KDIR:=/home/kernel
   PWD?=$(shell pwd)
   all:
   	make -C $(KDIR) M=$(PWD) modules #make 操作
   clean:
   	make -C $(KDIR) M=$(PWD) clean #make clean 操作
   ```

   > 第 1 行设置 ARCH 变量为 arm64
   >
   > 第 2 行设置交叉编译器前缀为 aarch64-linux-gnu- 
   >
   > 第 3 行 obj-m += <文件>：将指定的文件（需要是以.o 结尾）设为编译时以模块形式编译
   >
   > 第 4 行是设备树内核的源码路径，请大家根据实际内核路径进行修改。
   >
   > 第 5 行是获取当前目录的变量
   >
   > 第 7 行是编译 make 操作，会进入内核源码的路径，然后把当前路径下的代码编译成模块。
   >
   > 第 9 行是清除编译文件

14. 编译驱动模块

   有了 Makefile 以后，输入“make”命令就可以编译 helloworld 驱动模块.编译完生成 helloworld.ko 目标文件就是我们需要的内核模块。内核模块是以 ko 为后缀名.

   ![image-20240703170106231](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240703170106231.png)

15. 将驱动模块加载进内核

   将内核文件发送到开发板,在 Linux 系统启动以后使用“insmod”命令加载驱动模块。在加载驱动模块的时候会执行驱动入口的函数，也就是helloworld 程 序 中 的 helloworld_init 函 数 ， 所 以 可 以 看 到 打 印 出 来 的 字 符 串 信 息“helloworld_init”。

   > insmod helloworld.ko

   ![image-20240703173938534](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240703173938534.png)

16. 卸载驱动

   如果要卸载 helloworld 内核模块，可以通过“rmmod helloworld”命令来卸载驱动模块，同理在卸载驱动模块的时候会执行驱动出口的函数，所以可以看到驱动出口函数打印出来的字符串信息“helloworld_exit”

   > rmmod helloworld

   ![image-20240703173913047](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240703173913047.png)

17. 列出所有驱动

   lsmod 命令可以列出已经载入 Linux 内核模块，在 helloworld 驱动加载之后，查看内核中加载的模块。

   > lsmod 

   ![image-20240703170649913](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240703170649913.png)

### 驱动传参

#### 驱动模块传参介绍

驱动模块传参是一种可以随时向内核模块传递、修改参数的方法。例如可以传递串口驱动的波特率、数据位数、校验位、停止位等参数，进行功能的设置，以此节省编译模块的时间，大大提高调试速度。

Linux 内核提供了 module_param(name, type, perm)、module_param_array(name, type, nump, perm)宏和 module_param_string(name, string, len, perm)宏，分别进行基本类型、数组和字符串参数的传递。它们定义在 “内核源码/include/linux/moduleparam.h”文件中(在module.h 文件中已经对 export.h 进行引用，所以不需要单独引用 moduleparam.h 文件),

```c
#define module_param(name, type, perm) \
module_param_named(name, name, type, perm)
#define module_param_array(name, type, nump, perm) \
module_param_array_named(name, name, type, nump, perm)
#define module_param_string(name, string, len, perm) \
static const struct kparam_string __param_string_##name \ = { len, string }; \ __module_param_call(MODULE_PARAM_PREFIX, name, \
&param_ops_string, \
.str = &__param_string_##name, perm, -1, 0);\ __MODULE_PARM_TYPE(name, "string")
```

以上宏定义中的 module_param ()函数可以用来进行基本类型参数的传递，传入的三个参数定义如下：

> name：模块参数的名称
>
> type： 模块参数的数据类型
>
> perm： 模块参数的访问权限

参数 type 可以取以下任意一种情况:

> bool **:** 布尔型
>
> inbool **:** 布尔反值
>
> charp**:** 字符指针（相当于 char *,不超过 1024 字节的字符串）
>
> short**:** 短整型
>
> ushort **:** 无符号短整型
>
> int **:** 整型
>
> uint **:** 无符号整型
>
> long **:** 长整型
>
> ulong**:** 无符号长整型。

参数 perm 表示该参数在 sysfs 文件系统中所对应的文件节点的属性，其权限定义在“内核源码/include/linux/stat.h”文件中。可以用宏定义和数字法两种方式来表示。详细宏定义如下所示：

> \#define S_IRUSR 00400 /*文件所有者可读*/
>
> \#define S_IWUSR 00200 /*文件所有者可写*/
>
> \#define S_IXUSR 00100 /*文件所有者可执行*/
>
> \#define S_IRGRP 00040 /*与文件所有者同组的用户可读*/
>
> \#define S_IWGRP 00020 /*与文件所有者同组的用户可写*/
>
> \#define S_IXGRP 00010 /*与文件所有者同组的用户可执行*/
>
> \#define S_IROTH 00004 /*与文件所有者不同组的用户可读*/
>
> \#define S_IWOTH 00002 /*与文件所有者不同组的用户可写*/
>
> \#define S_IXOTH 00001 /*与文件所有者不同组的用户可可执行*/

如果要传递数组类型参数可以使用 module_param_array ()函数，相较于 module_param ()函数多了n_para参数，用来表示传递参数个数;n_para参数值会根据输入的参数个数而改变,n_para的最终值为传递的数组元素个数。最后是 module_param_string(name, string, len, perm)函数，用来传递字符串类型的变量，四个参数的定义如下所示：

> name：外部传入的参数名，即加载模块时的传入值
>
>  string:内部的变量名，即程序内定义的参数名
>
>  len:以 string 命名的 buffer 大小(可以小于 buffer 的大小，但是没有意义)
>
>  perm:模块参数的访问权限

#### 驱动模块传参实验

```c
#include <linux/init.h>
#include <linux/module.h>
static int number;//定义 int 类型变量 number
static char *name;//定义 char 类型变量 name
static int para[8];//定义 int 类型的数组
static char str1[10];//定义 char 类型字符串 str1
static int n_para;//定义 int 类型的用来记录 module_param_array 函数传递数组元素个数的变量 n_para
module_param(number, int, S_IRUGO);//传递 int 类型的参数 number，S_IRUGO 表示权限为可读
module_param(name, charp, S_IRUGO);//传递 char 类型变量 name
module_param_array(para , int , &n_para , S_IRUGO);//传递 int 类型的数组变量 para
module_param_string(str, str1 ,sizeof(str1), S_IRUGO);//传递字符串类型的变量 str1
static int __init parameter_init(void)//驱动入口函数
{
	static int i;
	printk(KERN_EMERG "%d\n",number);
	printk(KERN_EMERG "%s\n",name);
  for(i = 0; i < n_para; i++)
  {
    printk(KERN_EMERG "para[%d] : %d \n", i, para[i]);
  }
	printk(KERN_EMERG "%s\n",str1);
	return 0;
}
static void __exit parameter_exit(void)//驱动出口函数
{
	printk(KERN_EMERG "parameter_exit\n");
}
module_init(parameter_init);//注册入口函数
module_exit(parameter_exit);//注册出口函数
MODULE_LICENSE("GPL v2");//同意 GPL 开源协议
MODULE_AUTHOR("woniu"); //作者信息
```

以上代码将传递 int 类型参数 number、char 类型参数 name、int 类型的数组 para 和 char类型字符串 str1，并在驱动入口函数中，对各个参数进行打印。在下一小节会进行驱动加载测试。

驱动模块传参的命令格式：

> insmod 对应的模块 参数

> insmod parameter.ko number=100 name="woniu" para=0,1,2,3,4,5,6,7 str="niubi"

### 导出内核模块符号

#### 内核模块符号导出介绍

驱动程序编译生成的 ko 文件是相互独立的，即模块之间变量或者函数在正常情况下无法进行互相访问。而一些复杂的驱动模块需要分层进行设计，这时候就需要用到内核模块符号导出。

内核符号导出指的是在内核模块中导出相应的函数和变量，在加载模块时被记录在公共内核符号表中，以供其他模块调用。符号导出所使用的宏为 EXPORT_SYMBOL(sym)和 EXPORT_SYMBOL_GPL(sym)。它们定义在 “内核源码/include/linux/export.h”文件中（在 module.h 文件中已经对 export.h 进行引用，所以不需要单独引用 export.h 文件）,详细定义如下

```c
#define EXPORT_SYMBOL(sym) __EXPORT_SYMBOL(sym, "")
#define EXPORT_SYMBOL_GPL(sym) __EXPORT_SYMBOL(sym, "_gpl")
```

EXPORT_SYMBOL(sym)和 EXPORT_SYMBOL_GPL(sym)两个宏使用方法相同，而 EXPORT_SYMBOL_GPL(sym)导出的模块只能被 GPL 许可的模块使用，所以绝大多数的情况都使用 EXPORT_SYMBOL(sym)进行符号导出。sym 为函数的唯一参数，表示要导出的函数或变量名称。

#### 内核模块符号导出实验

```c
#include <linux/init.h>
#include <linux/module.h>
int num = 10;//定义参数 num
EXPORT_SYMBOL(num);//导出参数 num
int add(int a, int b)//定义数学函数 add()，用来实现加法
{
	return a + b;
}
EXPORT_SYMBOL(add);//导出数学函数 add()
static int __init math_init(void)//驱动入口函数
{
	printk("math_moudle init\n");
return 0;
}
static void __exit math_exit(void)//驱动出口函数
{
	printk("math_module exit\n");
}
module_init(math_init);//注册入口函数
module_exit(math_exit);//注册出口函数
MODULE_LICENSE("GPL");//同意 GPL 开源协议
MODULE_AUTHOR("woniu");//作者信息
```

```c
#include <linux/init.h>
#include <linux/module.h>
extern int num;//导入 int 类型变量 num
extern int add(int a, int b);//导入函数 add
static int __init hello_init(void)//驱动入口函数
{
	static int sum;
	printk("num = %d\n", num);//打印 num 值
	sum = add(3, 4);//使用 add 函数进行 3+4 的运算
	printk("sum = %d\n", sum);//打印 add 函数的运算值
return 0;
}
static void __exit hello_exit(void)//驱动出口函数
{
	printk("Goodbye hello module\n");
}
module_init(hello_init);//注册入口函数
module_exit(hello_exit);//注册出口函数
MODULE_LICENSE("GPL");//同意 GPL 开源协议
MODULE_AUTHOR("woniu");//作者信息
```

程序导入了 int 类型的变量 num 和 add()函数，并在驱动入口函数中打印相应了 num 的参数值并对 add()函数进行了调用。

```makefile
export ARCH=arm64#设置平台架构
export CROSS_COMPILE=aarch64-linux-gnu-#交叉编译器前缀
obj-m := mathmodule.o
obj-m += hello.o
KDIR :=/home/topeet/Linux/linux_sdk/kernel #这里是你的内核目录
PWD ?= $(shell pwd)
all:
	make -C $(KDIR) M=$(PWD) modules #make 操作
clean:
	make -C $(KDIR) M=$(PWD) clean #make clean 操作
```

对于 Makefile 的内容注释已在上图进行添加，这里要注意的是在 hello.c 代码中使用了mathmodule.c 所导出的符号，所以 mathmodule.c 要在 hello.c 之前进行编译，即第 3 行和第 4行顺序不能交换。

然后使用命令“make”进行驱动的编译,编译完后会生成 hello.ko 和 mathmodule.ko 目标文件.

这里要注意的是，由于 hello.ko 依赖于 mathmodule.ko，所以 mathmodule.ko 需要先加载，分别使用以下命令进行模块的加载（加载顺序不能变）。

```shell
insmod mathmodule.ko
insmod hello.ko
```

![image-20240704142408515](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240704142408515.png)

可以看到 hello.ko 驱动加载的时候，mathmodule.ko 模块中定义的 num 参数值和调用 sum()函数的后正确的返回值都被打印了出来。至此内核模块符号导出实验就完成了。

最后可以输入以下命令进行驱动的卸载

```shell
rmmod hello.ko
rmmod mathmodule.ko
```

![image-20240704142429233](https://woniumd.oss-cn-hangzhou.aliyuncs.com/aiot/luozhaoyong/image-20240704142429233.png)

注意：由于 hello.ko 文件使用了 mathmodule.ko 导出的符号，所以要先卸载 hello.ko，卸载完成之后再卸载 mathmodule.ko。
