# 队列
## 队列是什么？
* 本质就是一个简化版本的链表，实现只能从尾部追加数据和头部释放数据的功能，从而让数据具有了队列的特征！
![Pasted image 20241025140702.png](./assets/image-20241025140702.png)
```c
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>

//定义一个数据结构体
typedef struct Data{
    char name[16];
    char phone[16];
    char address[32];
}Data;
//定义一个节点结构体
typedef struct Node{
    Data data;
    struct Node *next;
}Node;
//定义一个队列结构体，里面存放首尾节点和队列长度
typedef struct Queue{
    Node *head;
    Node *end;
    int length;
}Queue;

//创建一个新队列并初始化队列,返回存放队列信息的地址
Queue *creatQueue(){
    Queue *q = malloc(sizeof(Queue));
    q->head=NULL;
    q->end=NULL;
    return q;
}
//创建新节点并返回新节点地址
Node *createNode(Data newdata){
    Node *newNode = malloc(sizeof(Node));
    newNode->data=newdata;
    newNode->next=NULL;
    return newNode;
}
//入队
void push(Queue *q,Data newdata){
    if(q==NULL){return;}//说明没有这个队列,直接返回
    Node *newNode = createNode(newdata);
    if(q->head==NULL){
        q->head=newNode;
        q->end=newNode;
    }else{
        q->end->next=newNode;
        q->end=newNode;
    }
    q->length++;
}
//队首元素出队
Data pop(Queue *q){
    Data output={0};
    if(q==NULL||q->head==NULL){
        return output;
    }
    output=q->head->data;
    if(q->head==q->end){
        free(q->head);
        q->head=NULL;
        q->end=NULL;
    }else{
        Node *oldHead=q->head;
        q->head=q->head->next;
        free(oldHead);
        oldHead=NULL;
    }
    return output;
}
//打印队列
void printfall(Queue *q){
    if(q==NULL){return;}
    Node *current=q->head;
    while(current!=NULL){
        printf("姓名:%s 联系方式:%s 地址:%s\n",current->data.name,current->data.phone,current->data.address);
		current =current->next;
    }
}

int main(){
    Queue *queue = creatQueue();//创建新队列queue并初始化队列
    Data data1={"王一","+86123456789","192.168.1.1"};
    Data data2={"王二","+86222222222","192.168.1.1"};
    Data data3={"王三","+86123456789","192.168.1.1"};
    Data data4={"王四","+86123456789","192.168.1.1"};
    Data data5={"王五","+86123456789","192.168.1.1"};
    push(queue,data1);
    push(queue,data2);
    push(queue,data3);
    push(queue,data4);
    push(queue,data5);
    pop(queue);
    printfall(queue);
    return 0;
}
```
# 双向队列