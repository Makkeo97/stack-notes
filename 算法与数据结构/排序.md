# 冒泡排序
![20240415152043 (1).gif](./assets/20240415152043 (1).gif)
```c
int main(){
int mp[10]={1,2,7,5,6,4,9,8,3,0};
for(int i=0;i<10;i++){//次数依次递减，因为已经把上一个循环最大的放到了最右面！
	for(int j=0;j<10-i-1;j++){//每次都不需要操作最后一位。
		if(mp[j]>mp[j+1]){
			int x = mp[j];
			mp[j]=mp[j+1];
			mp[j+1]=x;
		}
	}
}
    return 0;
}

```
* 内层循环的边界条件(10-i-1)要特别注意！确保不会出现数组越界访问的情况!!!
# 快速排序
* 快速排序（quick sort）是一种基于分治策略的排序算法，运行高效，应用广泛。

* **快速排序的核心操作是哨兵划分**：选择数组中的某个元素（最左边或者最右边的数）作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。具体流程：
1. 选取数组最左端元素作为基准数，初始化两个指针 `i` 和 `j` 分别指向数组的两端。
2. 设置一个循环，在每轮中使用 `i`（`j`）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。
3. 循环执行步骤 `2.` ，直到 `i` 和 `j` 相遇时停止，最后将基准数交换至两个子数组的分界线。

* **哨兵划分完成后**：原数组被划分成三部分：左子数组、基准数、右子数组，且满足“左子数组任意元素 ≤ 基准数 ≤ 右子数组任意元素”。因此，我们接下来只需对这两个子数组进行排序。

* **快速排序的整体流程**：
1. 首先，对原数组执行一次“哨兵划分”，得到未排序的左子数组和右子数组。
2. 然后，对左子数组和右子数组分别递归执行“哨兵划分”。
3. 持续递归，直至子数组长度为 1 时终止，从而完成整个数组的排序。
```c
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

//此函数用于交换两个数字
void swap(int arr[],int i,int j){
	int temp = arr[j];
	arr[j] = arr[i];
	arr[i] = temp;
};

//此函数用于划分两个子数组
int partition(int arr[],int left,int right){
	int i=left,j=right;
	while(i<j){
		while(i<j && arr[j] >= arr[left]){
			j--;
		}
		while(i<j && arr[i] <= arr[left]){
			i++;
		}
		swap(arr,i,j);
	}
	swap(arr,left,i);
	return i;
};

//此函数用于实现快速排序的递归过程与终止判断
void quickSort(int arr[],int left,int right){
	if(left >= right){
		return;
	}
	int divide = partition(arr,left,right);
	quickSort(arr,left,divide-1);
	quickSort(arr,divide+1,right);
}


int main(){
	int nums[10];
	puts("请依次输入10个数字：");
	for(int x=0;x<10;x++){
		scanf("%d",&nums[x]);
	}
	quickSort(nums,0,9);
	for(int x=0;x<10;x++){
		printf("%d  ",nums[x]);
	}

	return 0;
}

```
# 插入排序
* 插入排序主要就是为了实现在每次插入数据的时候数据都能精准插到指定位置上面，而不用后续对整个数据链进行操作。
```c
/* 插入排序 */
void insertionSort(int nums[], int size) {
    // 外循环：已排序区间为 [0, i-1]
    for (int i = 1; i < size; i++) {
        int base = nums[i], j = i - 1;
        // 内循环：将 base 插入到已排序区间 [0, i-1] 中的正确位置
        while (j >= 0 && nums[j] > base) {
            // 将 nums[j] 向右移动一位
            nums[j + 1] = nums[j];
            j--;
        }
        // 将 base 赋值到正确位置
        nums[j + 1] = base;
    }
}
```
