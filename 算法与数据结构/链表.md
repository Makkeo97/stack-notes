# 单链表
## 单链表是什么
* 链表就是利用结构体创造一种节点，他保存了要存放的数据和一个指针，这个指针指向下一个节点的地址，利用指针来搜索到下一个节点，以此来实现空间中不连续数据的有序存放，并且只有数据才会生成节点，这样的话内存利用率很高！
## 如何创建单链表
1. 定义一个结构体，里面包含自己要存放的数据和指向下一个节点的指针
```c
//定义单个用户结构体，需要保存的数据
struct Contact{
    char name[16];
    char phone[16];
    char address[32];
};
//定义每一个节点需要包含的信息
typedef struct Node{
    struct Contact user;
    struct Node *next;
}Node;
```
2. 编写一个函数用于创建并初始化节点（赋予数据，指向下一个节点为NULL）
```c
//创建一个新节点并初始化把第一个数据填进去并返回新节点的地址
Node *createNode(struct Contact Data){
    Node *newNode = malloc(sizeof(Node));
    newNode->user=Data;
    newNode->next=NULL;
    return newNode;
}
```
3. 在链表尾部追加加新节点，需要调用一次初始化用来创建新节点，然后把节点用指针连接起来
```c
//在链表尾部追加新元素
void addData(Node *head,struct Contact Data){
    if(head==NULL){return;}
    Node *newnode = createNode(Data);
    Node *current =head;
    while(current->next!=NULL){//用于找到链表尾
        current=current->next;
    }
    current->next=newnode;
}
```
4. 删除指定的节点，并将前后节点重新连接，如果删除的正好是首节点，就返回新的首节点的地址,因为传进来的指针实际上也是复制了一个包含首数据地址的新指针，所以要用二级指针修改真正的头节点点
```c
//删除指定位置的节点,用名字来查找
void delNode(Node **head,char name[16]){
    if(*head == NULL){return;}
    Node *current = *head;
    Node *prev = NULL;
    while(current->next!=NULL && strcmp (current->user.name,name)!=0){
        prev = current;
        current = current->next;
    }
    if(strcmp(current->user.name,name)==0){
        if(prev==NULL){
            *head=(*head)->next;
        }
        else{
        prev->next=current->next;    
        }
        free(current);
    }
}
```
5. 插入，如过插入的是头节点前面，就需要更新头结点，需要二级指针，如果是中间的，就要把前后重新桥接
```c
//插入节点，用名字来查找
void insNode(Node **head,char name[16],struct Contact Data){
    if(*head==NULL){
        return;
    }
    Node *current = *head;
    Node *prev = NULL;
    Node *newNode = createNode(Data);
    while(current->next!=NULL && strcmp (current->user.name,name)!=0){
        prev = current;
        current = current->next;
    }
     if(strcmp(current->user.name,name)==0){
        if(prev==NULL){
            newNode->next=*head;
            *head=newNode;
        }
        else{
            prev->next=newNode;
            newNode->next=current;
        }
    }

}
```
6. 单链表测试
```c
int main(){
    struct Contact newuser1={"王一","+86123456789","192.168.1.1"};
    struct Contact newuser2={"王二","+86222222222","192.168.1.1"};
    struct Contact newuser3={"王三","+86123456789","192.168.1.1"};
    struct Contact newuser4={"王四","+86123456789","192.168.1.1"};
    struct Contact newuser5={"王五","+86123456789","192.168.1.1"};
    Node *head = createNode(newuser1);
    addData(head,newuser2);
    addData(head,newuser3);
    addData(head,newuser4);
    addData(head,newuser5);
    delNode(&head,"王一");
    delNode(&head,"王三");
    delNode(&head,"王五");
    struct Contact newuser6={"王六","+86123456789","192.168.1.1"};
    struct Contact newuser7={"王七","+86123456789","192.168.1.1"};
    insNode(&head,"王二",newuser6);
    insNode(&head,"王四",newuser7);
    printfAll(head);
    return 0;
}
```
# 双链表
## 双链表是什么
* 和单链表类似，但是节点内部同时保存指向前后两个节点的指针，便于查找前后节点,创建方法也类似
## 如何创建双链表
* 参考创建单链表，只是多了prev的操作，**要注意在删除头结点的时候要把新头节点的prev改成NULL，否则他还指向旧地址，虽然释放了，但不是NULL** 。
```c
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>

//定义单个用户结构体，并重命名结构体
typedef struct Contact{
    char name[16];
    char phone[16];
    char address[32];
}Contact;
//定义节点结构体，包含必要的前指针后指针和存放的数据,并重命名结构体
typedef struct Node{
    Contact user;
    struct Node *prev;
    struct Node *next;
}Node;

//创建新节点并初始化
Node *createNode(Contact Data){
    Node *newnode = malloc(sizeof(Node));
    newnode->user = Data;
    newnode->prev =NULL;
    newnode->next = NULL;
    return newnode;
}
//追加新节点到链表尾部
void addNode(Node *head,Contact Data){
    if(head==NULL){return;}
    Node *newnode = createNode(Data);
    Node *current=head;
    while(current->next != NULL){
        current = current->next;
    }
    current->next=newnode;
    newnode->prev=current;
}
//打印所有元素的数据
void printfAll(Node *head){
    if(head == NULL){return;}
    Node *current=head;
    while(current!=NULL){
        printf("姓名：%s 手机号：%s 地址：%s \n",current->user.name,current->user.phone,current->user.address);
        current=current->next;
    }
}
//删除节点，如果是头节点就更新头节点
void delNode(Node **head,char name[16]){
    if(*head==NULL){return;}
    Node *current=*head;
    while(current->next!=NULL&&strcmp(current->user.name,name)!=0){
        current=current->next;
    }
    if(strcmp(current->user.name,name)==0){
         if(current->prev==NULL){
          *head=current->next;
          (*head)->prev=NULL;
         }
        else{
            current->prev->next=current->next;
             if(current->next!=NULL){
            current->next->prev=current->prev;
            }
        }
         free(current);
    }
}
//修改链表中某个节点的元素
void changeNode(Node *head,char name[16],Contact Data){
    if(head==NULL){return;}
    Node *current=head;
    while(current->next!=NULL && strcmp(current->user.name,name)!=0){
        current=current->next;
    }
    if(strcmp(current->user.name,name)==0){
        current->user=Data;
    }
}
//在链表中指定节点前面插入新的节点
void insNode(Node **head,char name[16],Contact Data){
    if(*head==NULL){return;}
    Node *current=*head; 
    while(current->next!=NULL && strcmp(current->user.name,name)!=0){
        current=current->next;
    }
    if(strcmp(current->user.name,name)==0){
        Node *newNode = createNode(Data);
        if(current->prev==NULL){
            newNode->next=*head;
            (*head)->prev=newNode;
            *head=newNode;
        }
        else{
          current->prev->next=newNode;
            newNode->prev=current->prev;
            current->prev=newNode;
            newNode->next=current;
        }
    }
}
//查找节点，返回数据
Contact searchCon(Node* head,char name[16]){
	Contact Con = {0};
	if(head==NULL){
		return Con ;
	}
	Node * current = head;
	while(current->next!=NULL && strcmp(current->user.name,name)!=0){
		current = current->next;
	}
	if(strcmp(current->user.name,name)==0){
		Con = current->user;
	}
	return Con;

}

int main(){
    Contact newuser1={"王一","+86123456789","192.168.1.1"};
    Contact newuser2={"王二","+86123456789","192.168.1.1"};
    Contact newuser3={"王三","+86123456789","192.168.1.1"};
    Contact newuser4={"王四","+86123456789","192.168.1.1"};
    Contact newuser5={"王五","+86123456789","192.168.1.1"};
    Node *head=createNode(newuser1);
    addNode(head,newuser2);
    addNode(head,newuser3);
    addNode(head,newuser4);
    addNode(head,newuser5);
    delNode(&head,"王一");
    delNode(&head,"王三");
    delNode(&head,"王五");
    Contact changeuser2={"新王二","+86222222222","192.168.1.1"};
    Contact changeuser4={"新王四","+86444444444","192.168.1.1"};
    changeNode(head,"王二",changeuser2);
    changeNode(head,"王四",changeuser4);
    Contact newuser6={"王六","+86666666666","192.168.1.1"};
    Contact newuser7={"王七","+86777777777","192.168.1.1"};
    insNode(&head,"新王二",newuser6);
    insNode(&head,"新王四",newuser7);
    printfAll(head);
    Contact searchData = searchCon(head,"新王四");
	printf("查找到的：姓名：%s 手机号：%s 地址：%s \n",searchData.name,searchData.phone,searchData.address);
    return 0;
}
```
